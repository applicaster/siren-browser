{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 70fb36f0fcc818f75eea","webpack:///./src/main.js","webpack:///./bower_components/angular-bootstrap/ui-bootstrap.js","webpack:///./bower_components/angular-bootstrap/ui-bootstrap-tpls.js","webpack:///./src/body.jade","webpack:///./~/angular-ui-router/release/angular-ui-router.js","webpack:///./src/modules/siren-browser/siren-browser.coffee","webpack:///./~/jade/lib/runtime.js","webpack:///./src/modules/siren-browser/templates/show.jade","webpack:///./src/modules/siren-browser/controllers/showCtrl.coffee","webpack:///./src/modules/siren-browser/directives/actionForm.coffee","webpack:///./src/modules/siren-browser/services/entityResolver.coffee","webpack:///./src/modules/siren-browser/services/sirenBrowserHttp.coffee","webpack:///./bower_components/angular-busy/dist/angular-busy.min.js","webpack:///./src/modules/siren-browser/controllers/actionModalCtrl.coffee","webpack:///./src/modules/siren-browser/templates/actionModal.jade","webpack:///./bower_components/angular-busy/dist/angular-busy.min.css?3c26","webpack:///./bower_components/angular-busy/dist/angular-busy.min.css","webpack:///./src/modules/siren-browser/templates/action-form.jade","webpack:///./src/modules/siren-browser/controllers/actionFromCtrl.coffee","webpack:///./~/fs/index.js","webpack:///./~/style-loader/addStyles.js","webpack:///./~/css-loader/cssToString.js","webpack:///./src/modules/siren-browser/services/actionsUtils.coffee","webpack:///./web_modules/jquery.ba-bbq.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","body","$","html","angular","filter","window","encodeURIComponent","obj","JSON","stringify","key","val","undefined","bootstrap","document","factory","$q","$timeout","$rootScope","findEndEventName","endEventNames","name","transElement","style","$transition","element","trigger","options","deferred","defer","endEventName","animation","transitionEndHandler","$apply","unbind","resolve","bind","isString","addClass","isFunction","isObject","css","promise","cancel","reject","createElement","transitionEndEventNames","WebkitTransition","MozTransition","OTransition","transition","animationEndEventNames","transitionEndEventName","animationEndEventName","directive","link","scope","attrs","doTransition","change","newTransitionDone","currentTransition","newTransition","then","expand","initialAnimSkip","expandDone","removeClass","height","scrollHeight","collapse","collapseDone","offsetWidth","$watch","shouldCollapse","constant","closeOthers","controller","$scope","$attrs","accordionConfig","this","groups","openGroup","isDefined","$eval","forEach","group","isOpen","addGroup","groupScope","that","push","$on","removeGroup","index","indexOf","splice","restrict","transclude","replace","templateUrl","require","heading","isDisabled","setHeading","accordionCtrl","value","toggleOpen","template","attr","accordionGroupCtrl","accordionTransclude","append","closeable","type","close","data","bindHtmlUnsafe","activeClass","toggleEvent","buttonConfig","ctrls","buttonsCtrl","ngModelCtrl","$render","toggleClass","equals","$modelValue","btnRadio","isActive","hasClass","uncheckable","$setViewValue","getTrueValue","getCheckboxValue","btnCheckboxTrue","getFalseValue","btnCheckboxFalse","attributeValue","defaultValue","restartTimer","resetTimer","interval","isNaN","currentTimeout","timerFn","isPlaying","next","pause","self","slides","currentIndex","currentSlide","destroyed","select","nextSlide","direction","goNext","noTransition","$element","slide","extend","entering","leaving","active","$currentTransition","current","transitionDone","nextIndex","indexOfSlide","newIndex","length","prev","play","noPause","addSlide","removeSlide","carouselCtrl","service","$locale","orderByFilter","createParser","format","map","regex","split","formatCodeToRegex","code","i","n","join","apply","RegExp","isValid","year","month","date","parsers","yyyy","yy","y","MMMM","DATETIME_FORMATS","MONTH","MMM","SHORTMONTH","MM","M","dd","d","EEEE","DAY","EEE","SHORTDAY","parse","input","parser","results","match","dt","fields","hours","mapper","Date","$document","$window","getStyle","el","cssprop","currentStyle","getComputedStyle","isStaticPositioned","parentOffsetEl","docDomEl","offsetParent","position","elBCR","offset","offsetParentBCR","top","left","offsetParentEl","clientTop","scrollTop","clientLeft","scrollLeft","boundingClientRect","getBoundingClientRect","width","prop","pageYOffset","documentElement","pageXOffset","positionElements","hostEl","targetEl","positionStr","appendToBody","hostElPos","targetElWidth","targetElHeight","targetElPos","positionStrParts","pos0","pos1","shiftWidth","center","right","shiftHeight","bottom","formatDay","formatMonth","formatYear","formatDayHeader","formatDayTitle","formatMonthTitle","datepickerMode","minMode","maxMode","showWeeks","startingDay","yearRange","minDate","maxDate","$parse","$interpolate","$log","dateFilter","datepickerConfig","noop","modes","$parent","refreshView","uniqueId","$id","Math","floor","random","activeDate","initDate","dateObject","compare","activeDateId","uid","init","ngModelCtrl_","render","error","$setValidity","_refreshView","createDateObject","model","label","selected","disabled","dateDisabled","mode","arr","size","arrays","setFullYear","getFullYear","getMonth","getDate","move","step","years","months","toggleMode","keys",13,32,33,34,35,36,37,38,39,40,"focusElement","focus","keydown","evt","which","shiftKey","altKey","preventDefault","stopPropagation","ctrlKey","handleKeyDown","datepickerCtrl","ctrl","getDaysInMonth","DAYS_IN_MONTH","getDates","startDate","dates","Array","setHours","setDate","getISO8601WeekNumber","checkDate","getDay","time","getTime","setMonth","round","firstDayOfMonth","difference","numDisplayedFromPreviousMonth","firstDate","days","secondary","labels","j","abbr","full","title","rows","weekNumbers","weekNumber","numWeeks","date1","date2","min","getStartingYear","parseInt","range","start","datepickerPopup","currentText","clearText","closeText","closeOnDateSelection","showButtonBar","$compile","$position","dateParser","datepickerPopupConfig","ngModel","cameltoDash","string","$1","toLowerCase","parseDate","viewValue","isDate","dateFormat","datepickerAppendToBody","getText","$observe","popupEl","ng-model","ng-change","datepickerEl","children","datepickerOptions","option","watchData","getAttribute","setAttribute","assign","oldvalue","$parsers","unshift","dateSelection","$viewValue","documentClickBind","event","target","$broadcast","today","$popup","remove","find","after","openClass","openScope","open","dropdownScope","closeDropdown","escapeKeyBind","toggleElement","getToggleElement","contains","focusToggleElement","dropdownConfig","dropdownService","$animate","getIsOpen","$new","setIsOpen","toggleInvoker","onToggle","toggle","arguments","wasOpen","$destroy","dropdownCtrl","toggleDropdown","aria-haspopup","aria-expanded","createNew","stack","add","get","idx","removeTop","backdropClass","animate","$modalStack","tElement","tAttrs","windowClass","querySelectorAll","modal","getTop","backdrop","currentTarget","dismiss","$transclude","clone","empty","$$stackedMap","backdropIndex","topBackdropIndex","opened","openedWindows","removeModalWindow","modalInstance","eq","modalWindow","removeAfterAnimate","modalDomEl","modalScope","OPENED_MODAL_CLASS","checkRemoveBackdrop","backdropDomEl","backdropScopeRef","backdropScope","domEl","emulateTime","done","afterAnimating","timeout","newBackdropIndex","keyboard","currBackdropIndex","angularBackgroundDomEl","angularDomEl","template-url","windowTemplateUrl","window-class","content","result","reason","dismissAll","topModal","provider","$modalProvider","$get","$injector","$http","$templateCache","$controller","getTemplatePromise","when","cache","getResolvePromises","resolves","promisesArr","isArray","invoke","$modal","modalOptions","modalResultDeferred","modalOpenedDeferred","Error","templateAndResolvePromise","all","concat","tplAndVars","$close","$dismiss","ctrlInstance","ctrlLocals","resolveIter","$modalInstance","controllerAs","setNumPages","numPages","config","itemsPerPage","totalPages","calculateTotalPages","ceil","totalItems","max","page","selectPage","noPrevious","noNext","boundaryLinks","directionLinks","firstText","previousText","nextText","lastText","rotate","paginationConfig","makePage","number","text","getPages","currentPage","pages","startPage","endPage","isMaxSized","maxSize","previousPageSet","nextPageSet","paginationCtrl","originalRender","align","pagerConfig","snake_case","regexp","separator","letter","pos","defaultOptions","placement","popupDelay","triggerMap","mouseenter","click","globalOptions","setTriggers","triggers","prefix","defaultTriggerShow","getTriggers","show","hide","directiveName","startSym","startSymbol","endSym","endSymbol","compile","tooltipLinker","toggleTooltipBind","tt_isOpen","hideTooltipBind","showTooltipBind","hasEnableExp","tt_popupDelay","popupTimeout","reposition","transitionTimeout","tt_content","createTooltip","tooltip","display","positionTooltip","$digest","tt_animation","removeTooltip","ttPosition","tt_placement","tt_title","delay","unregisterTriggers","$tooltip","progressConfig","bars","addBar","bar","percent","toFixed","removeBar","progressCtrl","stateOn","stateOff","ratingConfig","ratingStates","buildTemplateObjects","states","rate","readonly","enter","onHover","reset","onLeave","onKeydown","test","ratingCtrl","tabs","selectedTab","tab","onDeselect","onSelect","addTab","removeTab","newActiveIndex","vertical","justified","elm","tabsetCtrl","$transcludeFn","isTabHeading","node","tagName","hasAttribute","tabContentTransclude","contents","headingElement","hourStep","minuteStep","showMeridian","meridians","readonlyInput","mousewheel","timepickerConfig","getHoursFromTemplate","valid","meridian","getMinutesFromTemplate","minutes","pad","toString","refresh","keyboardChange","makeValid","updateTemplate","invalidHours","invalidMinutes","getHours","getMinutes","addMinutes","AMPMS","inputs","hoursInputEl","minutesInputEl","setupMousewheelEvents","setupInputEvents","$error","isScrollingUp","e","originalEvent","delta","wheelDelta","deltaY","detail","incrementHours","decrementHours","incrementMinutes","decrementMinutes","updateHours","updateMinutes","invalidate","setMinutes","toggleMeridian","timepickerCtrl","TYPEAHEAD_REGEXP","itemName","source","viewMapper","modelMapper","typeaheadParser","HOT_KEYS","originalScope","modelCtrl","hasFocus","minSearch","typeaheadMinLength","waitTime","typeaheadWaitMs","isEditable","typeaheadEditable","isLoadingSetter","typeaheadLoading","onSelectCallback","typeaheadOnSelect","inputFormatter","typeaheadInputFormatter","typeaheadAppendToBody","$setModelValue","parserResult","typeahead","popupId","aria-autocomplete","aria-owns","popUpEl","matches","query","typeaheadTemplateUrl","resetMatches","activeIdx","getMatchId","removeAttr","getMatchesAsync","inputValue","locals","onCurrentRequest","timeoutPromise","scheduleSearchWithTimeout","cancelPreviousTimeout","$formatters","modelValue","candidateViewValue","emptyViewValue","item","$item","$model","$label","dismissClickHandler","matchIdx","selectActive","selectMatch","tplUrl","success","tplContent","replaceWith","trim","escapeRegexp","queryToEscape","matchItem","run","put","buf","inherit","parent","extra","prototype","merge","dst","hasOwnProperty","ancestors","first","second","path","objectKeys","object","Object","arraySearch","array","Number","len","from","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","equalForKeys","a","b","k","filterByKeys","values","filtered","$Resolve","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","$$promises","$$values","study","invocables","visit","visited","cycle","plan","annotate","param","pop","isResolve","wait","merged","$$inheritedValues","resolution","fail","$$failure","invocable","onfailure","invocation","proceed","waitParams","dep","promises","ii","$TemplateFactory","fromConfig","fromString","fromUrl","templateProvider","fromProvider","url","response","UrlMatcher","pattern","$value","decode","$UrlMatcherFactory","$$getDefaultValue","addParameter","Type","quoteRegExp","isOptional","flag","paramConfig","cfg","placeholder","compiled","last","segments","segment","exec","substring","$types","$subPattern","lastIndex","search","sourceSearch","sourcePath","strict","caseInsensitive","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","def","injector","enqueue","defaultTypes","int","is","bool","encode","toISOString","slice","strictMode","isMatcher","o","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","interpolate","what","handleIfMatch","handler","$match","$location","$browser","appendBasePath","isHtml5","absolute","baseHref","update","check","rule","handled","defaultPrevented","rules","otherwise","listen","listener","location","interceptDeferred","sync","read","urlMatcher","href","validates","html5Mode","hashPrefix","slash","port","protocol","host","redirect","handlerIsString","strategies","matcher","global","sticky","deferIntercept","$inject","$StateProvider","$urlRouterProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","pathLength","state","queueState","parentName","queue","registerState","lastIndexOf","stateBuilder","$delegates","abstractKey","$stateParams","$state","navigable","transitionTo","isGlob","doesStateMatchGlob","glob","globSegments","MAX_VALUE","l","decorator","func","definition","$view","$resolve","$urlRouter","handleRedirect","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","TransitionSuperseded","to","toParams","resolveState","paramsAreFiltered","globals","views","view","injectables","$template","load","controllerProvider","injectLocals","$$controller","$$state","$$controllerAs","TransitionPrevented","root","reload","notify","go","relative","fromParams","fromPath","toState","redirectResult","toPath","keep","toLocals","ownParams","shouldTriggerReload","reloadOnSearch","resolved","exiting","onExit","onEnter","copy","includes","lossy","nav","context","compositeName","charAt","paramNames","v","own","abstract","$ViewProvider","$templateFactory","defaults","async","$ViewScrollProvider","useAnchorScroll","$anchorScroll","scrollIntoView","$ViewDirective","$uiViewScroll","getService","has","getRenderer","statics","cb","leave","$animator","terminal","priority","cleanupLastView","previousEl","currentScope","currentEl","renderer","updateView","firstTime","newScope","getUiViewName","inheritedData","previousLocals","latestLocals","autoScrollExp","$emit","onloadExp","onload","autoscroll","$ViewDirectiveFill","initial","uiView","parseStateRef","ref","parsed","preparsed","paramExpr","stateContext","stateData","$StateRefDirective","allowedOptions","uiSrefActive","uiSref","isForm","nodeName","optionsOverride","uiSrefOpts","newVal","newHref","activeDirective","$$setStateInfo","button","metaKey","$StateRefActiveDirective","isMatch","uiSrefActiveEq","matchesParams","newState","$IsStateFilter","$IncludedByStateFilter","searchParams","parameters","nTotal","nPath","sub","substr","$stateProvider","sirenEntity","entityResolver","nulls","joinClasses","ac","bc","cls","classes","escaped","escape","terse","String","rethrow","err","filename","lineno","str","message","readFileSync","ex","lines","end","line","curr","showCtrl","alerts","actions","properties","links","entities","openActionModal","action","actionForm","sirenBrowserHttp","EntityResolverClass","cachedEntity","cacheEntity","entity","request","method","SirenBrowserHttpClass","myPromise","status","msg","console","log","delayPromise","durationPromise","delayJustFinished","minDuration","$cgBusyFulfilled","getThen","$then","$promise","denodeify","f","g","h","$watchCollection","cgBusy","$message","$cgBusyIsActive","actionModalCtrl","actionFromCtrl","actionsUtils","submit","formData","serialize","renderOptions","entityUrl","addStylesToDom","styles","domStyle","stylesInDom","refs","parts","addStyle","listToStyles","list","newStyles","media","part","styleElement","head","getElementsByTagName","appendChild","applyToTag","newObj","removeChild","styleSheet","cssText","firstChild","createTextNode","newList","mayRemove","resolveFormContentType","enctype","_proecessUrlecoded","_processJson","deparam","formDataContentTypeConverter","convertedData","processFormData","application/x-www-form-urlencoded","application/json","_urlBuilderGET","queryString","headers","Content-Type","Accept","is_string","arg","curry","args","aps","get_fragment","re_fragment","get_querystring","jq_param_sub","is_fragment","get_func","merge_mode","qs","url_params","hash","re_params_fragment","re_params_querystring","jq_deparam","str_fragment","str_querystring","jq_param_sorted","re_no_escape","fragment_prefix","jq_deparam_sub","url_or_params","coerce","jq_param","jq_fn_sub","force_attr","each","jq_elemUrlAttr","jq_param_fragment","jq_deparam_fragment","jq_bbq_pushState","jq_bbq_getState","ajax_crawlable","decodeURIComponent","jq_bbq","bbq","special","str_hashchange","str_elemUrlAttr","str_href","str_src","elemUrlAttr_cache","sorted","traditional","key_obj","sort","noEscape","chars","ajaxCrawlable","coerce_types","true","false","null","cur","keys_last","shift","iframe","img","form","script","fn","pushState","has_args","getState","removeState","handleObj","new_handler","old_handler","jQuery","fake_onhashchange","doc","doc_mode","documentMode","supports_onhashchange","setup","teardown","stop","poll","history_hash","history_get","last_hash","history_set","timeout_id","setTimeout","fn_retval","clearTimeout","ua","navigator","userAgent","browser","msie","iframe_src","src","one","insertAfter","contentWindow","onpropertychange","propertyName","iframe_doc","domain","write"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t__webpack_require__(4);\n\t__webpack_require__(1);\n\t__webpack_require__(2);\n\t// require(\"siren.coffee\");\n\t__webpack_require__(5);\n\t\n\tvar body = __webpack_require__(3);\n\t$(\"body\").html(body);\n\t\n\tangular.module('MyApp', ['ui.bootstrap','SirenBrowser'])\n\t  .filter('encodeURIComponent', function() {\n\t    return window.encodeURIComponent;\n\t  })\n\t  .filter('prettify', function() {\n\t    return function(obj) {\n\t      return JSON.stringify(obj, function(key, val) {\n\t        return (key === '$$hashKey') ? undefined : val;\n\t      }, 2);\n\t    };\n\t  });\n\t\n\t$(function() {\n\t  angular.bootstrap(document, ['MyApp']);\n\t});\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * angular-ui-bootstrap\n\t * http://angular-ui.github.io/bootstrap/\n\t\n\t * Version: 0.11.2 - 2014-09-26\n\t * License: MIT\n\t */\n\tangular.module(\"ui.bootstrap\", [\"ui.bootstrap.transition\",\"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.bindHtml\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.modal\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\n\tangular.module('ui.bootstrap.transition', [])\n\t\n\t/**\n\t * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.\n\t * @param  {DOMElement} element  The DOMElement that will be animated.\n\t * @param  {string|object|function} trigger  The thing that will cause the transition to start:\n\t *   - As a string, it represents the css class to be added to the element.\n\t *   - As an object, it represents a hash of style attributes to be applied to the element.\n\t *   - As a function, it represents a function to be called that will cause the transition to occur.\n\t * @return {Promise}  A promise that is resolved when the transition finishes.\n\t */\n\t.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {\n\t\n\t  var $transition = function(element, trigger, options) {\n\t    options = options || {};\n\t    var deferred = $q.defer();\n\t    var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];\n\t\n\t    var transitionEndHandler = function(event) {\n\t      $rootScope.$apply(function() {\n\t        element.unbind(endEventName, transitionEndHandler);\n\t        deferred.resolve(element);\n\t      });\n\t    };\n\t\n\t    if (endEventName) {\n\t      element.bind(endEventName, transitionEndHandler);\n\t    }\n\t\n\t    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur\n\t    $timeout(function() {\n\t      if ( angular.isString(trigger) ) {\n\t        element.addClass(trigger);\n\t      } else if ( angular.isFunction(trigger) ) {\n\t        trigger(element);\n\t      } else if ( angular.isObject(trigger) ) {\n\t        element.css(trigger);\n\t      }\n\t      //If browser does not support transitions, instantly resolve\n\t      if ( !endEventName ) {\n\t        deferred.resolve(element);\n\t      }\n\t    });\n\t\n\t    // Add our custom cancel function to the promise that is returned\n\t    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,\n\t    // i.e. it will therefore never raise a transitionEnd event for that transition\n\t    deferred.promise.cancel = function() {\n\t      if ( endEventName ) {\n\t        element.unbind(endEventName, transitionEndHandler);\n\t      }\n\t      deferred.reject('Transition cancelled');\n\t    };\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  // Work out the name of the transitionEnd event\n\t  var transElement = document.createElement('trans');\n\t  var transitionEndEventNames = {\n\t    'WebkitTransition': 'webkitTransitionEnd',\n\t    'MozTransition': 'transitionend',\n\t    'OTransition': 'oTransitionEnd',\n\t    'transition': 'transitionend'\n\t  };\n\t  var animationEndEventNames = {\n\t    'WebkitTransition': 'webkitAnimationEnd',\n\t    'MozTransition': 'animationend',\n\t    'OTransition': 'oAnimationEnd',\n\t    'transition': 'animationend'\n\t  };\n\t  function findEndEventName(endEventNames) {\n\t    for (var name in endEventNames){\n\t      if (transElement.style[name] !== undefined) {\n\t        return endEventNames[name];\n\t      }\n\t    }\n\t  }\n\t  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);\n\t  $transition.animationEndEventName = findEndEventName(animationEndEventNames);\n\t  return $transition;\n\t}]);\n\t\n\tangular.module('ui.bootstrap.collapse', ['ui.bootstrap.transition'])\n\t\n\t  .directive('collapse', ['$transition', function ($transition) {\n\t\n\t    return {\n\t      link: function (scope, element, attrs) {\n\t\n\t        var initialAnimSkip = true;\n\t        var currentTransition;\n\t\n\t        function doTransition(change) {\n\t          var newTransition = $transition(element, change);\n\t          if (currentTransition) {\n\t            currentTransition.cancel();\n\t          }\n\t          currentTransition = newTransition;\n\t          newTransition.then(newTransitionDone, newTransitionDone);\n\t          return newTransition;\n\t\n\t          function newTransitionDone() {\n\t            // Make sure it's this transition, otherwise, leave it alone.\n\t            if (currentTransition === newTransition) {\n\t              currentTransition = undefined;\n\t            }\n\t          }\n\t        }\n\t\n\t        function expand() {\n\t          if (initialAnimSkip) {\n\t            initialAnimSkip = false;\n\t            expandDone();\n\t          } else {\n\t            element.removeClass('collapse').addClass('collapsing');\n\t            doTransition({ height: element[0].scrollHeight + 'px' }).then(expandDone);\n\t          }\n\t        }\n\t\n\t        function expandDone() {\n\t          element.removeClass('collapsing');\n\t          element.addClass('collapse in');\n\t          element.css({height: 'auto'});\n\t        }\n\t\n\t        function collapse() {\n\t          if (initialAnimSkip) {\n\t            initialAnimSkip = false;\n\t            collapseDone();\n\t            element.css({height: 0});\n\t          } else {\n\t            // CSS transitions don't work with height: auto, so we have to manually change the height to a specific value\n\t            element.css({ height: element[0].scrollHeight + 'px' });\n\t            //trigger reflow so a browser realizes that height was updated from auto to a specific value\n\t            var x = element[0].offsetWidth;\n\t\n\t            element.removeClass('collapse in').addClass('collapsing');\n\t\n\t            doTransition({ height: 0 }).then(collapseDone);\n\t          }\n\t        }\n\t\n\t        function collapseDone() {\n\t          element.removeClass('collapsing');\n\t          element.addClass('collapse');\n\t        }\n\t\n\t        scope.$watch(attrs.collapse, function (shouldCollapse) {\n\t          if (shouldCollapse) {\n\t            collapse();\n\t          } else {\n\t            expand();\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\t\n\t.constant('accordionConfig', {\n\t  closeOthers: true\n\t})\n\t\n\t.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {\n\t\n\t  // This array keeps track of the accordion groups\n\t  this.groups = [];\n\t\n\t  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n\t  this.closeOthers = function(openGroup) {\n\t    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n\t    if ( closeOthers ) {\n\t      angular.forEach(this.groups, function (group) {\n\t        if ( group !== openGroup ) {\n\t          group.isOpen = false;\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  // This is called from the accordion-group directive to add itself to the accordion\n\t  this.addGroup = function(groupScope) {\n\t    var that = this;\n\t    this.groups.push(groupScope);\n\t\n\t    groupScope.$on('$destroy', function (event) {\n\t      that.removeGroup(groupScope);\n\t    });\n\t  };\n\t\n\t  // This is called from the accordion-group directive when to remove itself\n\t  this.removeGroup = function(group) {\n\t    var index = this.groups.indexOf(group);\n\t    if ( index !== -1 ) {\n\t      this.groups.splice(index, 1);\n\t    }\n\t  };\n\t\n\t}])\n\t\n\t// The accordion directive simply sets up the directive controller\n\t// and adds an accordion CSS class to itself element.\n\t.directive('accordion', function () {\n\t  return {\n\t    restrict:'EA',\n\t    controller:'AccordionController',\n\t    transclude: true,\n\t    replace: false,\n\t    templateUrl: 'template/accordion/accordion.html'\n\t  };\n\t})\n\t\n\t// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n\t.directive('accordionGroup', function() {\n\t  return {\n\t    require:'^accordion',         // We need this directive to be inside an accordion\n\t    restrict:'EA',\n\t    transclude:true,              // It transcludes the contents of the directive into the template\n\t    replace: true,                // The element containing the directive will be replaced with the template\n\t    templateUrl:'template/accordion/accordion-group.html',\n\t    scope: {\n\t      heading: '@',               // Interpolate the heading attribute onto this scope\n\t      isOpen: '=?',\n\t      isDisabled: '=?'\n\t    },\n\t    controller: function() {\n\t      this.setHeading = function(element) {\n\t        this.heading = element;\n\t      };\n\t    },\n\t    link: function(scope, element, attrs, accordionCtrl) {\n\t      accordionCtrl.addGroup(scope);\n\t\n\t      scope.$watch('isOpen', function(value) {\n\t        if ( value ) {\n\t          accordionCtrl.closeOthers(scope);\n\t        }\n\t      });\n\t\n\t      scope.toggleOpen = function() {\n\t        if ( !scope.isDisabled ) {\n\t          scope.isOpen = !scope.isOpen;\n\t        }\n\t      };\n\t    }\n\t  };\n\t})\n\t\n\t// Use accordion-heading below an accordion-group to provide a heading containing HTML\n\t// <accordion-group>\n\t//   <accordion-heading>Heading containing HTML - <img src=\"...\"></accordion-heading>\n\t// </accordion-group>\n\t.directive('accordionHeading', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    transclude: true,   // Grab the contents to be used as the heading\n\t    template: '',       // In effect remove this element!\n\t    replace: true,\n\t    require: '^accordionGroup',\n\t    link: function(scope, element, attr, accordionGroupCtrl, transclude) {\n\t      // Pass the heading to the accordion-group controller\n\t      // so that it can be transcluded into the right place in the template\n\t      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n\t      accordionGroupCtrl.setHeading(transclude(scope, function() {}));\n\t    }\n\t  };\n\t})\n\t\n\t// Use in the accordion-group template to indicate where you want the heading to be transcluded\n\t// You must provide the property on the accordion-group controller that will hold the transcluded element\n\t// <div class=\"accordion-group\">\n\t//   <div class=\"accordion-heading\" ><a ... accordion-transclude=\"heading\">...</a></div>\n\t//   ...\n\t// </div>\n\t.directive('accordionTransclude', function() {\n\t  return {\n\t    require: '^accordionGroup',\n\t    link: function(scope, element, attr, controller) {\n\t      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n\t        if ( heading ) {\n\t          element.html('');\n\t          element.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.alert', [])\n\t\n\t.controller('AlertController', ['$scope', '$attrs', function ($scope, $attrs) {\n\t  $scope.closeable = 'close' in $attrs;\n\t}])\n\t\n\t.directive('alert', function () {\n\t  return {\n\t    restrict:'EA',\n\t    controller:'AlertController',\n\t    templateUrl:'template/alert/alert.html',\n\t    transclude:true,\n\t    replace:true,\n\t    scope: {\n\t      type: '@',\n\t      close: '&'\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.bindHtml', [])\n\t\n\t  .directive('bindHtmlUnsafe', function () {\n\t    return function (scope, element, attr) {\n\t      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);\n\t      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {\n\t        element.html(value || '');\n\t      });\n\t    };\n\t  });\n\tangular.module('ui.bootstrap.buttons', [])\n\t\n\t.constant('buttonConfig', {\n\t  activeClass: 'active',\n\t  toggleEvent: 'click'\n\t})\n\t\n\t.controller('ButtonsController', ['buttonConfig', function(buttonConfig) {\n\t  this.activeClass = buttonConfig.activeClass || 'active';\n\t  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n\t}])\n\t\n\t.directive('btnRadio', function () {\n\t  return {\n\t    require: ['btnRadio', 'ngModel'],\n\t    controller: 'ButtonsController',\n\t    link: function (scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function () {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n\t      };\n\t\n\t      //ui->model\n\t      element.bind(buttonsCtrl.toggleEvent, function () {\n\t        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\t\n\t        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n\t          scope.$apply(function () {\n\t            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));\n\t            ngModelCtrl.$render();\n\t          });\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('btnCheckbox', function () {\n\t  return {\n\t    require: ['btnCheckbox', 'ngModel'],\n\t    controller: 'ButtonsController',\n\t    link: function (scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      function getTrueValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n\t      }\n\t\n\t      function getFalseValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n\t      }\n\t\n\t      function getCheckboxValue(attributeValue, defaultValue) {\n\t        var val = scope.$eval(attributeValue);\n\t        return angular.isDefined(val) ? val : defaultValue;\n\t      }\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function () {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n\t      };\n\t\n\t      //ui->model\n\t      element.bind(buttonsCtrl.toggleEvent, function () {\n\t        scope.$apply(function () {\n\t          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t          ngModelCtrl.$render();\n\t        });\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\t/**\n\t* @ngdoc overview\n\t* @name ui.bootstrap.carousel\n\t*\n\t* @description\n\t* AngularJS version of an image carousel.\n\t*\n\t*/\n\tangular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition'])\n\t.controller('CarouselController', ['$scope', '$timeout', '$transition', function ($scope, $timeout, $transition) {\n\t  var self = this,\n\t    slides = self.slides = $scope.slides = [],\n\t    currentIndex = -1,\n\t    currentTimeout, isPlaying;\n\t  self.currentSlide = null;\n\t\n\t  var destroyed = false;\n\t  /* direction: \"prev\" or \"next\" */\n\t  self.select = $scope.select = function(nextSlide, direction) {\n\t    var nextIndex = slides.indexOf(nextSlide);\n\t    //Decide direction if it's not given\n\t    if (direction === undefined) {\n\t      direction = nextIndex > currentIndex ? 'next' : 'prev';\n\t    }\n\t    if (nextSlide && nextSlide !== self.currentSlide) {\n\t      if ($scope.$currentTransition) {\n\t        $scope.$currentTransition.cancel();\n\t        //Timeout so ng-class in template has time to fix classes for finished slide\n\t        $timeout(goNext);\n\t      } else {\n\t        goNext();\n\t      }\n\t    }\n\t    function goNext() {\n\t      // Scope has been destroyed, stop here.\n\t      if (destroyed) { return; }\n\t      //If we have a slide to transition from and we have a transition type and we're allowed, go\n\t      if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {\n\t        //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime\n\t        nextSlide.$element.addClass(direction);\n\t        var reflow = nextSlide.$element[0].offsetWidth; //force reflow\n\t\n\t        //Set all other slides to stop doing their stuff for the new transition\n\t        angular.forEach(slides, function(slide) {\n\t          angular.extend(slide, {direction: '', entering: false, leaving: false, active: false});\n\t        });\n\t        angular.extend(nextSlide, {direction: direction, active: true, entering: true});\n\t        angular.extend(self.currentSlide||{}, {direction: direction, leaving: true});\n\t\n\t        $scope.$currentTransition = $transition(nextSlide.$element, {});\n\t        //We have to create new pointers inside a closure since next & current will change\n\t        (function(next,current) {\n\t          $scope.$currentTransition.then(\n\t            function(){ transitionDone(next, current); },\n\t            function(){ transitionDone(next, current); }\n\t          );\n\t        }(nextSlide, self.currentSlide));\n\t      } else {\n\t        transitionDone(nextSlide, self.currentSlide);\n\t      }\n\t      self.currentSlide = nextSlide;\n\t      currentIndex = nextIndex;\n\t      //every time you change slides, reset the timer\n\t      restartTimer();\n\t    }\n\t    function transitionDone(next, current) {\n\t      angular.extend(next, {direction: '', active: true, leaving: false, entering: false});\n\t      angular.extend(current||{}, {direction: '', active: false, leaving: false, entering: false});\n\t      $scope.$currentTransition = null;\n\t    }\n\t  };\n\t  $scope.$on('$destroy', function () {\n\t    destroyed = true;\n\t  });\n\t\n\t  /* Allow outside people to call indexOf on slides array */\n\t  self.indexOfSlide = function(slide) {\n\t    return slides.indexOf(slide);\n\t  };\n\t\n\t  $scope.next = function() {\n\t    var newIndex = (currentIndex + 1) % slides.length;\n\t\n\t    //Prevent this user-triggered transition from occurring if there is already one in progress\n\t    if (!$scope.$currentTransition) {\n\t      return self.select(slides[newIndex], 'next');\n\t    }\n\t  };\n\t\n\t  $scope.prev = function() {\n\t    var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;\n\t\n\t    //Prevent this user-triggered transition from occurring if there is already one in progress\n\t    if (!$scope.$currentTransition) {\n\t      return self.select(slides[newIndex], 'prev');\n\t    }\n\t  };\n\t\n\t  $scope.isActive = function(slide) {\n\t     return self.currentSlide === slide;\n\t  };\n\t\n\t  $scope.$watch('interval', restartTimer);\n\t  $scope.$on('$destroy', resetTimer);\n\t\n\t  function restartTimer() {\n\t    resetTimer();\n\t    var interval = +$scope.interval;\n\t    if (!isNaN(interval) && interval>=0) {\n\t      currentTimeout = $timeout(timerFn, interval);\n\t    }\n\t  }\n\t\n\t  function resetTimer() {\n\t    if (currentTimeout) {\n\t      $timeout.cancel(currentTimeout);\n\t      currentTimeout = null;\n\t    }\n\t  }\n\t\n\t  function timerFn() {\n\t    if (isPlaying) {\n\t      $scope.next();\n\t      restartTimer();\n\t    } else {\n\t      $scope.pause();\n\t    }\n\t  }\n\t\n\t  $scope.play = function() {\n\t    if (!isPlaying) {\n\t      isPlaying = true;\n\t      restartTimer();\n\t    }\n\t  };\n\t  $scope.pause = function() {\n\t    if (!$scope.noPause) {\n\t      isPlaying = false;\n\t      resetTimer();\n\t    }\n\t  };\n\t\n\t  self.addSlide = function(slide, element) {\n\t    slide.$element = element;\n\t    slides.push(slide);\n\t    //if this is the first slide or the slide is set to active, select it\n\t    if(slides.length === 1 || slide.active) {\n\t      self.select(slides[slides.length-1]);\n\t      if (slides.length == 1) {\n\t        $scope.play();\n\t      }\n\t    } else {\n\t      slide.active = false;\n\t    }\n\t  };\n\t\n\t  self.removeSlide = function(slide) {\n\t    //get the index of the slide inside the carousel\n\t    var index = slides.indexOf(slide);\n\t    slides.splice(index, 1);\n\t    if (slides.length > 0 && slide.active) {\n\t      if (index >= slides.length) {\n\t        self.select(slides[index-1]);\n\t      } else {\n\t        self.select(slides[index]);\n\t      }\n\t    } else if (currentIndex > index) {\n\t      currentIndex--;\n\t    }\n\t  };\n\t\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.carousel.directive:carousel\n\t * @restrict EA\n\t *\n\t * @description\n\t * Carousel is the outer container for a set of image 'slides' to showcase.\n\t *\n\t * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\n\t * @param {boolean=} noTransition Whether to disable transitions on the carousel.\n\t * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <carousel>\n\t      <slide>\n\t        <img src=\"http://placekitten.com/150/150\" style=\"margin:auto;\">\n\t        <div class=\"carousel-caption\">\n\t          <p>Beautiful!</p>\n\t        </div>\n\t      </slide>\n\t      <slide>\n\t        <img src=\"http://placekitten.com/100/150\" style=\"margin:auto;\">\n\t        <div class=\"carousel-caption\">\n\t          <p>D'aww!</p>\n\t        </div>\n\t      </slide>\n\t    </carousel>\n\t  </file>\n\t  <file name=\"demo.css\">\n\t    .carousel-indicators {\n\t      top: auto;\n\t      bottom: 15px;\n\t    }\n\t  </file>\n\t</example>\n\t */\n\t.directive('carousel', [function() {\n\t  return {\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    controller: 'CarouselController',\n\t    require: 'carousel',\n\t    templateUrl: 'template/carousel/carousel.html',\n\t    scope: {\n\t      interval: '=',\n\t      noTransition: '=',\n\t      noPause: '='\n\t    }\n\t  };\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.carousel.directive:slide\n\t * @restrict EA\n\t *\n\t * @description\n\t * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\n\t *\n\t * @param {boolean=} active Model binding, whether or not this slide is currently active.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t<div ng-controller=\"CarouselDemoCtrl\">\n\t  <carousel>\n\t    <slide ng-repeat=\"slide in slides\" active=\"slide.active\">\n\t      <img ng-src=\"{{slide.image}}\" style=\"margin:auto;\">\n\t      <div class=\"carousel-caption\">\n\t        <h4>Slide {{$index}}</h4>\n\t        <p>{{slide.text}}</p>\n\t      </div>\n\t    </slide>\n\t  </carousel>\n\t  Interval, in milliseconds: <input type=\"number\" ng-model=\"myInterval\">\n\t  <br />Enter a negative number to stop the interval.\n\t</div>\n\t  </file>\n\t  <file name=\"script.js\">\n\tfunction CarouselDemoCtrl($scope) {\n\t  $scope.myInterval = 5000;\n\t}\n\t  </file>\n\t  <file name=\"demo.css\">\n\t    .carousel-indicators {\n\t      top: auto;\n\t      bottom: 15px;\n\t    }\n\t  </file>\n\t</example>\n\t*/\n\t\n\t.directive('slide', function() {\n\t  return {\n\t    require: '^carousel',\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    templateUrl: 'template/carousel/slide.html',\n\t    scope: {\n\t      active: '=?'\n\t    },\n\t    link: function (scope, element, attrs, carouselCtrl) {\n\t      carouselCtrl.addSlide(scope, element);\n\t      //when the scope is destroyed then remove the slide from the current slides array\n\t      scope.$on('$destroy', function() {\n\t        carouselCtrl.removeSlide(scope);\n\t      });\n\t\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          carouselCtrl.select(scope);\n\t        }\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.dateparser', [])\n\t\n\t.service('dateParser', ['$locale', 'orderByFilter', function($locale, orderByFilter) {\n\t\n\t  this.parsers = {};\n\t\n\t  var formatCodeToRegex = {\n\t    'yyyy': {\n\t      regex: '\\\\d{4}',\n\t      apply: function(value) { this.year = +value; }\n\t    },\n\t    'yy': {\n\t      regex: '\\\\d{2}',\n\t      apply: function(value) { this.year = +value + 2000; }\n\t    },\n\t    'y': {\n\t      regex: '\\\\d{1,4}',\n\t      apply: function(value) { this.year = +value; }\n\t    },\n\t    'MMMM': {\n\t      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n\t      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }\n\t    },\n\t    'MMM': {\n\t      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n\t      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }\n\t    },\n\t    'MM': {\n\t      regex: '0[1-9]|1[0-2]',\n\t      apply: function(value) { this.month = value - 1; }\n\t    },\n\t    'M': {\n\t      regex: '[1-9]|1[0-2]',\n\t      apply: function(value) { this.month = value - 1; }\n\t    },\n\t    'dd': {\n\t      regex: '[0-2][0-9]{1}|3[0-1]{1}',\n\t      apply: function(value) { this.date = +value; }\n\t    },\n\t    'd': {\n\t      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n\t      apply: function(value) { this.date = +value; }\n\t    },\n\t    'EEEE': {\n\t      regex: $locale.DATETIME_FORMATS.DAY.join('|')\n\t    },\n\t    'EEE': {\n\t      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')\n\t    }\n\t  };\n\t\n\t  function createParser(format) {\n\t    var map = [], regex = format.split('');\n\t\n\t    angular.forEach(formatCodeToRegex, function(data, code) {\n\t      var index = format.indexOf(code);\n\t\n\t      if (index > -1) {\n\t        format = format.split('');\n\t\n\t        regex[index] = '(' + data.regex + ')';\n\t        format[index] = '$'; // Custom symbol to define consumed part of format\n\t        for (var i = index + 1, n = index + code.length; i < n; i++) {\n\t          regex[i] = '';\n\t          format[i] = '$';\n\t        }\n\t        format = format.join('');\n\t\n\t        map.push({ index: index, apply: data.apply });\n\t      }\n\t    });\n\t\n\t    return {\n\t      regex: new RegExp('^' + regex.join('') + '$'),\n\t      map: orderByFilter(map, 'index')\n\t    };\n\t  }\n\t\n\t  this.parse = function(input, format) {\n\t    if ( !angular.isString(input) || !format ) {\n\t      return input;\n\t    }\n\t\n\t    format = $locale.DATETIME_FORMATS[format] || format;\n\t\n\t    if ( !this.parsers[format] ) {\n\t      this.parsers[format] = createParser(format);\n\t    }\n\t\n\t    var parser = this.parsers[format],\n\t        regex = parser.regex,\n\t        map = parser.map,\n\t        results = input.match(regex);\n\t\n\t    if ( results && results.length ) {\n\t      var fields = { year: 1900, month: 0, date: 1, hours: 0 }, dt;\n\t\n\t      for( var i = 1, n = results.length; i < n; i++ ) {\n\t        var mapper = map[i-1];\n\t        if ( mapper.apply ) {\n\t          mapper.apply.call(fields, results[i]);\n\t        }\n\t      }\n\t\n\t      if ( isValid(fields.year, fields.month, fields.date) ) {\n\t        dt = new Date( fields.year, fields.month, fields.date, fields.hours);\n\t      }\n\t\n\t      return dt;\n\t    }\n\t  };\n\t\n\t  // Check if date is valid for specific month (and year for February).\n\t  // Month: 0 = Jan, 1 = Feb, etc\n\t  function isValid(year, month, date) {\n\t    if ( month === 1 && date > 28) {\n\t        return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n\t    }\n\t\n\t    if ( month === 3 || month === 5 || month === 8 || month === 10) {\n\t        return date < 31;\n\t    }\n\t\n\t    return true;\n\t  }\n\t}]);\n\t\n\tangular.module('ui.bootstrap.position', [])\n\t\n\t/**\n\t * A set of utility methods that can be use to retrieve position of DOM elements.\n\t * It is meant to be used where we need to absolute-position DOM elements in\n\t * relation to other, existing elements (this is the case for tooltips, popovers,\n\t * typeahead suggestions etc.).\n\t */\n\t  .factory('$position', ['$document', '$window', function ($document, $window) {\n\t\n\t    function getStyle(el, cssprop) {\n\t      if (el.currentStyle) { //IE\n\t        return el.currentStyle[cssprop];\n\t      } else if ($window.getComputedStyle) {\n\t        return $window.getComputedStyle(el)[cssprop];\n\t      }\n\t      // finally try and get inline style\n\t      return el.style[cssprop];\n\t    }\n\t\n\t    /**\n\t     * Checks if a given element is statically positioned\n\t     * @param element - raw DOM element\n\t     */\n\t    function isStaticPositioned(element) {\n\t      return (getStyle(element, 'position') || 'static' ) === 'static';\n\t    }\n\t\n\t    /**\n\t     * returns the closest, non-statically positioned parentOffset of a given element\n\t     * @param element\n\t     */\n\t    var parentOffsetEl = function (element) {\n\t      var docDomEl = $document[0];\n\t      var offsetParent = element.offsetParent || docDomEl;\n\t      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n\t        offsetParent = offsetParent.offsetParent;\n\t      }\n\t      return offsetParent || docDomEl;\n\t    };\n\t\n\t    return {\n\t      /**\n\t       * Provides read-only equivalent of jQuery's position function:\n\t       * http://api.jquery.com/position/\n\t       */\n\t      position: function (element) {\n\t        var elBCR = this.offset(element);\n\t        var offsetParentBCR = { top: 0, left: 0 };\n\t        var offsetParentEl = parentOffsetEl(element[0]);\n\t        if (offsetParentEl != $document[0]) {\n\t          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n\t          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n\t          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n\t        }\n\t\n\t        var boundingClientRect = element[0].getBoundingClientRect();\n\t        return {\n\t          width: boundingClientRect.width || element.prop('offsetWidth'),\n\t          height: boundingClientRect.height || element.prop('offsetHeight'),\n\t          top: elBCR.top - offsetParentBCR.top,\n\t          left: elBCR.left - offsetParentBCR.left\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides read-only equivalent of jQuery's offset function:\n\t       * http://api.jquery.com/offset/\n\t       */\n\t      offset: function (element) {\n\t        var boundingClientRect = element[0].getBoundingClientRect();\n\t        return {\n\t          width: boundingClientRect.width || element.prop('offsetWidth'),\n\t          height: boundingClientRect.height || element.prop('offsetHeight'),\n\t          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n\t          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides coordinates for the targetEl in relation to hostEl\n\t       */\n\t      positionElements: function (hostEl, targetEl, positionStr, appendToBody) {\n\t\n\t        var positionStrParts = positionStr.split('-');\n\t        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\t\n\t        var hostElPos,\n\t          targetElWidth,\n\t          targetElHeight,\n\t          targetElPos;\n\t\n\t        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\t\n\t        targetElWidth = targetEl.prop('offsetWidth');\n\t        targetElHeight = targetEl.prop('offsetHeight');\n\t\n\t        var shiftWidth = {\n\t          center: function () {\n\t            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n\t          },\n\t          left: function () {\n\t            return hostElPos.left;\n\t          },\n\t          right: function () {\n\t            return hostElPos.left + hostElPos.width;\n\t          }\n\t        };\n\t\n\t        var shiftHeight = {\n\t          center: function () {\n\t            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n\t          },\n\t          top: function () {\n\t            return hostElPos.top;\n\t          },\n\t          bottom: function () {\n\t            return hostElPos.top + hostElPos.height;\n\t          }\n\t        };\n\t\n\t        switch (pos0) {\n\t          case 'right':\n\t            targetElPos = {\n\t              top: shiftHeight[pos1](),\n\t              left: shiftWidth[pos0]()\n\t            };\n\t            break;\n\t          case 'left':\n\t            targetElPos = {\n\t              top: shiftHeight[pos1](),\n\t              left: hostElPos.left - targetElWidth\n\t            };\n\t            break;\n\t          case 'bottom':\n\t            targetElPos = {\n\t              top: shiftHeight[pos0](),\n\t              left: shiftWidth[pos1]()\n\t            };\n\t            break;\n\t          default:\n\t            targetElPos = {\n\t              top: hostElPos.top - targetElHeight,\n\t              left: shiftWidth[pos1]()\n\t            };\n\t            break;\n\t        }\n\t\n\t        return targetElPos;\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])\n\t\n\t.constant('datepickerConfig', {\n\t  formatDay: 'dd',\n\t  formatMonth: 'MMMM',\n\t  formatYear: 'yyyy',\n\t  formatDayHeader: 'EEE',\n\t  formatDayTitle: 'MMMM yyyy',\n\t  formatMonthTitle: 'yyyy',\n\t  datepickerMode: 'day',\n\t  minMode: 'day',\n\t  maxMode: 'year',\n\t  showWeeks: true,\n\t  startingDay: 0,\n\t  yearRange: 20,\n\t  minDate: null,\n\t  maxDate: null\n\t})\n\t\n\t.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$timeout', '$log', 'dateFilter', 'datepickerConfig', function($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\t\n\t  // Modes chain\n\t  this.modes = ['day', 'month', 'year'];\n\t\n\t  // Configuration attributes\n\t  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n\t                   'minMode', 'maxMode', 'showWeeks', 'startingDay', 'yearRange'], function( key, index ) {\n\t    self[key] = angular.isDefined($attrs[key]) ? (index < 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n\t  });\n\t\n\t  // Watchable date attributes\n\t  angular.forEach(['minDate', 'maxDate'], function( key ) {\n\t    if ( $attrs[key] ) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = value ? new Date(value) : null;\n\t        self.refreshView();\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n\t    }\n\t  });\n\t\n\t  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n\t  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t  this.activeDate = angular.isDefined($attrs.initDate) ? $scope.$parent.$eval($attrs.initDate) : new Date();\n\t\n\t  $scope.isActive = function(dateObject) {\n\t    if (self.compare(dateObject.date, self.activeDate) === 0) {\n\t      $scope.activeDateId = dateObject.uid;\n\t      return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  this.init = function( ngModelCtrl_ ) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t  };\n\t\n\t  this.render = function() {\n\t    if ( ngModelCtrl.$modelValue ) {\n\t      var date = new Date( ngModelCtrl.$modelValue ),\n\t          isValid = !isNaN(date);\n\t\n\t      if ( isValid ) {\n\t        this.activeDate = date;\n\t      } else {\n\t        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t      }\n\t      ngModelCtrl.$setValidity('date', isValid);\n\t    }\n\t    this.refreshView();\n\t  };\n\t\n\t  this.refreshView = function() {\n\t    if ( this.element ) {\n\t      this._refreshView();\n\t\n\t      var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;\n\t      ngModelCtrl.$setValidity('date-disabled', !date || (this.element && !this.isDisabled(date)));\n\t    }\n\t  };\n\t\n\t  this.createDateObject = function(date, format) {\n\t    var model = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;\n\t    return {\n\t      date: date,\n\t      label: dateFilter(date, format),\n\t      selected: model && this.compare(date, model) === 0,\n\t      disabled: this.isDisabled(date),\n\t      current: this.compare(date, new Date()) === 0\n\t    };\n\t  };\n\t\n\t  this.isDisabled = function( date ) {\n\t    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n\t  };\n\t\n\t  // Split array into smaller arrays\n\t  this.split = function(arr, size) {\n\t    var arrays = [];\n\t    while (arr.length > 0) {\n\t      arrays.push(arr.splice(0, size));\n\t    }\n\t    return arrays;\n\t  };\n\t\n\t  $scope.select = function( date ) {\n\t    if ( $scope.datepickerMode === self.minMode ) {\n\t      var dt = ngModelCtrl.$modelValue ? new Date( ngModelCtrl.$modelValue ) : new Date(0, 0, 0, 0, 0, 0, 0);\n\t      dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );\n\t      ngModelCtrl.$setViewValue( dt );\n\t      ngModelCtrl.$render();\n\t    } else {\n\t      self.activeDate = date;\n\t      $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) - 1 ];\n\t    }\n\t  };\n\t\n\t  $scope.move = function( direction ) {\n\t    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n\t        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n\t    self.activeDate.setFullYear(year, month, 1);\n\t    self.refreshView();\n\t  };\n\t\n\t  $scope.toggleMode = function( direction ) {\n\t    direction = direction || 1;\n\t\n\t    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n\t      return;\n\t    }\n\t\n\t    $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) + direction ];\n\t  };\n\t\n\t  // Key event mapper\n\t  $scope.keys = { 13:'enter', 32:'space', 33:'pageup', 34:'pagedown', 35:'end', 36:'home', 37:'left', 38:'up', 39:'right', 40:'down' };\n\t\n\t  var focusElement = function() {\n\t    $timeout(function() {\n\t      self.element[0].focus();\n\t    }, 0 , false);\n\t  };\n\t\n\t  // Listen for focus requests from popup directive\n\t  $scope.$on('datepicker.focus', focusElement);\n\t\n\t  $scope.keydown = function( evt ) {\n\t    var key = $scope.keys[evt.which];\n\t\n\t    if ( !key || evt.shiftKey || evt.altKey ) {\n\t      return;\n\t    }\n\t\n\t    evt.preventDefault();\n\t    evt.stopPropagation();\n\t\n\t    if (key === 'enter' || key === 'space') {\n\t      if ( self.isDisabled(self.activeDate)) {\n\t        return; // do nothing\n\t      }\n\t      $scope.select(self.activeDate);\n\t      focusElement();\n\t    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n\t      $scope.toggleMode(key === 'up' ? 1 : -1);\n\t      focusElement();\n\t    } else {\n\t      self.handleKeyDown(key, evt);\n\t      self.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive( 'datepicker', function () {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/datepicker.html',\n\t    scope: {\n\t      datepickerMode: '=?',\n\t      dateDisabled: '&'\n\t    },\n\t    require: ['datepicker', '?^ngModel'],\n\t    controller: 'DatepickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if ( ngModelCtrl ) {\n\t        datepickerCtrl.init( ngModelCtrl );\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('daypicker', ['dateFilter', function (dateFilter) {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/day.html',\n\t    require: '^datepicker',\n\t    link: function(scope, element, attrs, ctrl) {\n\t      scope.showWeeks = ctrl.showWeeks;\n\t\n\t      ctrl.step = { months: 1 };\n\t      ctrl.element = element;\n\t\n\t      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\t      function getDaysInMonth( year, month ) {\n\t        return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];\n\t      }\n\t\n\t      function getDates(startDate, n) {\n\t        var dates = new Array(n), current = new Date(startDate), i = 0;\n\t        current.setHours(12); // Prevent repeated dates because of timezone bug\n\t        while ( i < n ) {\n\t          dates[i++] = new Date(current);\n\t          current.setDate( current.getDate() + 1 );\n\t        }\n\t        return dates;\n\t      }\n\t\n\t      ctrl._refreshView = function() {\n\t        var year = ctrl.activeDate.getFullYear(),\n\t          month = ctrl.activeDate.getMonth(),\n\t          firstDayOfMonth = new Date(year, month, 1),\n\t          difference = ctrl.startingDay - firstDayOfMonth.getDay(),\n\t          numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n\t          firstDate = new Date(firstDayOfMonth);\n\t\n\t        if ( numDisplayedFromPreviousMonth > 0 ) {\n\t          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );\n\t        }\n\t\n\t        // 42 is the number of days on a six-month calendar\n\t        var days = getDates(firstDate, 42);\n\t        for (var i = 0; i < 42; i ++) {\n\t          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {\n\t            secondary: days[i].getMonth() !== month,\n\t            uid: scope.uniqueId + '-' + i\n\t          });\n\t        }\n\t\n\t        scope.labels = new Array(7);\n\t        for (var j = 0; j < 7; j++) {\n\t          scope.labels[j] = {\n\t            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),\n\t            full: dateFilter(days[j].date, 'EEEE')\n\t          };\n\t        }\n\t\n\t        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);\n\t        scope.rows = ctrl.split(days, 7);\n\t\n\t        if ( scope.showWeeks ) {\n\t          scope.weekNumbers = [];\n\t          var weekNumber = getISO8601WeekNumber( scope.rows[0][0].date ),\n\t              numWeeks = scope.rows.length;\n\t          while( scope.weekNumbers.push(weekNumber++) < numWeeks ) {}\n\t        }\n\t      };\n\t\n\t      ctrl.compare = function(date1, date2) {\n\t        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );\n\t      };\n\t\n\t      function getISO8601WeekNumber(date) {\n\t        var checkDate = new Date(date);\n\t        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n\t        var time = checkDate.getTime();\n\t        checkDate.setMonth(0); // Compare with Jan 1\n\t        checkDate.setDate(1);\n\t        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n\t      }\n\t\n\t      ctrl.handleKeyDown = function( key, evt ) {\n\t        var date = ctrl.activeDate.getDate();\n\t\n\t        if (key === 'left') {\n\t          date = date - 1;   // up\n\t        } else if (key === 'up') {\n\t          date = date - 7;   // down\n\t        } else if (key === 'right') {\n\t          date = date + 1;   // down\n\t        } else if (key === 'down') {\n\t          date = date + 7;\n\t        } else if (key === 'pageup' || key === 'pagedown') {\n\t          var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n\t          ctrl.activeDate.setMonth(month, 1);\n\t          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);\n\t        } else if (key === 'home') {\n\t          date = 1;\n\t        } else if (key === 'end') {\n\t          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());\n\t        }\n\t        ctrl.activeDate.setDate(date);\n\t      };\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('monthpicker', ['dateFilter', function (dateFilter) {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/month.html',\n\t    require: '^datepicker',\n\t    link: function(scope, element, attrs, ctrl) {\n\t      ctrl.step = { years: 1 };\n\t      ctrl.element = element;\n\t\n\t      ctrl._refreshView = function() {\n\t        var months = new Array(12),\n\t            year = ctrl.activeDate.getFullYear();\n\t\n\t        for ( var i = 0; i < 12; i++ ) {\n\t          months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {\n\t            uid: scope.uniqueId + '-' + i\n\t          });\n\t        }\n\t\n\t        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);\n\t        scope.rows = ctrl.split(months, 3);\n\t      };\n\t\n\t      ctrl.compare = function(date1, date2) {\n\t        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );\n\t      };\n\t\n\t      ctrl.handleKeyDown = function( key, evt ) {\n\t        var date = ctrl.activeDate.getMonth();\n\t\n\t        if (key === 'left') {\n\t          date = date - 1;   // up\n\t        } else if (key === 'up') {\n\t          date = date - 3;   // down\n\t        } else if (key === 'right') {\n\t          date = date + 1;   // down\n\t        } else if (key === 'down') {\n\t          date = date + 3;\n\t        } else if (key === 'pageup' || key === 'pagedown') {\n\t          var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n\t          ctrl.activeDate.setFullYear(year);\n\t        } else if (key === 'home') {\n\t          date = 0;\n\t        } else if (key === 'end') {\n\t          date = 11;\n\t        }\n\t        ctrl.activeDate.setMonth(date);\n\t      };\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('yearpicker', ['dateFilter', function (dateFilter) {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/year.html',\n\t    require: '^datepicker',\n\t    link: function(scope, element, attrs, ctrl) {\n\t      var range = ctrl.yearRange;\n\t\n\t      ctrl.step = { years: range };\n\t      ctrl.element = element;\n\t\n\t      function getStartingYear( year ) {\n\t        return parseInt((year - 1) / range, 10) * range + 1;\n\t      }\n\t\n\t      ctrl._refreshView = function() {\n\t        var years = new Array(range);\n\t\n\t        for ( var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++ ) {\n\t          years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {\n\t            uid: scope.uniqueId + '-' + i\n\t          });\n\t        }\n\t\n\t        scope.title = [years[0].label, years[range - 1].label].join(' - ');\n\t        scope.rows = ctrl.split(years, 5);\n\t      };\n\t\n\t      ctrl.compare = function(date1, date2) {\n\t        return date1.getFullYear() - date2.getFullYear();\n\t      };\n\t\n\t      ctrl.handleKeyDown = function( key, evt ) {\n\t        var date = ctrl.activeDate.getFullYear();\n\t\n\t        if (key === 'left') {\n\t          date = date - 1;   // up\n\t        } else if (key === 'up') {\n\t          date = date - 5;   // down\n\t        } else if (key === 'right') {\n\t          date = date + 1;   // down\n\t        } else if (key === 'down') {\n\t          date = date + 5;\n\t        } else if (key === 'pageup' || key === 'pagedown') {\n\t          date += (key === 'pageup' ? - 1 : 1) * ctrl.step.years;\n\t        } else if (key === 'home') {\n\t          date = getStartingYear( ctrl.activeDate.getFullYear() );\n\t        } else if (key === 'end') {\n\t          date = getStartingYear( ctrl.activeDate.getFullYear() ) + range - 1;\n\t        }\n\t        ctrl.activeDate.setFullYear(date);\n\t      };\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.constant('datepickerPopupConfig', {\n\t  datepickerPopup: 'yyyy-MM-dd',\n\t  currentText: 'Today',\n\t  clearText: 'Clear',\n\t  closeText: 'Done',\n\t  closeOnDateSelection: true,\n\t  appendToBody: false,\n\t  showButtonBar: true\n\t})\n\t\n\t.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig',\n\tfunction ($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    require: 'ngModel',\n\t    scope: {\n\t      isOpen: '=?',\n\t      currentText: '@',\n\t      clearText: '@',\n\t      closeText: '@',\n\t      dateDisabled: '&'\n\t    },\n\t    link: function(scope, element, attrs, ngModel) {\n\t      var dateFormat,\n\t          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,\n\t          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n\t\n\t      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\t\n\t      scope.getText = function( key ) {\n\t        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n\t      };\n\t\n\t      attrs.$observe('datepickerPopup', function(value) {\n\t          dateFormat = value || datepickerPopupConfig.datepickerPopup;\n\t          ngModel.$render();\n\t      });\n\t\n\t      // popup element used to display calendar\n\t      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');\n\t      popupEl.attr({\n\t        'ng-model': 'date',\n\t        'ng-change': 'dateSelection()'\n\t      });\n\t\n\t      function cameltoDash( string ){\n\t        return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n\t      }\n\t\n\t      // datepicker element\n\t      var datepickerEl = angular.element(popupEl.children()[0]);\n\t      if ( attrs.datepickerOptions ) {\n\t        angular.forEach(scope.$parent.$eval(attrs.datepickerOptions), function( value, option ) {\n\t          datepickerEl.attr( cameltoDash(option), value );\n\t        });\n\t      }\n\t\n\t      scope.watchData = {};\n\t      angular.forEach(['minDate', 'maxDate', 'datepickerMode'], function( key ) {\n\t        if ( attrs[key] ) {\n\t          var getAttribute = $parse(attrs[key]);\n\t          scope.$parent.$watch(getAttribute, function(value){\n\t            scope.watchData[key] = value;\n\t          });\n\t          datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\t\n\t          // Propagate changes from datepicker to outside\n\t          if ( key === 'datepickerMode' ) {\n\t            var setAttribute = getAttribute.assign;\n\t            scope.$watch('watchData.' + key, function(value, oldvalue) {\n\t              if ( value !== oldvalue ) {\n\t                setAttribute(scope.$parent, value);\n\t              }\n\t            });\n\t          }\n\t        }\n\t      });\n\t      if (attrs.dateDisabled) {\n\t        datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n\t      }\n\t\n\t      function parseDate(viewValue) {\n\t        if (!viewValue) {\n\t          ngModel.$setValidity('date', true);\n\t          return null;\n\t        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n\t          ngModel.$setValidity('date', true);\n\t          return viewValue;\n\t        } else if (angular.isString(viewValue)) {\n\t          var date = dateParser.parse(viewValue, dateFormat) || new Date(viewValue);\n\t          if (isNaN(date)) {\n\t            ngModel.$setValidity('date', false);\n\t            return undefined;\n\t          } else {\n\t            ngModel.$setValidity('date', true);\n\t            return date;\n\t          }\n\t        } else {\n\t          ngModel.$setValidity('date', false);\n\t          return undefined;\n\t        }\n\t      }\n\t      ngModel.$parsers.unshift(parseDate);\n\t\n\t      // Inner change\n\t      scope.dateSelection = function(dt) {\n\t        if (angular.isDefined(dt)) {\n\t          scope.date = dt;\n\t        }\n\t        ngModel.$setViewValue(scope.date);\n\t        ngModel.$render();\n\t\n\t        if ( closeOnDateSelection ) {\n\t          scope.isOpen = false;\n\t          element[0].focus();\n\t        }\n\t      };\n\t\n\t      element.bind('input change keyup', function() {\n\t        scope.$apply(function() {\n\t          scope.date = ngModel.$modelValue;\n\t        });\n\t      });\n\t\n\t      // Outter change\n\t      ngModel.$render = function() {\n\t        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';\n\t        element.val(date);\n\t        scope.date = parseDate( ngModel.$modelValue );\n\t      };\n\t\n\t      var documentClickBind = function(event) {\n\t        if (scope.isOpen && event.target !== element[0]) {\n\t          scope.$apply(function() {\n\t            scope.isOpen = false;\n\t          });\n\t        }\n\t      };\n\t\n\t      var keydown = function(evt, noApply) {\n\t        scope.keydown(evt);\n\t      };\n\t      element.bind('keydown', keydown);\n\t\n\t      scope.keydown = function(evt) {\n\t        if (evt.which === 27) {\n\t          evt.preventDefault();\n\t          evt.stopPropagation();\n\t          scope.close();\n\t        } else if (evt.which === 40 && !scope.isOpen) {\n\t          scope.isOpen = true;\n\t        }\n\t      };\n\t\n\t      scope.$watch('isOpen', function(value) {\n\t        if (value) {\n\t          scope.$broadcast('datepicker.focus');\n\t          scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t          scope.position.top = scope.position.top + element.prop('offsetHeight');\n\t\n\t          $document.bind('click', documentClickBind);\n\t        } else {\n\t          $document.unbind('click', documentClickBind);\n\t        }\n\t      });\n\t\n\t      scope.select = function( date ) {\n\t        if (date === 'today') {\n\t          var today = new Date();\n\t          if (angular.isDate(ngModel.$modelValue)) {\n\t            date = new Date(ngModel.$modelValue);\n\t            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n\t          } else {\n\t            date = new Date(today.setHours(0, 0, 0, 0));\n\t          }\n\t        }\n\t        scope.dateSelection( date );\n\t      };\n\t\n\t      scope.close = function() {\n\t        scope.isOpen = false;\n\t        element[0].focus();\n\t      };\n\t\n\t      var $popup = $compile(popupEl)(scope);\n\t      // Prevent jQuery cache memory leak (template is now redundant after linking)\n\t      popupEl.remove();\n\t\n\t      if ( appendToBody ) {\n\t        $document.find('body').append($popup);\n\t      } else {\n\t        element.after($popup);\n\t      }\n\t\n\t      scope.$on('$destroy', function() {\n\t        $popup.remove();\n\t        element.unbind('keydown', keydown);\n\t        $document.unbind('click', documentClickBind);\n\t      });\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('datepickerPopupWrap', function() {\n\t  return {\n\t    restrict:'EA',\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: 'template/datepicker/popup.html',\n\t    link:function (scope, element, attrs) {\n\t      element.bind('click', function(event) {\n\t        event.preventDefault();\n\t        event.stopPropagation();\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.dropdown', [])\n\t\n\t.constant('dropdownConfig', {\n\t  openClass: 'open'\n\t})\n\t\n\t.service('dropdownService', ['$document', function($document) {\n\t  var openScope = null;\n\t\n\t  this.open = function( dropdownScope ) {\n\t    if ( !openScope ) {\n\t      $document.bind('click', closeDropdown);\n\t      $document.bind('keydown', escapeKeyBind);\n\t    }\n\t\n\t    if ( openScope && openScope !== dropdownScope ) {\n\t        openScope.isOpen = false;\n\t    }\n\t\n\t    openScope = dropdownScope;\n\t  };\n\t\n\t  this.close = function( dropdownScope ) {\n\t    if ( openScope === dropdownScope ) {\n\t      openScope = null;\n\t      $document.unbind('click', closeDropdown);\n\t      $document.unbind('keydown', escapeKeyBind);\n\t    }\n\t  };\n\t\n\t  var closeDropdown = function( evt ) {\n\t    var toggleElement = openScope.getToggleElement();\n\t    if ( evt && toggleElement && toggleElement[0].contains(evt.target) ) {\n\t        return;\n\t    }\n\t\n\t    openScope.$apply(function() {\n\t      openScope.isOpen = false;\n\t    });\n\t  };\n\t\n\t  var escapeKeyBind = function( evt ) {\n\t    if ( evt.which === 27 ) {\n\t      openScope.focusToggleElement();\n\t      closeDropdown();\n\t    }\n\t  };\n\t}])\n\t\n\t.controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {\n\t  var self = this,\n\t      scope = $scope.$new(), // create a child scope so we are not polluting original one\n\t      openClass = dropdownConfig.openClass,\n\t      getIsOpen,\n\t      setIsOpen = angular.noop,\n\t      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop;\n\t\n\t  this.init = function( element ) {\n\t    self.$element = element;\n\t\n\t    if ( $attrs.isOpen ) {\n\t      getIsOpen = $parse($attrs.isOpen);\n\t      setIsOpen = getIsOpen.assign;\n\t\n\t      $scope.$watch(getIsOpen, function(value) {\n\t        scope.isOpen = !!value;\n\t      });\n\t    }\n\t  };\n\t\n\t  this.toggle = function( open ) {\n\t    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n\t  };\n\t\n\t  // Allow other directives to watch status\n\t  this.isOpen = function() {\n\t    return scope.isOpen;\n\t  };\n\t\n\t  scope.getToggleElement = function() {\n\t    return self.toggleElement;\n\t  };\n\t\n\t  scope.focusToggleElement = function() {\n\t    if ( self.toggleElement ) {\n\t      self.toggleElement[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.$watch('isOpen', function( isOpen, wasOpen ) {\n\t    $animate[isOpen ? 'addClass' : 'removeClass'](self.$element, openClass);\n\t\n\t    if ( isOpen ) {\n\t      scope.focusToggleElement();\n\t      dropdownService.open( scope );\n\t    } else {\n\t      dropdownService.close( scope );\n\t    }\n\t\n\t    setIsOpen($scope, isOpen);\n\t    if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n\t      toggleInvoker($scope, { open: !!isOpen });\n\t    }\n\t  });\n\t\n\t  $scope.$on('$locationChangeSuccess', function() {\n\t    scope.isOpen = false;\n\t  });\n\t\n\t  $scope.$on('$destroy', function() {\n\t    scope.$destroy();\n\t  });\n\t}])\n\t\n\t.directive('dropdown', function() {\n\t  return {\n\t    restrict: 'CA',\n\t    controller: 'DropdownController',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      dropdownCtrl.init( element );\n\t    }\n\t  };\n\t})\n\t\n\t.directive('dropdownToggle', function() {\n\t  return {\n\t    restrict: 'CA',\n\t    require: '?^dropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if ( !dropdownCtrl ) {\n\t        return;\n\t      }\n\t\n\t      dropdownCtrl.toggleElement = element;\n\t\n\t      var toggleDropdown = function(event) {\n\t        event.preventDefault();\n\t\n\t        if ( !element.hasClass('disabled') && !attrs.disabled ) {\n\t          scope.$apply(function() {\n\t            dropdownCtrl.toggle();\n\t          });\n\t        }\n\t      };\n\t\n\t      element.bind('click', toggleDropdown);\n\t\n\t      // WAI-ARIA\n\t      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n\t      scope.$watch(dropdownCtrl.isOpen, function( isOpen ) {\n\t        element.attr('aria-expanded', !!isOpen);\n\t      });\n\t\n\t      scope.$on('$destroy', function() {\n\t        element.unbind('click', toggleDropdown);\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.modal', ['ui.bootstrap.transition'])\n\t\n\t/**\n\t * A helper, internal data structure that acts as a map but also allows getting / removing\n\t * elements in the LIFO order\n\t */\n\t  .factory('$$stackedMap', function () {\n\t    return {\n\t      createNew: function () {\n\t        var stack = [];\n\t\n\t        return {\n\t          add: function (key, value) {\n\t            stack.push({\n\t              key: key,\n\t              value: value\n\t            });\n\t          },\n\t          get: function (key) {\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key == stack[i].key) {\n\t                return stack[i];\n\t              }\n\t            }\n\t          },\n\t          keys: function() {\n\t            var keys = [];\n\t            for (var i = 0; i < stack.length; i++) {\n\t              keys.push(stack[i].key);\n\t            }\n\t            return keys;\n\t          },\n\t          top: function () {\n\t            return stack[stack.length - 1];\n\t          },\n\t          remove: function (key) {\n\t            var idx = -1;\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key == stack[i].key) {\n\t                idx = i;\n\t                break;\n\t              }\n\t            }\n\t            return stack.splice(idx, 1)[0];\n\t          },\n\t          removeTop: function () {\n\t            return stack.splice(stack.length - 1, 1)[0];\n\t          },\n\t          length: function () {\n\t            return stack.length;\n\t          }\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t/**\n\t * A helper directive for the $modal service. It creates a backdrop element.\n\t */\n\t  .directive('modalBackdrop', ['$timeout', function ($timeout) {\n\t    return {\n\t      restrict: 'EA',\n\t      replace: true,\n\t      templateUrl: 'template/modal/backdrop.html',\n\t      link: function (scope, element, attrs) {\n\t        scope.backdropClass = attrs.backdropClass || '';\n\t\n\t        scope.animate = false;\n\t\n\t        //trigger CSS transitions\n\t        $timeout(function () {\n\t          scope.animate = true;\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('modalWindow', ['$modalStack', '$timeout', function ($modalStack, $timeout) {\n\t    return {\n\t      restrict: 'EA',\n\t      scope: {\n\t        index: '@',\n\t        animate: '='\n\t      },\n\t      replace: true,\n\t      transclude: true,\n\t      templateUrl: function(tElement, tAttrs) {\n\t        return tAttrs.templateUrl || 'template/modal/window.html';\n\t      },\n\t      link: function (scope, element, attrs) {\n\t        element.addClass(attrs.windowClass || '');\n\t        scope.size = attrs.size;\n\t\n\t        $timeout(function () {\n\t          // trigger CSS transitions\n\t          scope.animate = true;\n\t\n\t          /**\n\t           * Auto-focusing of a freshly-opened modal element causes any child elements\n\t           * with the autofocus attribute to loose focus. This is an issue on touch\n\t           * based devices which will show and then hide the onscreen keyboard.\n\t           * Attempts to refocus the autofocus element via JavaScript will not reopen\n\t           * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n\t           * the modal element if the modal does not contain an autofocus element.\n\t           */\n\t          if (!element[0].querySelectorAll('[autofocus]').length) {\n\t            element[0].focus();\n\t          }\n\t        });\n\t\n\t        scope.close = function (evt) {\n\t          var modal = $modalStack.getTop();\n\t          if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && (evt.target === evt.currentTarget)) {\n\t            evt.preventDefault();\n\t            evt.stopPropagation();\n\t            $modalStack.dismiss(modal.key, 'backdrop click');\n\t          }\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('modalTransclude', function () {\n\t    return {\n\t      link: function($scope, $element, $attrs, controller, $transclude) {\n\t        $transclude($scope.$parent, function(clone) {\n\t          $element.empty();\n\t          $element.append(clone);\n\t        });\n\t      }\n\t    };\n\t  })\n\t\n\t  .factory('$modalStack', ['$transition', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap',\n\t    function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {\n\t\n\t      var OPENED_MODAL_CLASS = 'modal-open';\n\t\n\t      var backdropDomEl, backdropScope;\n\t      var openedWindows = $$stackedMap.createNew();\n\t      var $modalStack = {};\n\t\n\t      function backdropIndex() {\n\t        var topBackdropIndex = -1;\n\t        var opened = openedWindows.keys();\n\t        for (var i = 0; i < opened.length; i++) {\n\t          if (openedWindows.get(opened[i]).value.backdrop) {\n\t            topBackdropIndex = i;\n\t          }\n\t        }\n\t        return topBackdropIndex;\n\t      }\n\t\n\t      $rootScope.$watch(backdropIndex, function(newBackdropIndex){\n\t        if (backdropScope) {\n\t          backdropScope.index = newBackdropIndex;\n\t        }\n\t      });\n\t\n\t      function removeModalWindow(modalInstance) {\n\t\n\t        var body = $document.find('body').eq(0);\n\t        var modalWindow = openedWindows.get(modalInstance).value;\n\t\n\t        //clean up the stack\n\t        openedWindows.remove(modalInstance);\n\t\n\t        //remove window DOM element\n\t        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {\n\t          modalWindow.modalScope.$destroy();\n\t          body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);\n\t          checkRemoveBackdrop();\n\t        });\n\t      }\n\t\n\t      function checkRemoveBackdrop() {\n\t          //remove backdrop if no longer needed\n\t          if (backdropDomEl && backdropIndex() == -1) {\n\t            var backdropScopeRef = backdropScope;\n\t            removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {\n\t              backdropScopeRef.$destroy();\n\t              backdropScopeRef = null;\n\t            });\n\t            backdropDomEl = undefined;\n\t            backdropScope = undefined;\n\t          }\n\t      }\n\t\n\t      function removeAfterAnimate(domEl, scope, emulateTime, done) {\n\t        // Closing animation\n\t        scope.animate = false;\n\t\n\t        var transitionEndEventName = $transition.transitionEndEventName;\n\t        if (transitionEndEventName) {\n\t          // transition out\n\t          var timeout = $timeout(afterAnimating, emulateTime);\n\t\n\t          domEl.bind(transitionEndEventName, function () {\n\t            $timeout.cancel(timeout);\n\t            afterAnimating();\n\t            scope.$apply();\n\t          });\n\t        } else {\n\t          // Ensure this call is async\n\t          $timeout(afterAnimating);\n\t        }\n\t\n\t        function afterAnimating() {\n\t          if (afterAnimating.done) {\n\t            return;\n\t          }\n\t          afterAnimating.done = true;\n\t\n\t          domEl.remove();\n\t          if (done) {\n\t            done();\n\t          }\n\t        }\n\t      }\n\t\n\t      $document.bind('keydown', function (evt) {\n\t        var modal;\n\t\n\t        if (evt.which === 27) {\n\t          modal = openedWindows.top();\n\t          if (modal && modal.value.keyboard) {\n\t            evt.preventDefault();\n\t            $rootScope.$apply(function () {\n\t              $modalStack.dismiss(modal.key, 'escape key press');\n\t            });\n\t          }\n\t        }\n\t      });\n\t\n\t      $modalStack.open = function (modalInstance, modal) {\n\t\n\t        openedWindows.add(modalInstance, {\n\t          deferred: modal.deferred,\n\t          modalScope: modal.scope,\n\t          backdrop: modal.backdrop,\n\t          keyboard: modal.keyboard\n\t        });\n\t\n\t        var body = $document.find('body').eq(0),\n\t            currBackdropIndex = backdropIndex();\n\t\n\t        if (currBackdropIndex >= 0 && !backdropDomEl) {\n\t          backdropScope = $rootScope.$new(true);\n\t          backdropScope.index = currBackdropIndex;\n\t          var angularBackgroundDomEl = angular.element('<div modal-backdrop></div>');\n\t          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);\n\t          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n\t          body.append(backdropDomEl);\n\t        }\n\t\n\t        var angularDomEl = angular.element('<div modal-window></div>');\n\t        angularDomEl.attr({\n\t          'template-url': modal.windowTemplateUrl,\n\t          'window-class': modal.windowClass,\n\t          'size': modal.size,\n\t          'index': openedWindows.length() - 1,\n\t          'animate': 'animate'\n\t        }).html(modal.content);\n\t\n\t        var modalDomEl = $compile(angularDomEl)(modal.scope);\n\t        openedWindows.top().value.modalDomEl = modalDomEl;\n\t        body.append(modalDomEl);\n\t        body.addClass(OPENED_MODAL_CLASS);\n\t      };\n\t\n\t      $modalStack.close = function (modalInstance, result) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow) {\n\t          modalWindow.value.deferred.resolve(result);\n\t          removeModalWindow(modalInstance);\n\t        }\n\t      };\n\t\n\t      $modalStack.dismiss = function (modalInstance, reason) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow) {\n\t          modalWindow.value.deferred.reject(reason);\n\t          removeModalWindow(modalInstance);\n\t        }\n\t      };\n\t\n\t      $modalStack.dismissAll = function (reason) {\n\t        var topModal = this.getTop();\n\t        while (topModal) {\n\t          this.dismiss(topModal.key, reason);\n\t          topModal = this.getTop();\n\t        }\n\t      };\n\t\n\t      $modalStack.getTop = function () {\n\t        return openedWindows.top();\n\t      };\n\t\n\t      return $modalStack;\n\t    }])\n\t\n\t  .provider('$modal', function () {\n\t\n\t    var $modalProvider = {\n\t      options: {\n\t        backdrop: true, //can be also false or 'static'\n\t        keyboard: true\n\t      },\n\t      $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack',\n\t        function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {\n\t\n\t          var $modal = {};\n\t\n\t          function getTemplatePromise(options) {\n\t            return options.template ? $q.when(options.template) :\n\t              $http.get(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl,\n\t                {cache: $templateCache}).then(function (result) {\n\t                  return result.data;\n\t              });\n\t          }\n\t\n\t          function getResolvePromises(resolves) {\n\t            var promisesArr = [];\n\t            angular.forEach(resolves, function (value) {\n\t              if (angular.isFunction(value) || angular.isArray(value)) {\n\t                promisesArr.push($q.when($injector.invoke(value)));\n\t              }\n\t            });\n\t            return promisesArr;\n\t          }\n\t\n\t          $modal.open = function (modalOptions) {\n\t\n\t            var modalResultDeferred = $q.defer();\n\t            var modalOpenedDeferred = $q.defer();\n\t\n\t            //prepare an instance of a modal to be injected into controllers and returned to a caller\n\t            var modalInstance = {\n\t              result: modalResultDeferred.promise,\n\t              opened: modalOpenedDeferred.promise,\n\t              close: function (result) {\n\t                $modalStack.close(modalInstance, result);\n\t              },\n\t              dismiss: function (reason) {\n\t                $modalStack.dismiss(modalInstance, reason);\n\t              }\n\t            };\n\t\n\t            //merge and clean up options\n\t            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n\t            modalOptions.resolve = modalOptions.resolve || {};\n\t\n\t            //verify options\n\t            if (!modalOptions.template && !modalOptions.templateUrl) {\n\t              throw new Error('One of template or templateUrl options is required.');\n\t            }\n\t\n\t            var templateAndResolvePromise =\n\t              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\t\n\t\n\t            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {\n\t\n\t              var modalScope = (modalOptions.scope || $rootScope).$new();\n\t              modalScope.$close = modalInstance.close;\n\t              modalScope.$dismiss = modalInstance.dismiss;\n\t\n\t              var ctrlInstance, ctrlLocals = {};\n\t              var resolveIter = 1;\n\t\n\t              //controllers\n\t              if (modalOptions.controller) {\n\t                ctrlLocals.$scope = modalScope;\n\t                ctrlLocals.$modalInstance = modalInstance;\n\t                angular.forEach(modalOptions.resolve, function (value, key) {\n\t                  ctrlLocals[key] = tplAndVars[resolveIter++];\n\t                });\n\t\n\t                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n\t                if (modalOptions.controllerAs) {\n\t                  modalScope[modalOptions.controllerAs] = ctrlInstance;\n\t                }\n\t              }\n\t\n\t              $modalStack.open(modalInstance, {\n\t                scope: modalScope,\n\t                deferred: modalResultDeferred,\n\t                content: tplAndVars[0],\n\t                backdrop: modalOptions.backdrop,\n\t                keyboard: modalOptions.keyboard,\n\t                backdropClass: modalOptions.backdropClass,\n\t                windowClass: modalOptions.windowClass,\n\t                windowTemplateUrl: modalOptions.windowTemplateUrl,\n\t                size: modalOptions.size\n\t              });\n\t\n\t            }, function resolveError(reason) {\n\t              modalResultDeferred.reject(reason);\n\t            });\n\t\n\t            templateAndResolvePromise.then(function () {\n\t              modalOpenedDeferred.resolve(true);\n\t            }, function () {\n\t              modalOpenedDeferred.reject(false);\n\t            });\n\t\n\t            return modalInstance;\n\t          };\n\t\n\t          return $modal;\n\t        }]\n\t    };\n\t\n\t    return $modalProvider;\n\t  });\n\t\n\tangular.module('ui.bootstrap.pagination', [])\n\t\n\t.controller('PaginationController', ['$scope', '$attrs', '$parse', function ($scope, $attrs, $parse) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\t\n\t  this.init = function(ngModelCtrl_, config) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    this.config = config;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t\n\t    if ($attrs.itemsPerPage) {\n\t      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n\t        self.itemsPerPage = parseInt(value, 10);\n\t        $scope.totalPages = self.calculateTotalPages();\n\t      });\n\t    } else {\n\t      this.itemsPerPage = config.itemsPerPage;\n\t    }\n\t  };\n\t\n\t  this.calculateTotalPages = function() {\n\t    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n\t    return Math.max(totalPages || 0, 1);\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n\t  };\n\t\n\t  $scope.selectPage = function(page) {\n\t    if ( $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n\t      ngModelCtrl.$setViewValue(page);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.getText = function( key ) {\n\t    return $scope[key + 'Text'] || self.config[key + 'Text'];\n\t  };\n\t  $scope.noPrevious = function() {\n\t    return $scope.page === 1;\n\t  };\n\t  $scope.noNext = function() {\n\t    return $scope.page === $scope.totalPages;\n\t  };\n\t\n\t  $scope.$watch('totalItems', function() {\n\t    $scope.totalPages = self.calculateTotalPages();\n\t  });\n\t\n\t  $scope.$watch('totalPages', function(value) {\n\t    setNumPages($scope.$parent, value); // Readonly variable\n\t\n\t    if ( $scope.page > value ) {\n\t      $scope.selectPage(value);\n\t    } else {\n\t      ngModelCtrl.$render();\n\t    }\n\t  });\n\t}])\n\t\n\t.constant('paginationConfig', {\n\t  itemsPerPage: 10,\n\t  boundaryLinks: false,\n\t  directionLinks: true,\n\t  firstText: 'First',\n\t  previousText: 'Previous',\n\t  nextText: 'Next',\n\t  lastText: 'Last',\n\t  rotate: true\n\t})\n\t\n\t.directive('pagination', ['$parse', 'paginationConfig', function($parse, paginationConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      firstText: '@',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      lastText: '@'\n\t    },\n\t    require: ['pagination', '?ngModel'],\n\t    controller: 'PaginationController',\n\t    templateUrl: 'template/pagination/pagination.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      // Setup configuration parameters\n\t      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n\t          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n\t      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n\t      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\t\n\t      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\t\n\t      if (attrs.maxSize) {\n\t        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n\t          maxSize = parseInt(value, 10);\n\t          paginationCtrl.render();\n\t        });\n\t      }\n\t\n\t      // Create page object used in template\n\t      function makePage(number, text, isActive) {\n\t        return {\n\t          number: number,\n\t          text: text,\n\t          active: isActive\n\t        };\n\t      }\n\t\n\t      function getPages(currentPage, totalPages) {\n\t        var pages = [];\n\t\n\t        // Default page limits\n\t        var startPage = 1, endPage = totalPages;\n\t        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );\n\t\n\t        // recompute if maxSize\n\t        if ( isMaxSized ) {\n\t          if ( rotate ) {\n\t            // Current page is displayed in the middle of the visible ones\n\t            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n\t            endPage   = startPage + maxSize - 1;\n\t\n\t            // Adjust if limit is exceeded\n\t            if (endPage > totalPages) {\n\t              endPage   = totalPages;\n\t              startPage = endPage - maxSize + 1;\n\t            }\n\t          } else {\n\t            // Visible pages are paginated with maxSize\n\t            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\t\n\t            // Adjust last page if limit is exceeded\n\t            endPage = Math.min(startPage + maxSize - 1, totalPages);\n\t          }\n\t        }\n\t\n\t        // Add page number links\n\t        for (var number = startPage; number <= endPage; number++) {\n\t          var page = makePage(number, number, number === currentPage);\n\t          pages.push(page);\n\t        }\n\t\n\t        // Add links to move between page sets\n\t        if ( isMaxSized && ! rotate ) {\n\t          if ( startPage > 1 ) {\n\t            var previousPageSet = makePage(startPage - 1, '...', false);\n\t            pages.unshift(previousPageSet);\n\t          }\n\t\n\t          if ( endPage < totalPages ) {\n\t            var nextPageSet = makePage(endPage + 1, '...', false);\n\t            pages.push(nextPageSet);\n\t          }\n\t        }\n\t\n\t        return pages;\n\t      }\n\t\n\t      var originalRender = paginationCtrl.render;\n\t      paginationCtrl.render = function() {\n\t        originalRender();\n\t        if (scope.page > 0 && scope.page <= scope.totalPages) {\n\t          scope.pages = getPages(scope.page, scope.totalPages);\n\t        }\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t.constant('pagerConfig', {\n\t  itemsPerPage: 10,\n\t  previousText: ' Previous',\n\t  nextText: 'Next ',\n\t  align: true\n\t})\n\t\n\t.directive('pager', ['pagerConfig', function(pagerConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      previousText: '@',\n\t      nextText: '@'\n\t    },\n\t    require: ['pager', '?ngModel'],\n\t    controller: 'PaginationController',\n\t    templateUrl: 'template/pagination/pager.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n\t      paginationCtrl.init(ngModelCtrl, pagerConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, html tooltips, and selector delegation.\n\t */\n\tangular.module( 'ui.bootstrap.tooltip', [ 'ui.bootstrap.position', 'ui.bootstrap.bindHtml' ] )\n\t\n\t/**\n\t * The $tooltip service creates tooltip- and popover-like directives as well as\n\t * houses global options for them.\n\t */\n\t.provider( '$tooltip', function () {\n\t  // The default options tooltip and popover.\n\t  var defaultOptions = {\n\t    placement: 'top',\n\t    animation: true,\n\t    popupDelay: 0\n\t  };\n\t\n\t  // Default hide triggers for each show trigger\n\t  var triggerMap = {\n\t    'mouseenter': 'mouseleave',\n\t    'click': 'click',\n\t    'focus': 'blur'\n\t  };\n\t\n\t  // The options specified to the provider globally.\n\t  var globalOptions = {};\n\t\n\t  /**\n\t   * `options({})` allows global configuration of all tooltips in the\n\t   * application.\n\t   *\n\t   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n\t   *     // place tooltips left instead of top by default\n\t   *     $tooltipProvider.options( { placement: 'left' } );\n\t   *   });\n\t   */\n\t\tthis.options = function( value ) {\n\t\t\tangular.extend( globalOptions, value );\n\t\t};\n\t\n\t  /**\n\t   * This allows you to extend the set of trigger mappings available. E.g.:\n\t   *\n\t   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n\t   */\n\t  this.setTriggers = function setTriggers ( triggers ) {\n\t    angular.extend( triggerMap, triggers );\n\t  };\n\t\n\t  /**\n\t   * This is a helper function for translating camel-case to snake-case.\n\t   */\n\t  function snake_case(name){\n\t    var regexp = /[A-Z]/g;\n\t    var separator = '-';\n\t    return name.replace(regexp, function(letter, pos) {\n\t      return (pos ? separator : '') + letter.toLowerCase();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Returns the actual instance of the $tooltip service.\n\t   * TODO support multiple triggers\n\t   */\n\t  this.$get = [ '$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ( $window, $compile, $timeout, $parse, $document, $position, $interpolate ) {\n\t    return function $tooltip ( type, prefix, defaultTriggerShow ) {\n\t      var options = angular.extend( {}, defaultOptions, globalOptions );\n\t\n\t      /**\n\t       * Returns an object of show and hide triggers.\n\t       *\n\t       * If a trigger is supplied,\n\t       * it is used to show the tooltip; otherwise, it will use the `trigger`\n\t       * option passed to the `$tooltipProvider.options` method; else it will\n\t       * default to the trigger supplied to this directive factory.\n\t       *\n\t       * The hide trigger is based on the show trigger. If the `trigger` option\n\t       * was passed to the `$tooltipProvider.options` method, it will use the\n\t       * mapped trigger from `triggerMap` or the passed trigger if the map is\n\t       * undefined; otherwise, it uses the `triggerMap` value of the show\n\t       * trigger; else it will just use the show trigger.\n\t       */\n\t      function getTriggers ( trigger ) {\n\t        var show = trigger || options.trigger || defaultTriggerShow;\n\t        var hide = triggerMap[show] || show;\n\t        return {\n\t          show: show,\n\t          hide: hide\n\t        };\n\t      }\n\t\n\t      var directiveName = snake_case( type );\n\t\n\t      var startSym = $interpolate.startSymbol();\n\t      var endSym = $interpolate.endSymbol();\n\t      var template =\n\t        '<div '+ directiveName +'-popup '+\n\t          'title=\"'+startSym+'tt_title'+endSym+'\" '+\n\t          'content=\"'+startSym+'tt_content'+endSym+'\" '+\n\t          'placement=\"'+startSym+'tt_placement'+endSym+'\" '+\n\t          'animation=\"tt_animation\" '+\n\t          'is-open=\"tt_isOpen\"'+\n\t          '>'+\n\t        '</div>';\n\t\n\t      return {\n\t        restrict: 'EA',\n\t        scope: true,\n\t        compile: function (tElem, tAttrs) {\n\t          var tooltipLinker = $compile( template );\n\t\n\t          return function link ( scope, element, attrs ) {\n\t            var tooltip;\n\t            var transitionTimeout;\n\t            var popupTimeout;\n\t            var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;\n\t            var triggers = getTriggers( undefined );\n\t            var hasEnableExp = angular.isDefined(attrs[prefix+'Enable']);\n\t\n\t            var positionTooltip = function () {\n\t\n\t              var ttPosition = $position.positionElements(element, tooltip, scope.tt_placement, appendToBody);\n\t              ttPosition.top += 'px';\n\t              ttPosition.left += 'px';\n\t\n\t              // Now set the calculated positioning.\n\t              tooltip.css( ttPosition );\n\t            };\n\t\n\t            // By default, the tooltip is not open.\n\t            // TODO add ability to start tooltip opened\n\t            scope.tt_isOpen = false;\n\t\n\t            function toggleTooltipBind () {\n\t              if ( ! scope.tt_isOpen ) {\n\t                showTooltipBind();\n\t              } else {\n\t                hideTooltipBind();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip with delay if specified, otherwise show it immediately\n\t            function showTooltipBind() {\n\t              if(hasEnableExp && !scope.$eval(attrs[prefix+'Enable'])) {\n\t                return;\n\t              }\n\t              if ( scope.tt_popupDelay ) {\n\t                // Do nothing if the tooltip was already scheduled to pop-up.\n\t                // This happens if show is triggered multiple times before any hide is triggered.\n\t                if (!popupTimeout) {\n\t                  popupTimeout = $timeout( show, scope.tt_popupDelay, false );\n\t                  popupTimeout.then(function(reposition){reposition();});\n\t                }\n\t              } else {\n\t                show()();\n\t              }\n\t            }\n\t\n\t            function hideTooltipBind () {\n\t              scope.$apply(function () {\n\t                hide();\n\t              });\n\t            }\n\t\n\t            // Show the tooltip popup element.\n\t            function show() {\n\t\n\t              popupTimeout = null;\n\t\n\t              // If there is a pending remove transition, we must cancel it, lest the\n\t              // tooltip be mysteriously removed.\n\t              if ( transitionTimeout ) {\n\t                $timeout.cancel( transitionTimeout );\n\t                transitionTimeout = null;\n\t              }\n\t\n\t              // Don't show empty tooltips.\n\t              if ( ! scope.tt_content ) {\n\t                return angular.noop;\n\t              }\n\t\n\t              createTooltip();\n\t\n\t              // Set the initial positioning.\n\t              tooltip.css({ top: 0, left: 0, display: 'block' });\n\t\n\t              // Now we add it to the DOM because need some info about it. But it's not \n\t              // visible yet anyway.\n\t              if ( appendToBody ) {\n\t                  $document.find( 'body' ).append( tooltip );\n\t              } else {\n\t                element.after( tooltip );\n\t              }\n\t\n\t              positionTooltip();\n\t\n\t              // And show the tooltip.\n\t              scope.tt_isOpen = true;\n\t              scope.$digest(); // digest required as $apply is not called\n\t\n\t              // Return positioning function as promise callback for correct\n\t              // positioning after draw.\n\t              return positionTooltip;\n\t            }\n\t\n\t            // Hide the tooltip popup element.\n\t            function hide() {\n\t              // First things first: we don't show it anymore.\n\t              scope.tt_isOpen = false;\n\t\n\t              //if tooltip is going to be shown after delay, we must cancel this\n\t              $timeout.cancel( popupTimeout );\n\t              popupTimeout = null;\n\t\n\t              // And now we remove it from the DOM. However, if we have animation, we \n\t              // need to wait for it to expire beforehand.\n\t              // FIXME: this is a placeholder for a port of the transitions library.\n\t              if ( scope.tt_animation ) {\n\t                if (!transitionTimeout) {\n\t                  transitionTimeout = $timeout(removeTooltip, 500);\n\t                }\n\t              } else {\n\t                removeTooltip();\n\t              }\n\t            }\n\t\n\t            function createTooltip() {\n\t              // There can only be one tooltip element per directive shown at once.\n\t              if (tooltip) {\n\t                removeTooltip();\n\t              }\n\t              tooltip = tooltipLinker(scope, function () {});\n\t\n\t              // Get contents rendered into the tooltip\n\t              scope.$digest();\n\t            }\n\t\n\t            function removeTooltip() {\n\t              transitionTimeout = null;\n\t              if (tooltip) {\n\t                tooltip.remove();\n\t                tooltip = null;\n\t              }\n\t            }\n\t\n\t            /**\n\t             * Observe the relevant attributes.\n\t             */\n\t            attrs.$observe( type, function ( val ) {\n\t              scope.tt_content = val;\n\t\n\t              if (!val && scope.tt_isOpen ) {\n\t                hide();\n\t              }\n\t            });\n\t\n\t            attrs.$observe( prefix+'Title', function ( val ) {\n\t              scope.tt_title = val;\n\t            });\n\t\n\t            attrs.$observe( prefix+'Placement', function ( val ) {\n\t              scope.tt_placement = angular.isDefined( val ) ? val : options.placement;\n\t            });\n\t\n\t            attrs.$observe( prefix+'PopupDelay', function ( val ) {\n\t              var delay = parseInt( val, 10 );\n\t              scope.tt_popupDelay = ! isNaN(delay) ? delay : options.popupDelay;\n\t            });\n\t\n\t            var unregisterTriggers = function () {\n\t              element.unbind(triggers.show, showTooltipBind);\n\t              element.unbind(triggers.hide, hideTooltipBind);\n\t            };\n\t\n\t            attrs.$observe( prefix+'Trigger', function ( val ) {\n\t              unregisterTriggers();\n\t\n\t              triggers = getTriggers( val );\n\t\n\t              if ( triggers.show === triggers.hide ) {\n\t                element.bind( triggers.show, toggleTooltipBind );\n\t              } else {\n\t                element.bind( triggers.show, showTooltipBind );\n\t                element.bind( triggers.hide, hideTooltipBind );\n\t              }\n\t            });\n\t\n\t            var animation = scope.$eval(attrs[prefix + 'Animation']);\n\t            scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation;\n\t\n\t            attrs.$observe( prefix+'AppendToBody', function ( val ) {\n\t              appendToBody = angular.isDefined( val ) ? $parse( val )( scope ) : appendToBody;\n\t            });\n\t\n\t            // if a tooltip is attached to <body> we need to remove it on\n\t            // location change as its parent scope will probably not be destroyed\n\t            // by the change.\n\t            if ( appendToBody ) {\n\t              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {\n\t              if ( scope.tt_isOpen ) {\n\t                hide();\n\t              }\n\t            });\n\t            }\n\t\n\t            // Make sure tooltip is destroyed and removed.\n\t            scope.$on('$destroy', function onDestroyTooltip() {\n\t              $timeout.cancel( transitionTimeout );\n\t              $timeout.cancel( popupTimeout );\n\t              unregisterTriggers();\n\t              removeTooltip();\n\t            });\n\t          };\n\t        }\n\t      };\n\t    };\n\t  }];\n\t})\n\t\n\t.directive( 'tooltipPopup', function () {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-popup.html'\n\t  };\n\t})\n\t\n\t.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {\n\t  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );\n\t}])\n\t\n\t.directive( 'tooltipHtmlUnsafePopup', function () {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'\n\t  };\n\t})\n\t\n\t.directive( 'tooltipHtmlUnsafe', [ '$tooltip', function ( $tooltip ) {\n\t  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: popup delay, animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, html popovers, and selector delegatation.\n\t */\n\tangular.module( 'ui.bootstrap.popover', [ 'ui.bootstrap.tooltip' ] )\n\t\n\t.directive( 'popoverPopup', function () {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover.html'\n\t  };\n\t})\n\t\n\t.directive( 'popover', [ '$tooltip', function ( $tooltip ) {\n\t  return $tooltip( 'popover', 'popover', 'click' );\n\t}]);\n\t\n\tangular.module('ui.bootstrap.progressbar', [])\n\t\n\t.constant('progressConfig', {\n\t  animate: true,\n\t  max: 100\n\t})\n\t\n\t.controller('ProgressController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {\n\t    var self = this,\n\t        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\t\n\t    this.bars = [];\n\t    $scope.max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max;\n\t\n\t    this.addBar = function(bar, element) {\n\t        if ( !animate ) {\n\t            element.css({'transition': 'none'});\n\t        }\n\t\n\t        this.bars.push(bar);\n\t\n\t        bar.$watch('value', function( value ) {\n\t            bar.percent = +(100 * value / $scope.max).toFixed(2);\n\t        });\n\t\n\t        bar.$on('$destroy', function() {\n\t            element = null;\n\t            self.removeBar(bar);\n\t        });\n\t    };\n\t\n\t    this.removeBar = function(bar) {\n\t        this.bars.splice(this.bars.indexOf(bar), 1);\n\t    };\n\t}])\n\t\n\t.directive('progress', function() {\n\t    return {\n\t        restrict: 'EA',\n\t        replace: true,\n\t        transclude: true,\n\t        controller: 'ProgressController',\n\t        require: 'progress',\n\t        scope: {},\n\t        templateUrl: 'template/progressbar/progress.html'\n\t    };\n\t})\n\t\n\t.directive('bar', function() {\n\t    return {\n\t        restrict: 'EA',\n\t        replace: true,\n\t        transclude: true,\n\t        require: '^progress',\n\t        scope: {\n\t            value: '=',\n\t            type: '@'\n\t        },\n\t        templateUrl: 'template/progressbar/bar.html',\n\t        link: function(scope, element, attrs, progressCtrl) {\n\t            progressCtrl.addBar(scope, element);\n\t        }\n\t    };\n\t})\n\t\n\t.directive('progressbar', function() {\n\t    return {\n\t        restrict: 'EA',\n\t        replace: true,\n\t        transclude: true,\n\t        controller: 'ProgressController',\n\t        scope: {\n\t            value: '=',\n\t            type: '@'\n\t        },\n\t        templateUrl: 'template/progressbar/progressbar.html',\n\t        link: function(scope, element, attrs, progressCtrl) {\n\t            progressCtrl.addBar(scope, angular.element(element.children()[0]));\n\t        }\n\t    };\n\t});\n\tangular.module('ui.bootstrap.rating', [])\n\t\n\t.constant('ratingConfig', {\n\t  max: 5,\n\t  stateOn: null,\n\t  stateOff: null\n\t})\n\t\n\t.controller('RatingController', ['$scope', '$attrs', 'ratingConfig', function($scope, $attrs, ratingConfig) {\n\t  var ngModelCtrl  = { $setViewValue: angular.noop };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n\t    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\t\n\t    var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) :\n\t                        new Array( angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max );\n\t    $scope.range = this.buildTemplateObjects(ratingStates);\n\t  };\n\t\n\t  this.buildTemplateObjects = function(states) {\n\t    for (var i = 0, n = states.length; i < n; i++) {\n\t      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff }, states[i]);\n\t    }\n\t    return states;\n\t  };\n\t\n\t  $scope.rate = function(value) {\n\t    if ( !$scope.readonly && value >= 0 && value <= $scope.range.length ) {\n\t      ngModelCtrl.$setViewValue(value);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.enter = function(value) {\n\t    if ( !$scope.readonly ) {\n\t      $scope.value = value;\n\t    }\n\t    $scope.onHover({value: value});\n\t  };\n\t\n\t  $scope.reset = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t    $scope.onLeave();\n\t  };\n\t\n\t  $scope.onKeydown = function(evt) {\n\t    if (/(37|38|39|40)/.test(evt.which)) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.rate( $scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1) );\n\t    }\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t  };\n\t}])\n\t\n\t.directive('rating', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    require: ['rating', 'ngModel'],\n\t    scope: {\n\t      readonly: '=?',\n\t      onHover: '&',\n\t      onLeave: '&'\n\t    },\n\t    controller: 'RatingController',\n\t    templateUrl: 'template/rating/rating.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if ( ngModelCtrl ) {\n\t        ratingCtrl.init( ngModelCtrl );\n\t      }\n\t    }\n\t  };\n\t});\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.bootstrap.tabs\n\t *\n\t * @description\n\t * AngularJS version of the tabs directive.\n\t */\n\t\n\tangular.module('ui.bootstrap.tabs', [])\n\t\n\t.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {\n\t  var ctrl = this,\n\t      tabs = ctrl.tabs = $scope.tabs = [];\n\t\n\t  ctrl.select = function(selectedTab) {\n\t    angular.forEach(tabs, function(tab) {\n\t      if (tab.active && tab !== selectedTab) {\n\t        tab.active = false;\n\t        tab.onDeselect();\n\t      }\n\t    });\n\t    selectedTab.active = true;\n\t    selectedTab.onSelect();\n\t  };\n\t\n\t  ctrl.addTab = function addTab(tab) {\n\t    tabs.push(tab);\n\t    // we can't run the select function on the first tab\n\t    // since that would select it twice\n\t    if (tabs.length === 1) {\n\t      tab.active = true;\n\t    } else if (tab.active) {\n\t      ctrl.select(tab);\n\t    }\n\t  };\n\t\n\t  ctrl.removeTab = function removeTab(tab) {\n\t    var index = tabs.indexOf(tab);\n\t    //Select a new tab if the tab to be removed is selected\n\t    if (tab.active && tabs.length > 1) {\n\t      //If this is the last tab, select the previous tab. else, the next tab.\n\t      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n\t      ctrl.select(tabs[newActiveIndex]);\n\t    }\n\t    tabs.splice(index, 1);\n\t  };\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tabset\n\t * @restrict EA\n\t *\n\t * @description\n\t * Tabset is the outer container for the tabs directive\n\t *\n\t * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n\t * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <tabset>\n\t      <tab heading=\"Tab 1\"><b>First</b> Content!</tab>\n\t      <tab heading=\"Tab 2\"><i>Second</i> Content!</tab>\n\t    </tabset>\n\t    <hr />\n\t    <tabset vertical=\"true\">\n\t      <tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</tab>\n\t      <tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</tab>\n\t    </tabset>\n\t    <tabset justified=\"true\">\n\t      <tab heading=\"Justified Tab 1\"><b>First</b> Justified Content!</tab>\n\t      <tab heading=\"Justified Tab 2\"><i>Second</i> Justified Content!</tab>\n\t    </tabset>\n\t  </file>\n\t</example>\n\t */\n\t.directive('tabset', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@'\n\t    },\n\t    controller: 'TabsetController',\n\t    templateUrl: 'template/tabs/tabset.html',\n\t    link: function(scope, element, attrs) {\n\t      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n\t      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n\t    }\n\t  };\n\t})\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tab\n\t * @restrict EA\n\t *\n\t * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\n\t * @param {string=} select An expression to evaluate when the tab is selected.\n\t * @param {boolean=} active A binding, telling whether or not this tab is selected.\n\t * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n\t *\n\t * @description\n\t * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <div ng-controller=\"TabsDemoCtrl\">\n\t      <button class=\"btn btn-small\" ng-click=\"items[0].active = true\">\n\t        Select item 1, using active binding\n\t      </button>\n\t      <button class=\"btn btn-small\" ng-click=\"items[1].disabled = !items[1].disabled\">\n\t        Enable/disable item 2, using disabled binding\n\t      </button>\n\t      <br />\n\t      <tabset>\n\t        <tab heading=\"Tab 1\">First Tab</tab>\n\t        <tab select=\"alertMe()\">\n\t          <tab-heading><i class=\"icon-bell\"></i> Alert me!</tab-heading>\n\t          Second Tab, with alert callback and html heading!\n\t        </tab>\n\t        <tab ng-repeat=\"item in items\"\n\t          heading=\"{{item.title}}\"\n\t          disabled=\"item.disabled\"\n\t          active=\"item.active\">\n\t          {{item.content}}\n\t        </tab>\n\t      </tabset>\n\t    </div>\n\t  </file>\n\t  <file name=\"script.js\">\n\t    function TabsDemoCtrl($scope) {\n\t      $scope.items = [\n\t        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\n\t        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\n\t      ];\n\t\n\t      $scope.alertMe = function() {\n\t        setTimeout(function() {\n\t          alert(\"You've selected the alert tab!\");\n\t        });\n\t      };\n\t    };\n\t  </file>\n\t</example>\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tabHeading\n\t * @restrict EA\n\t *\n\t * @description\n\t * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <tabset>\n\t      <tab>\n\t        <tab-heading><b>HTML</b> in my titles?!</tab-heading>\n\t        And some content, too!\n\t      </tab>\n\t      <tab>\n\t        <tab-heading><i class=\"icon-heart\"></i> Icon heading?!?</tab-heading>\n\t        That's right.\n\t      </tab>\n\t    </tabset>\n\t  </file>\n\t</example>\n\t */\n\t.directive('tab', ['$parse', function($parse) {\n\t  return {\n\t    require: '^tabset',\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/tabs/tab.html',\n\t    transclude: true,\n\t    scope: {\n\t      active: '=?',\n\t      heading: '@',\n\t      onSelect: '&select', //This callback is called in contentHeadingTransclude\n\t                          //once it inserts the tab's content into the dom\n\t      onDeselect: '&deselect'\n\t    },\n\t    controller: function() {\n\t      //Empty controller so other directives can require being 'under' a tab\n\t    },\n\t    compile: function(elm, attrs, transclude) {\n\t      return function postLink(scope, elm, attrs, tabsetCtrl) {\n\t        scope.$watch('active', function(active) {\n\t          if (active) {\n\t            tabsetCtrl.select(scope);\n\t          }\n\t        });\n\t\n\t        scope.disabled = false;\n\t        if ( attrs.disabled ) {\n\t          scope.$parent.$watch($parse(attrs.disabled), function(value) {\n\t            scope.disabled = !! value;\n\t          });\n\t        }\n\t\n\t        scope.select = function() {\n\t          if ( !scope.disabled ) {\n\t            scope.active = true;\n\t          }\n\t        };\n\t\n\t        tabsetCtrl.addTab(scope);\n\t        scope.$on('$destroy', function() {\n\t          tabsetCtrl.removeTab(scope);\n\t        });\n\t\n\t        //We need to transclude later, once the content container is ready.\n\t        //when this link happens, we're inside a tab heading.\n\t        scope.$transcludeFn = transclude;\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tabHeadingTransclude', [function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^tab',\n\t    link: function(scope, elm, attrs, tabCtrl) {\n\t      scope.$watch('headingElement', function updateHeadingElement(heading) {\n\t        if (heading) {\n\t          elm.html('');\n\t          elm.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tabContentTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^tabset',\n\t    link: function(scope, elm, attrs) {\n\t      var tab = scope.$eval(attrs.tabContentTransclude);\n\t\n\t      //Now our tab is ready to be transcluded: both the tab heading area\n\t      //and the tab content area are loaded.  Transclude 'em both.\n\t      tab.$transcludeFn(tab.$parent, function(contents) {\n\t        angular.forEach(contents, function(node) {\n\t          if (isTabHeading(node)) {\n\t            //Let tabHeadingTransclude know.\n\t            tab.headingElement = node;\n\t          } else {\n\t            elm.append(node);\n\t          }\n\t        });\n\t      });\n\t    }\n\t  };\n\t  function isTabHeading(node) {\n\t    return node.tagName &&  (\n\t      node.hasAttribute('tab-heading') ||\n\t      node.hasAttribute('data-tab-heading') ||\n\t      node.tagName.toLowerCase() === 'tab-heading' ||\n\t      node.tagName.toLowerCase() === 'data-tab-heading'\n\t    );\n\t  }\n\t})\n\t\n\t;\n\t\n\tangular.module('ui.bootstrap.timepicker', [])\n\t\n\t.constant('timepickerConfig', {\n\t  hourStep: 1,\n\t  minuteStep: 1,\n\t  showMeridian: true,\n\t  meridians: null,\n\t  readonlyInput: false,\n\t  mousewheel: true\n\t})\n\t\n\t.controller('TimepickerController', ['$scope', '$attrs', '$parse', '$log', '$locale', 'timepickerConfig', function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {\n\t  var selected = new Date(),\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\t\n\t  this.init = function( ngModelCtrl_, inputs ) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    var hoursInputEl = inputs.eq(0),\n\t        minutesInputEl = inputs.eq(1);\n\t\n\t    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\t    if ( mousewheel ) {\n\t      this.setupMousewheelEvents( hoursInputEl, minutesInputEl );\n\t    }\n\t\n\t    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n\t    this.setupInputEvents( hoursInputEl, minutesInputEl );\n\t  };\n\t\n\t  var hourStep = timepickerConfig.hourStep;\n\t  if ($attrs.hourStep) {\n\t    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n\t      hourStep = parseInt(value, 10);\n\t    });\n\t  }\n\t\n\t  var minuteStep = timepickerConfig.minuteStep;\n\t  if ($attrs.minuteStep) {\n\t    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n\t      minuteStep = parseInt(value, 10);\n\t    });\n\t  }\n\t\n\t  // 12H / 24H mode\n\t  $scope.showMeridian = timepickerConfig.showMeridian;\n\t  if ($attrs.showMeridian) {\n\t    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n\t      $scope.showMeridian = !!value;\n\t\n\t      if ( ngModelCtrl.$error.time ) {\n\t        // Evaluate from template\n\t        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n\t        if (angular.isDefined( hours ) && angular.isDefined( minutes )) {\n\t          selected.setHours( hours );\n\t          refresh();\n\t        }\n\t      } else {\n\t        updateTemplate();\n\t      }\n\t    });\n\t  }\n\t\n\t  // Get $scope.hours in 24H mode if valid\n\t  function getHoursFromTemplate ( ) {\n\t    var hours = parseInt( $scope.hours, 10 );\n\t    var valid = ( $scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n\t    if ( !valid ) {\n\t      return undefined;\n\t    }\n\t\n\t    if ( $scope.showMeridian ) {\n\t      if ( hours === 12 ) {\n\t        hours = 0;\n\t      }\n\t      if ( $scope.meridian === meridians[1] ) {\n\t        hours = hours + 12;\n\t      }\n\t    }\n\t    return hours;\n\t  }\n\t\n\t  function getMinutesFromTemplate() {\n\t    var minutes = parseInt($scope.minutes, 10);\n\t    return ( minutes >= 0 && minutes < 60 ) ? minutes : undefined;\n\t  }\n\t\n\t  function pad( value ) {\n\t    return ( angular.isDefined(value) && value.toString().length < 2 ) ? '0' + value : value;\n\t  }\n\t\n\t  // Respond on mousewheel spin\n\t  this.setupMousewheelEvents = function( hoursInputEl, minutesInputEl ) {\n\t    var isScrollingUp = function(e) {\n\t      if (e.originalEvent) {\n\t        e = e.originalEvent;\n\t      }\n\t      //pick correct delta variable depending on event\n\t      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n\t      return (e.detail || delta > 0);\n\t    };\n\t\n\t    hoursInputEl.bind('mousewheel wheel', function(e) {\n\t      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementHours() : $scope.decrementHours() );\n\t      e.preventDefault();\n\t    });\n\t\n\t    minutesInputEl.bind('mousewheel wheel', function(e) {\n\t      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementMinutes() : $scope.decrementMinutes() );\n\t      e.preventDefault();\n\t    });\n\t\n\t  };\n\t\n\t  this.setupInputEvents = function( hoursInputEl, minutesInputEl ) {\n\t    if ( $scope.readonlyInput ) {\n\t      $scope.updateHours = angular.noop;\n\t      $scope.updateMinutes = angular.noop;\n\t      return;\n\t    }\n\t\n\t    var invalidate = function(invalidHours, invalidMinutes) {\n\t      ngModelCtrl.$setViewValue( null );\n\t      ngModelCtrl.$setValidity('time', false);\n\t      if (angular.isDefined(invalidHours)) {\n\t        $scope.invalidHours = invalidHours;\n\t      }\n\t      if (angular.isDefined(invalidMinutes)) {\n\t        $scope.invalidMinutes = invalidMinutes;\n\t      }\n\t    };\n\t\n\t    $scope.updateHours = function() {\n\t      var hours = getHoursFromTemplate();\n\t\n\t      if ( angular.isDefined(hours) ) {\n\t        selected.setHours( hours );\n\t        refresh( 'h' );\n\t      } else {\n\t        invalidate(true);\n\t      }\n\t    };\n\t\n\t    hoursInputEl.bind('blur', function(e) {\n\t      if ( !$scope.invalidHours && $scope.hours < 10) {\n\t        $scope.$apply( function() {\n\t          $scope.hours = pad( $scope.hours );\n\t        });\n\t      }\n\t    });\n\t\n\t    $scope.updateMinutes = function() {\n\t      var minutes = getMinutesFromTemplate();\n\t\n\t      if ( angular.isDefined(minutes) ) {\n\t        selected.setMinutes( minutes );\n\t        refresh( 'm' );\n\t      } else {\n\t        invalidate(undefined, true);\n\t      }\n\t    };\n\t\n\t    minutesInputEl.bind('blur', function(e) {\n\t      if ( !$scope.invalidMinutes && $scope.minutes < 10 ) {\n\t        $scope.$apply( function() {\n\t          $scope.minutes = pad( $scope.minutes );\n\t        });\n\t      }\n\t    });\n\t\n\t  };\n\t\n\t  this.render = function() {\n\t    var date = ngModelCtrl.$modelValue ? new Date( ngModelCtrl.$modelValue ) : null;\n\t\n\t    if ( isNaN(date) ) {\n\t      ngModelCtrl.$setValidity('time', false);\n\t      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t    } else {\n\t      if ( date ) {\n\t        selected = date;\n\t      }\n\t      makeValid();\n\t      updateTemplate();\n\t    }\n\t  };\n\t\n\t  // Call internally when we know that model is valid.\n\t  function refresh( keyboardChange ) {\n\t    makeValid();\n\t    ngModelCtrl.$setViewValue( new Date(selected) );\n\t    updateTemplate( keyboardChange );\n\t  }\n\t\n\t  function makeValid() {\n\t    ngModelCtrl.$setValidity('time', true);\n\t    $scope.invalidHours = false;\n\t    $scope.invalidMinutes = false;\n\t  }\n\t\n\t  function updateTemplate( keyboardChange ) {\n\t    var hours = selected.getHours(), minutes = selected.getMinutes();\n\t\n\t    if ( $scope.showMeridian ) {\n\t      hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system\n\t    }\n\t\n\t    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n\t    $scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);\n\t    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\t  }\n\t\n\t  function addMinutes( minutes ) {\n\t    var dt = new Date( selected.getTime() + minutes * 60000 );\n\t    selected.setHours( dt.getHours(), dt.getMinutes() );\n\t    refresh();\n\t  }\n\t\n\t  $scope.incrementHours = function() {\n\t    addMinutes( hourStep * 60 );\n\t  };\n\t  $scope.decrementHours = function() {\n\t    addMinutes( - hourStep * 60 );\n\t  };\n\t  $scope.incrementMinutes = function() {\n\t    addMinutes( minuteStep );\n\t  };\n\t  $scope.decrementMinutes = function() {\n\t    addMinutes( - minuteStep );\n\t  };\n\t  $scope.toggleMeridian = function() {\n\t    addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );\n\t  };\n\t}])\n\t\n\t.directive('timepicker', function () {\n\t  return {\n\t    restrict: 'EA',\n\t    require: ['timepicker', '?^ngModel'],\n\t    controller:'TimepickerController',\n\t    replace: true,\n\t    scope: {},\n\t    templateUrl: 'template/timepicker/timepicker.html',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if ( ngModelCtrl ) {\n\t        timepickerCtrl.init( ngModelCtrl, element.find('input') );\n\t      }\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])\n\t\n\t/**\n\t * A helper service that can parse typeahead's syntax (string provided by users)\n\t * Extracted to a separate service for ease of unit testing\n\t */\n\t  .factory('typeaheadParser', ['$parse', function ($parse) {\n\t\n\t  //                      00000111000000000000022200000000000000003333333333333330000000000044000\n\t  var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n\t\n\t  return {\n\t    parse:function (input) {\n\t\n\t      var match = input.match(TYPEAHEAD_REGEXP);\n\t      if (!match) {\n\t        throw new Error(\n\t          'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n\t            ' but got \"' + input + '\".');\n\t      }\n\t\n\t      return {\n\t        itemName:match[3],\n\t        source:$parse(match[4]),\n\t        viewMapper:$parse(match[2] || match[1]),\n\t        modelMapper:$parse(match[1])\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',\n\t    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {\n\t\n\t  var HOT_KEYS = [9, 13, 27, 38, 40];\n\t\n\t  return {\n\t    require:'ngModel',\n\t    link:function (originalScope, element, attrs, modelCtrl) {\n\t\n\t      //SUPPORTED ATTRIBUTES (OPTIONS)\n\t\n\t      //minimal no of characters that needs to be entered before typeahead kicks-in\n\t      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;\n\t\n\t      //minimal wait time after last character typed before typehead kicks-in\n\t      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\t\n\t      //should it restrict model values to the ones selected from the popup only?\n\t      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\t\n\t      //binding to a variable that indicates if matches are being retrieved asynchronously\n\t      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\t\n\t      //a callback executed when a match is selected\n\t      var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\t\n\t      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\t\n\t      var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\t\n\t      //INTERNAL VARIABLES\n\t\n\t      //model setter executed upon match selection\n\t      var $setModelValue = $parse(attrs.ngModel).assign;\n\t\n\t      //expressions used by typeahead\n\t      var parserResult = typeaheadParser.parse(attrs.typeahead);\n\t\n\t      var hasFocus;\n\t\n\t      //create a child scope for the typeahead directive so we are not polluting original scope\n\t      //with typeahead-specific data (matches, query etc.)\n\t      var scope = originalScope.$new();\n\t      originalScope.$on('$destroy', function(){\n\t        scope.$destroy();\n\t      });\n\t\n\t      // WAI-ARIA\n\t      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t      element.attr({\n\t        'aria-autocomplete': 'list',\n\t        'aria-expanded': false,\n\t        'aria-owns': popupId\n\t      });\n\t\n\t      //pop-up element used to display matches\n\t      var popUpEl = angular.element('<div typeahead-popup></div>');\n\t      popUpEl.attr({\n\t        id: popupId,\n\t        matches: 'matches',\n\t        active: 'activeIdx',\n\t        select: 'select(activeIdx)',\n\t        query: 'query',\n\t        position: 'position'\n\t      });\n\t      //custom item template\n\t      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n\t        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n\t      }\n\t\n\t      var resetMatches = function() {\n\t        scope.matches = [];\n\t        scope.activeIdx = -1;\n\t        element.attr('aria-expanded', false);\n\t      };\n\t\n\t      var getMatchId = function(index) {\n\t        return popupId + '-option-' + index;\n\t      };\n\t\n\t      // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n\t      // This attribute is added or removed automatically when the `activeIdx` changes.\n\t      scope.$watch('activeIdx', function(index) {\n\t        if (index < 0) {\n\t          element.removeAttr('aria-activedescendant');\n\t        } else {\n\t          element.attr('aria-activedescendant', getMatchId(index));\n\t        }\n\t      });\n\t\n\t      var getMatchesAsync = function(inputValue) {\n\t\n\t        var locals = {$viewValue: inputValue};\n\t        isLoadingSetter(originalScope, true);\n\t        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\t\n\t          //it might happen that several async queries were in progress if a user were typing fast\n\t          //but we are interested only in responses that correspond to the current view value\n\t          var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n\t          if (onCurrentRequest && hasFocus) {\n\t            if (matches.length > 0) {\n\t\n\t              scope.activeIdx = 0;\n\t              scope.matches.length = 0;\n\t\n\t              //transform labels\n\t              for(var i=0; i<matches.length; i++) {\n\t                locals[parserResult.itemName] = matches[i];\n\t                scope.matches.push({\n\t                  id: getMatchId(i),\n\t                  label: parserResult.viewMapper(scope, locals),\n\t                  model: matches[i]\n\t                });\n\t              }\n\t\n\t              scope.query = inputValue;\n\t              //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n\t              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n\t              //due to other elements being rendered\n\t              scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t              scope.position.top = scope.position.top + element.prop('offsetHeight');\n\t\n\t              element.attr('aria-expanded', true);\n\t            } else {\n\t              resetMatches();\n\t            }\n\t          }\n\t          if (onCurrentRequest) {\n\t            isLoadingSetter(originalScope, false);\n\t          }\n\t        }, function(){\n\t          resetMatches();\n\t          isLoadingSetter(originalScope, false);\n\t        });\n\t      };\n\t\n\t      resetMatches();\n\t\n\t      //we need to propagate user's query so we can higlight matches\n\t      scope.query = undefined;\n\t\n\t      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later \n\t      var timeoutPromise;\n\t\n\t      var scheduleSearchWithTimeout = function(inputValue) {\n\t        timeoutPromise = $timeout(function () {\n\t          getMatchesAsync(inputValue);\n\t        }, waitTime);\n\t      };\n\t\n\t      var cancelPreviousTimeout = function() {\n\t        if (timeoutPromise) {\n\t          $timeout.cancel(timeoutPromise);\n\t        }\n\t      };\n\t\n\t      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n\t      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n\t      modelCtrl.$parsers.unshift(function (inputValue) {\n\t\n\t        hasFocus = true;\n\t\n\t        if (inputValue && inputValue.length >= minSearch) {\n\t          if (waitTime > 0) {\n\t            cancelPreviousTimeout();\n\t            scheduleSearchWithTimeout(inputValue);\n\t          } else {\n\t            getMatchesAsync(inputValue);\n\t          }\n\t        } else {\n\t          isLoadingSetter(originalScope, false);\n\t          cancelPreviousTimeout();\n\t          resetMatches();\n\t        }\n\t\n\t        if (isEditable) {\n\t          return inputValue;\n\t        } else {\n\t          if (!inputValue) {\n\t            // Reset in case user had typed something previously.\n\t            modelCtrl.$setValidity('editable', true);\n\t            return inputValue;\n\t          } else {\n\t            modelCtrl.$setValidity('editable', false);\n\t            return undefined;\n\t          }\n\t        }\n\t      });\n\t\n\t      modelCtrl.$formatters.push(function (modelValue) {\n\t\n\t        var candidateViewValue, emptyViewValue;\n\t        var locals = {};\n\t\n\t        if (inputFormatter) {\n\t\n\t          locals['$model'] = modelValue;\n\t          return inputFormatter(originalScope, locals);\n\t\n\t        } else {\n\t\n\t          //it might happen that we don't have enough info to properly render input value\n\t          //we need to check for this situation and simply return model value if we can't apply custom formatting\n\t          locals[parserResult.itemName] = modelValue;\n\t          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n\t          locals[parserResult.itemName] = undefined;\n\t          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\t\n\t          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;\n\t        }\n\t      });\n\t\n\t      scope.select = function (activeIdx) {\n\t        //called from within the $digest() cycle\n\t        var locals = {};\n\t        var model, item;\n\t\n\t        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n\t        model = parserResult.modelMapper(originalScope, locals);\n\t        $setModelValue(originalScope, model);\n\t        modelCtrl.$setValidity('editable', true);\n\t\n\t        onSelectCallback(originalScope, {\n\t          $item: item,\n\t          $model: model,\n\t          $label: parserResult.viewMapper(originalScope, locals)\n\t        });\n\t\n\t        resetMatches();\n\t\n\t        //return focus to the input element if a match was selected via a mouse click event\n\t        // use timeout to avoid $rootScope:inprog error\n\t        $timeout(function() { element[0].focus(); }, 0, false);\n\t      };\n\t\n\t      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n\t      element.bind('keydown', function (evt) {\n\t\n\t        //typeahead is open and an \"interesting\" key was pressed\n\t        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n\t          return;\n\t        }\n\t\n\t        evt.preventDefault();\n\t\n\t        if (evt.which === 40) {\n\t          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n\t          scope.$digest();\n\t\n\t        } else if (evt.which === 38) {\n\t          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;\n\t          scope.$digest();\n\t\n\t        } else if (evt.which === 13 || evt.which === 9) {\n\t          scope.$apply(function () {\n\t            scope.select(scope.activeIdx);\n\t          });\n\t\n\t        } else if (evt.which === 27) {\n\t          evt.stopPropagation();\n\t\n\t          resetMatches();\n\t          scope.$digest();\n\t        }\n\t      });\n\t\n\t      element.bind('blur', function (evt) {\n\t        hasFocus = false;\n\t      });\n\t\n\t      // Keep reference to click handler to unbind it.\n\t      var dismissClickHandler = function (evt) {\n\t        if (element[0] !== evt.target) {\n\t          resetMatches();\n\t          scope.$digest();\n\t        }\n\t      };\n\t\n\t      $document.bind('click', dismissClickHandler);\n\t\n\t      originalScope.$on('$destroy', function(){\n\t        $document.unbind('click', dismissClickHandler);\n\t      });\n\t\n\t      var $popup = $compile(popUpEl)(scope);\n\t      if ( appendToBody ) {\n\t        $document.find('body').append($popup);\n\t      } else {\n\t        element.after($popup);\n\t      }\n\t    }\n\t  };\n\t\n\t}])\n\t\n\t  .directive('typeaheadPopup', function () {\n\t    return {\n\t      restrict:'EA',\n\t      scope:{\n\t        matches:'=',\n\t        query:'=',\n\t        active:'=',\n\t        position:'=',\n\t        select:'&'\n\t      },\n\t      replace:true,\n\t      templateUrl:'template/typeahead/typeahead-popup.html',\n\t      link:function (scope, element, attrs) {\n\t\n\t        scope.templateUrl = attrs.templateUrl;\n\t\n\t        scope.isOpen = function () {\n\t          return scope.matches.length > 0;\n\t        };\n\t\n\t        scope.isActive = function (matchIdx) {\n\t          return scope.active == matchIdx;\n\t        };\n\t\n\t        scope.selectActive = function (matchIdx) {\n\t          scope.active = matchIdx;\n\t        };\n\t\n\t        scope.selectMatch = function (activeIdx) {\n\t          scope.select({activeIdx:activeIdx});\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {\n\t    return {\n\t      restrict:'EA',\n\t      scope:{\n\t        index:'=',\n\t        match:'=',\n\t        query:'='\n\t      },\n\t      link:function (scope, element, attrs) {\n\t        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n\t        $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent){\n\t           element.replaceWith($compile(tplContent.trim())(scope));\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .filter('typeaheadHighlight', function() {\n\t\n\t    function escapeRegexp(queryToEscape) {\n\t      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n\t    }\n\t\n\t    return function(matchItem, query) {\n\t      return query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;\n\t    };\n\t  });\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * angular-ui-bootstrap\n\t * http://angular-ui.github.io/bootstrap/\n\t\n\t * Version: 0.11.2 - 2014-09-26\n\t * License: MIT\n\t */\n\tangular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.transition\",\"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.bindHtml\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.modal\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\n\tangular.module(\"ui.bootstrap.tpls\", [\"template/accordion/accordion-group.html\",\"template/accordion/accordion.html\",\"template/alert/alert.html\",\"template/carousel/carousel.html\",\"template/carousel/slide.html\",\"template/datepicker/datepicker.html\",\"template/datepicker/day.html\",\"template/datepicker/month.html\",\"template/datepicker/popup.html\",\"template/datepicker/year.html\",\"template/modal/backdrop.html\",\"template/modal/window.html\",\"template/pagination/pager.html\",\"template/pagination/pagination.html\",\"template/tooltip/tooltip-html-unsafe-popup.html\",\"template/tooltip/tooltip-popup.html\",\"template/popover/popover.html\",\"template/progressbar/bar.html\",\"template/progressbar/progress.html\",\"template/progressbar/progressbar.html\",\"template/rating/rating.html\",\"template/tabs/tab.html\",\"template/tabs/tabset.html\",\"template/timepicker/timepicker.html\",\"template/typeahead/typeahead-match.html\",\"template/typeahead/typeahead-popup.html\"]);\n\tangular.module('ui.bootstrap.transition', [])\n\t\n\t/**\n\t * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.\n\t * @param  {DOMElement} element  The DOMElement that will be animated.\n\t * @param  {string|object|function} trigger  The thing that will cause the transition to start:\n\t *   - As a string, it represents the css class to be added to the element.\n\t *   - As an object, it represents a hash of style attributes to be applied to the element.\n\t *   - As a function, it represents a function to be called that will cause the transition to occur.\n\t * @return {Promise}  A promise that is resolved when the transition finishes.\n\t */\n\t.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {\n\t\n\t  var $transition = function(element, trigger, options) {\n\t    options = options || {};\n\t    var deferred = $q.defer();\n\t    var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];\n\t\n\t    var transitionEndHandler = function(event) {\n\t      $rootScope.$apply(function() {\n\t        element.unbind(endEventName, transitionEndHandler);\n\t        deferred.resolve(element);\n\t      });\n\t    };\n\t\n\t    if (endEventName) {\n\t      element.bind(endEventName, transitionEndHandler);\n\t    }\n\t\n\t    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur\n\t    $timeout(function() {\n\t      if ( angular.isString(trigger) ) {\n\t        element.addClass(trigger);\n\t      } else if ( angular.isFunction(trigger) ) {\n\t        trigger(element);\n\t      } else if ( angular.isObject(trigger) ) {\n\t        element.css(trigger);\n\t      }\n\t      //If browser does not support transitions, instantly resolve\n\t      if ( !endEventName ) {\n\t        deferred.resolve(element);\n\t      }\n\t    });\n\t\n\t    // Add our custom cancel function to the promise that is returned\n\t    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,\n\t    // i.e. it will therefore never raise a transitionEnd event for that transition\n\t    deferred.promise.cancel = function() {\n\t      if ( endEventName ) {\n\t        element.unbind(endEventName, transitionEndHandler);\n\t      }\n\t      deferred.reject('Transition cancelled');\n\t    };\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  // Work out the name of the transitionEnd event\n\t  var transElement = document.createElement('trans');\n\t  var transitionEndEventNames = {\n\t    'WebkitTransition': 'webkitTransitionEnd',\n\t    'MozTransition': 'transitionend',\n\t    'OTransition': 'oTransitionEnd',\n\t    'transition': 'transitionend'\n\t  };\n\t  var animationEndEventNames = {\n\t    'WebkitTransition': 'webkitAnimationEnd',\n\t    'MozTransition': 'animationend',\n\t    'OTransition': 'oAnimationEnd',\n\t    'transition': 'animationend'\n\t  };\n\t  function findEndEventName(endEventNames) {\n\t    for (var name in endEventNames){\n\t      if (transElement.style[name] !== undefined) {\n\t        return endEventNames[name];\n\t      }\n\t    }\n\t  }\n\t  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);\n\t  $transition.animationEndEventName = findEndEventName(animationEndEventNames);\n\t  return $transition;\n\t}]);\n\t\n\tangular.module('ui.bootstrap.collapse', ['ui.bootstrap.transition'])\n\t\n\t  .directive('collapse', ['$transition', function ($transition) {\n\t\n\t    return {\n\t      link: function (scope, element, attrs) {\n\t\n\t        var initialAnimSkip = true;\n\t        var currentTransition;\n\t\n\t        function doTransition(change) {\n\t          var newTransition = $transition(element, change);\n\t          if (currentTransition) {\n\t            currentTransition.cancel();\n\t          }\n\t          currentTransition = newTransition;\n\t          newTransition.then(newTransitionDone, newTransitionDone);\n\t          return newTransition;\n\t\n\t          function newTransitionDone() {\n\t            // Make sure it's this transition, otherwise, leave it alone.\n\t            if (currentTransition === newTransition) {\n\t              currentTransition = undefined;\n\t            }\n\t          }\n\t        }\n\t\n\t        function expand() {\n\t          if (initialAnimSkip) {\n\t            initialAnimSkip = false;\n\t            expandDone();\n\t          } else {\n\t            element.removeClass('collapse').addClass('collapsing');\n\t            doTransition({ height: element[0].scrollHeight + 'px' }).then(expandDone);\n\t          }\n\t        }\n\t\n\t        function expandDone() {\n\t          element.removeClass('collapsing');\n\t          element.addClass('collapse in');\n\t          element.css({height: 'auto'});\n\t        }\n\t\n\t        function collapse() {\n\t          if (initialAnimSkip) {\n\t            initialAnimSkip = false;\n\t            collapseDone();\n\t            element.css({height: 0});\n\t          } else {\n\t            // CSS transitions don't work with height: auto, so we have to manually change the height to a specific value\n\t            element.css({ height: element[0].scrollHeight + 'px' });\n\t            //trigger reflow so a browser realizes that height was updated from auto to a specific value\n\t            var x = element[0].offsetWidth;\n\t\n\t            element.removeClass('collapse in').addClass('collapsing');\n\t\n\t            doTransition({ height: 0 }).then(collapseDone);\n\t          }\n\t        }\n\t\n\t        function collapseDone() {\n\t          element.removeClass('collapsing');\n\t          element.addClass('collapse');\n\t        }\n\t\n\t        scope.$watch(attrs.collapse, function (shouldCollapse) {\n\t          if (shouldCollapse) {\n\t            collapse();\n\t          } else {\n\t            expand();\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\t\n\t.constant('accordionConfig', {\n\t  closeOthers: true\n\t})\n\t\n\t.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {\n\t\n\t  // This array keeps track of the accordion groups\n\t  this.groups = [];\n\t\n\t  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n\t  this.closeOthers = function(openGroup) {\n\t    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n\t    if ( closeOthers ) {\n\t      angular.forEach(this.groups, function (group) {\n\t        if ( group !== openGroup ) {\n\t          group.isOpen = false;\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  // This is called from the accordion-group directive to add itself to the accordion\n\t  this.addGroup = function(groupScope) {\n\t    var that = this;\n\t    this.groups.push(groupScope);\n\t\n\t    groupScope.$on('$destroy', function (event) {\n\t      that.removeGroup(groupScope);\n\t    });\n\t  };\n\t\n\t  // This is called from the accordion-group directive when to remove itself\n\t  this.removeGroup = function(group) {\n\t    var index = this.groups.indexOf(group);\n\t    if ( index !== -1 ) {\n\t      this.groups.splice(index, 1);\n\t    }\n\t  };\n\t\n\t}])\n\t\n\t// The accordion directive simply sets up the directive controller\n\t// and adds an accordion CSS class to itself element.\n\t.directive('accordion', function () {\n\t  return {\n\t    restrict:'EA',\n\t    controller:'AccordionController',\n\t    transclude: true,\n\t    replace: false,\n\t    templateUrl: 'template/accordion/accordion.html'\n\t  };\n\t})\n\t\n\t// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n\t.directive('accordionGroup', function() {\n\t  return {\n\t    require:'^accordion',         // We need this directive to be inside an accordion\n\t    restrict:'EA',\n\t    transclude:true,              // It transcludes the contents of the directive into the template\n\t    replace: true,                // The element containing the directive will be replaced with the template\n\t    templateUrl:'template/accordion/accordion-group.html',\n\t    scope: {\n\t      heading: '@',               // Interpolate the heading attribute onto this scope\n\t      isOpen: '=?',\n\t      isDisabled: '=?'\n\t    },\n\t    controller: function() {\n\t      this.setHeading = function(element) {\n\t        this.heading = element;\n\t      };\n\t    },\n\t    link: function(scope, element, attrs, accordionCtrl) {\n\t      accordionCtrl.addGroup(scope);\n\t\n\t      scope.$watch('isOpen', function(value) {\n\t        if ( value ) {\n\t          accordionCtrl.closeOthers(scope);\n\t        }\n\t      });\n\t\n\t      scope.toggleOpen = function() {\n\t        if ( !scope.isDisabled ) {\n\t          scope.isOpen = !scope.isOpen;\n\t        }\n\t      };\n\t    }\n\t  };\n\t})\n\t\n\t// Use accordion-heading below an accordion-group to provide a heading containing HTML\n\t// <accordion-group>\n\t//   <accordion-heading>Heading containing HTML - <img src=\"...\"></accordion-heading>\n\t// </accordion-group>\n\t.directive('accordionHeading', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    transclude: true,   // Grab the contents to be used as the heading\n\t    template: '',       // In effect remove this element!\n\t    replace: true,\n\t    require: '^accordionGroup',\n\t    link: function(scope, element, attr, accordionGroupCtrl, transclude) {\n\t      // Pass the heading to the accordion-group controller\n\t      // so that it can be transcluded into the right place in the template\n\t      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n\t      accordionGroupCtrl.setHeading(transclude(scope, function() {}));\n\t    }\n\t  };\n\t})\n\t\n\t// Use in the accordion-group template to indicate where you want the heading to be transcluded\n\t// You must provide the property on the accordion-group controller that will hold the transcluded element\n\t// <div class=\"accordion-group\">\n\t//   <div class=\"accordion-heading\" ><a ... accordion-transclude=\"heading\">...</a></div>\n\t//   ...\n\t// </div>\n\t.directive('accordionTransclude', function() {\n\t  return {\n\t    require: '^accordionGroup',\n\t    link: function(scope, element, attr, controller) {\n\t      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n\t        if ( heading ) {\n\t          element.html('');\n\t          element.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.alert', [])\n\t\n\t.controller('AlertController', ['$scope', '$attrs', function ($scope, $attrs) {\n\t  $scope.closeable = 'close' in $attrs;\n\t}])\n\t\n\t.directive('alert', function () {\n\t  return {\n\t    restrict:'EA',\n\t    controller:'AlertController',\n\t    templateUrl:'template/alert/alert.html',\n\t    transclude:true,\n\t    replace:true,\n\t    scope: {\n\t      type: '@',\n\t      close: '&'\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.bindHtml', [])\n\t\n\t  .directive('bindHtmlUnsafe', function () {\n\t    return function (scope, element, attr) {\n\t      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);\n\t      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {\n\t        element.html(value || '');\n\t      });\n\t    };\n\t  });\n\tangular.module('ui.bootstrap.buttons', [])\n\t\n\t.constant('buttonConfig', {\n\t  activeClass: 'active',\n\t  toggleEvent: 'click'\n\t})\n\t\n\t.controller('ButtonsController', ['buttonConfig', function(buttonConfig) {\n\t  this.activeClass = buttonConfig.activeClass || 'active';\n\t  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n\t}])\n\t\n\t.directive('btnRadio', function () {\n\t  return {\n\t    require: ['btnRadio', 'ngModel'],\n\t    controller: 'ButtonsController',\n\t    link: function (scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function () {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n\t      };\n\t\n\t      //ui->model\n\t      element.bind(buttonsCtrl.toggleEvent, function () {\n\t        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\t\n\t        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n\t          scope.$apply(function () {\n\t            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));\n\t            ngModelCtrl.$render();\n\t          });\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('btnCheckbox', function () {\n\t  return {\n\t    require: ['btnCheckbox', 'ngModel'],\n\t    controller: 'ButtonsController',\n\t    link: function (scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      function getTrueValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n\t      }\n\t\n\t      function getFalseValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n\t      }\n\t\n\t      function getCheckboxValue(attributeValue, defaultValue) {\n\t        var val = scope.$eval(attributeValue);\n\t        return angular.isDefined(val) ? val : defaultValue;\n\t      }\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function () {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n\t      };\n\t\n\t      //ui->model\n\t      element.bind(buttonsCtrl.toggleEvent, function () {\n\t        scope.$apply(function () {\n\t          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t          ngModelCtrl.$render();\n\t        });\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\t/**\n\t* @ngdoc overview\n\t* @name ui.bootstrap.carousel\n\t*\n\t* @description\n\t* AngularJS version of an image carousel.\n\t*\n\t*/\n\tangular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition'])\n\t.controller('CarouselController', ['$scope', '$timeout', '$transition', function ($scope, $timeout, $transition) {\n\t  var self = this,\n\t    slides = self.slides = $scope.slides = [],\n\t    currentIndex = -1,\n\t    currentTimeout, isPlaying;\n\t  self.currentSlide = null;\n\t\n\t  var destroyed = false;\n\t  /* direction: \"prev\" or \"next\" */\n\t  self.select = $scope.select = function(nextSlide, direction) {\n\t    var nextIndex = slides.indexOf(nextSlide);\n\t    //Decide direction if it's not given\n\t    if (direction === undefined) {\n\t      direction = nextIndex > currentIndex ? 'next' : 'prev';\n\t    }\n\t    if (nextSlide && nextSlide !== self.currentSlide) {\n\t      if ($scope.$currentTransition) {\n\t        $scope.$currentTransition.cancel();\n\t        //Timeout so ng-class in template has time to fix classes for finished slide\n\t        $timeout(goNext);\n\t      } else {\n\t        goNext();\n\t      }\n\t    }\n\t    function goNext() {\n\t      // Scope has been destroyed, stop here.\n\t      if (destroyed) { return; }\n\t      //If we have a slide to transition from and we have a transition type and we're allowed, go\n\t      if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {\n\t        //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime\n\t        nextSlide.$element.addClass(direction);\n\t        var reflow = nextSlide.$element[0].offsetWidth; //force reflow\n\t\n\t        //Set all other slides to stop doing their stuff for the new transition\n\t        angular.forEach(slides, function(slide) {\n\t          angular.extend(slide, {direction: '', entering: false, leaving: false, active: false});\n\t        });\n\t        angular.extend(nextSlide, {direction: direction, active: true, entering: true});\n\t        angular.extend(self.currentSlide||{}, {direction: direction, leaving: true});\n\t\n\t        $scope.$currentTransition = $transition(nextSlide.$element, {});\n\t        //We have to create new pointers inside a closure since next & current will change\n\t        (function(next,current) {\n\t          $scope.$currentTransition.then(\n\t            function(){ transitionDone(next, current); },\n\t            function(){ transitionDone(next, current); }\n\t          );\n\t        }(nextSlide, self.currentSlide));\n\t      } else {\n\t        transitionDone(nextSlide, self.currentSlide);\n\t      }\n\t      self.currentSlide = nextSlide;\n\t      currentIndex = nextIndex;\n\t      //every time you change slides, reset the timer\n\t      restartTimer();\n\t    }\n\t    function transitionDone(next, current) {\n\t      angular.extend(next, {direction: '', active: true, leaving: false, entering: false});\n\t      angular.extend(current||{}, {direction: '', active: false, leaving: false, entering: false});\n\t      $scope.$currentTransition = null;\n\t    }\n\t  };\n\t  $scope.$on('$destroy', function () {\n\t    destroyed = true;\n\t  });\n\t\n\t  /* Allow outside people to call indexOf on slides array */\n\t  self.indexOfSlide = function(slide) {\n\t    return slides.indexOf(slide);\n\t  };\n\t\n\t  $scope.next = function() {\n\t    var newIndex = (currentIndex + 1) % slides.length;\n\t\n\t    //Prevent this user-triggered transition from occurring if there is already one in progress\n\t    if (!$scope.$currentTransition) {\n\t      return self.select(slides[newIndex], 'next');\n\t    }\n\t  };\n\t\n\t  $scope.prev = function() {\n\t    var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;\n\t\n\t    //Prevent this user-triggered transition from occurring if there is already one in progress\n\t    if (!$scope.$currentTransition) {\n\t      return self.select(slides[newIndex], 'prev');\n\t    }\n\t  };\n\t\n\t  $scope.isActive = function(slide) {\n\t     return self.currentSlide === slide;\n\t  };\n\t\n\t  $scope.$watch('interval', restartTimer);\n\t  $scope.$on('$destroy', resetTimer);\n\t\n\t  function restartTimer() {\n\t    resetTimer();\n\t    var interval = +$scope.interval;\n\t    if (!isNaN(interval) && interval>=0) {\n\t      currentTimeout = $timeout(timerFn, interval);\n\t    }\n\t  }\n\t\n\t  function resetTimer() {\n\t    if (currentTimeout) {\n\t      $timeout.cancel(currentTimeout);\n\t      currentTimeout = null;\n\t    }\n\t  }\n\t\n\t  function timerFn() {\n\t    if (isPlaying) {\n\t      $scope.next();\n\t      restartTimer();\n\t    } else {\n\t      $scope.pause();\n\t    }\n\t  }\n\t\n\t  $scope.play = function() {\n\t    if (!isPlaying) {\n\t      isPlaying = true;\n\t      restartTimer();\n\t    }\n\t  };\n\t  $scope.pause = function() {\n\t    if (!$scope.noPause) {\n\t      isPlaying = false;\n\t      resetTimer();\n\t    }\n\t  };\n\t\n\t  self.addSlide = function(slide, element) {\n\t    slide.$element = element;\n\t    slides.push(slide);\n\t    //if this is the first slide or the slide is set to active, select it\n\t    if(slides.length === 1 || slide.active) {\n\t      self.select(slides[slides.length-1]);\n\t      if (slides.length == 1) {\n\t        $scope.play();\n\t      }\n\t    } else {\n\t      slide.active = false;\n\t    }\n\t  };\n\t\n\t  self.removeSlide = function(slide) {\n\t    //get the index of the slide inside the carousel\n\t    var index = slides.indexOf(slide);\n\t    slides.splice(index, 1);\n\t    if (slides.length > 0 && slide.active) {\n\t      if (index >= slides.length) {\n\t        self.select(slides[index-1]);\n\t      } else {\n\t        self.select(slides[index]);\n\t      }\n\t    } else if (currentIndex > index) {\n\t      currentIndex--;\n\t    }\n\t  };\n\t\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.carousel.directive:carousel\n\t * @restrict EA\n\t *\n\t * @description\n\t * Carousel is the outer container for a set of image 'slides' to showcase.\n\t *\n\t * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\n\t * @param {boolean=} noTransition Whether to disable transitions on the carousel.\n\t * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <carousel>\n\t      <slide>\n\t        <img src=\"http://placekitten.com/150/150\" style=\"margin:auto;\">\n\t        <div class=\"carousel-caption\">\n\t          <p>Beautiful!</p>\n\t        </div>\n\t      </slide>\n\t      <slide>\n\t        <img src=\"http://placekitten.com/100/150\" style=\"margin:auto;\">\n\t        <div class=\"carousel-caption\">\n\t          <p>D'aww!</p>\n\t        </div>\n\t      </slide>\n\t    </carousel>\n\t  </file>\n\t  <file name=\"demo.css\">\n\t    .carousel-indicators {\n\t      top: auto;\n\t      bottom: 15px;\n\t    }\n\t  </file>\n\t</example>\n\t */\n\t.directive('carousel', [function() {\n\t  return {\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    controller: 'CarouselController',\n\t    require: 'carousel',\n\t    templateUrl: 'template/carousel/carousel.html',\n\t    scope: {\n\t      interval: '=',\n\t      noTransition: '=',\n\t      noPause: '='\n\t    }\n\t  };\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.carousel.directive:slide\n\t * @restrict EA\n\t *\n\t * @description\n\t * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\n\t *\n\t * @param {boolean=} active Model binding, whether or not this slide is currently active.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t<div ng-controller=\"CarouselDemoCtrl\">\n\t  <carousel>\n\t    <slide ng-repeat=\"slide in slides\" active=\"slide.active\">\n\t      <img ng-src=\"{{slide.image}}\" style=\"margin:auto;\">\n\t      <div class=\"carousel-caption\">\n\t        <h4>Slide {{$index}}</h4>\n\t        <p>{{slide.text}}</p>\n\t      </div>\n\t    </slide>\n\t  </carousel>\n\t  Interval, in milliseconds: <input type=\"number\" ng-model=\"myInterval\">\n\t  <br />Enter a negative number to stop the interval.\n\t</div>\n\t  </file>\n\t  <file name=\"script.js\">\n\tfunction CarouselDemoCtrl($scope) {\n\t  $scope.myInterval = 5000;\n\t}\n\t  </file>\n\t  <file name=\"demo.css\">\n\t    .carousel-indicators {\n\t      top: auto;\n\t      bottom: 15px;\n\t    }\n\t  </file>\n\t</example>\n\t*/\n\t\n\t.directive('slide', function() {\n\t  return {\n\t    require: '^carousel',\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    templateUrl: 'template/carousel/slide.html',\n\t    scope: {\n\t      active: '=?'\n\t    },\n\t    link: function (scope, element, attrs, carouselCtrl) {\n\t      carouselCtrl.addSlide(scope, element);\n\t      //when the scope is destroyed then remove the slide from the current slides array\n\t      scope.$on('$destroy', function() {\n\t        carouselCtrl.removeSlide(scope);\n\t      });\n\t\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          carouselCtrl.select(scope);\n\t        }\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.dateparser', [])\n\t\n\t.service('dateParser', ['$locale', 'orderByFilter', function($locale, orderByFilter) {\n\t\n\t  this.parsers = {};\n\t\n\t  var formatCodeToRegex = {\n\t    'yyyy': {\n\t      regex: '\\\\d{4}',\n\t      apply: function(value) { this.year = +value; }\n\t    },\n\t    'yy': {\n\t      regex: '\\\\d{2}',\n\t      apply: function(value) { this.year = +value + 2000; }\n\t    },\n\t    'y': {\n\t      regex: '\\\\d{1,4}',\n\t      apply: function(value) { this.year = +value; }\n\t    },\n\t    'MMMM': {\n\t      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n\t      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }\n\t    },\n\t    'MMM': {\n\t      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n\t      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }\n\t    },\n\t    'MM': {\n\t      regex: '0[1-9]|1[0-2]',\n\t      apply: function(value) { this.month = value - 1; }\n\t    },\n\t    'M': {\n\t      regex: '[1-9]|1[0-2]',\n\t      apply: function(value) { this.month = value - 1; }\n\t    },\n\t    'dd': {\n\t      regex: '[0-2][0-9]{1}|3[0-1]{1}',\n\t      apply: function(value) { this.date = +value; }\n\t    },\n\t    'd': {\n\t      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n\t      apply: function(value) { this.date = +value; }\n\t    },\n\t    'EEEE': {\n\t      regex: $locale.DATETIME_FORMATS.DAY.join('|')\n\t    },\n\t    'EEE': {\n\t      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')\n\t    }\n\t  };\n\t\n\t  function createParser(format) {\n\t    var map = [], regex = format.split('');\n\t\n\t    angular.forEach(formatCodeToRegex, function(data, code) {\n\t      var index = format.indexOf(code);\n\t\n\t      if (index > -1) {\n\t        format = format.split('');\n\t\n\t        regex[index] = '(' + data.regex + ')';\n\t        format[index] = '$'; // Custom symbol to define consumed part of format\n\t        for (var i = index + 1, n = index + code.length; i < n; i++) {\n\t          regex[i] = '';\n\t          format[i] = '$';\n\t        }\n\t        format = format.join('');\n\t\n\t        map.push({ index: index, apply: data.apply });\n\t      }\n\t    });\n\t\n\t    return {\n\t      regex: new RegExp('^' + regex.join('') + '$'),\n\t      map: orderByFilter(map, 'index')\n\t    };\n\t  }\n\t\n\t  this.parse = function(input, format) {\n\t    if ( !angular.isString(input) || !format ) {\n\t      return input;\n\t    }\n\t\n\t    format = $locale.DATETIME_FORMATS[format] || format;\n\t\n\t    if ( !this.parsers[format] ) {\n\t      this.parsers[format] = createParser(format);\n\t    }\n\t\n\t    var parser = this.parsers[format],\n\t        regex = parser.regex,\n\t        map = parser.map,\n\t        results = input.match(regex);\n\t\n\t    if ( results && results.length ) {\n\t      var fields = { year: 1900, month: 0, date: 1, hours: 0 }, dt;\n\t\n\t      for( var i = 1, n = results.length; i < n; i++ ) {\n\t        var mapper = map[i-1];\n\t        if ( mapper.apply ) {\n\t          mapper.apply.call(fields, results[i]);\n\t        }\n\t      }\n\t\n\t      if ( isValid(fields.year, fields.month, fields.date) ) {\n\t        dt = new Date( fields.year, fields.month, fields.date, fields.hours);\n\t      }\n\t\n\t      return dt;\n\t    }\n\t  };\n\t\n\t  // Check if date is valid for specific month (and year for February).\n\t  // Month: 0 = Jan, 1 = Feb, etc\n\t  function isValid(year, month, date) {\n\t    if ( month === 1 && date > 28) {\n\t        return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n\t    }\n\t\n\t    if ( month === 3 || month === 5 || month === 8 || month === 10) {\n\t        return date < 31;\n\t    }\n\t\n\t    return true;\n\t  }\n\t}]);\n\t\n\tangular.module('ui.bootstrap.position', [])\n\t\n\t/**\n\t * A set of utility methods that can be use to retrieve position of DOM elements.\n\t * It is meant to be used where we need to absolute-position DOM elements in\n\t * relation to other, existing elements (this is the case for tooltips, popovers,\n\t * typeahead suggestions etc.).\n\t */\n\t  .factory('$position', ['$document', '$window', function ($document, $window) {\n\t\n\t    function getStyle(el, cssprop) {\n\t      if (el.currentStyle) { //IE\n\t        return el.currentStyle[cssprop];\n\t      } else if ($window.getComputedStyle) {\n\t        return $window.getComputedStyle(el)[cssprop];\n\t      }\n\t      // finally try and get inline style\n\t      return el.style[cssprop];\n\t    }\n\t\n\t    /**\n\t     * Checks if a given element is statically positioned\n\t     * @param element - raw DOM element\n\t     */\n\t    function isStaticPositioned(element) {\n\t      return (getStyle(element, 'position') || 'static' ) === 'static';\n\t    }\n\t\n\t    /**\n\t     * returns the closest, non-statically positioned parentOffset of a given element\n\t     * @param element\n\t     */\n\t    var parentOffsetEl = function (element) {\n\t      var docDomEl = $document[0];\n\t      var offsetParent = element.offsetParent || docDomEl;\n\t      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n\t        offsetParent = offsetParent.offsetParent;\n\t      }\n\t      return offsetParent || docDomEl;\n\t    };\n\t\n\t    return {\n\t      /**\n\t       * Provides read-only equivalent of jQuery's position function:\n\t       * http://api.jquery.com/position/\n\t       */\n\t      position: function (element) {\n\t        var elBCR = this.offset(element);\n\t        var offsetParentBCR = { top: 0, left: 0 };\n\t        var offsetParentEl = parentOffsetEl(element[0]);\n\t        if (offsetParentEl != $document[0]) {\n\t          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n\t          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n\t          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n\t        }\n\t\n\t        var boundingClientRect = element[0].getBoundingClientRect();\n\t        return {\n\t          width: boundingClientRect.width || element.prop('offsetWidth'),\n\t          height: boundingClientRect.height || element.prop('offsetHeight'),\n\t          top: elBCR.top - offsetParentBCR.top,\n\t          left: elBCR.left - offsetParentBCR.left\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides read-only equivalent of jQuery's offset function:\n\t       * http://api.jquery.com/offset/\n\t       */\n\t      offset: function (element) {\n\t        var boundingClientRect = element[0].getBoundingClientRect();\n\t        return {\n\t          width: boundingClientRect.width || element.prop('offsetWidth'),\n\t          height: boundingClientRect.height || element.prop('offsetHeight'),\n\t          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n\t          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides coordinates for the targetEl in relation to hostEl\n\t       */\n\t      positionElements: function (hostEl, targetEl, positionStr, appendToBody) {\n\t\n\t        var positionStrParts = positionStr.split('-');\n\t        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\t\n\t        var hostElPos,\n\t          targetElWidth,\n\t          targetElHeight,\n\t          targetElPos;\n\t\n\t        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\t\n\t        targetElWidth = targetEl.prop('offsetWidth');\n\t        targetElHeight = targetEl.prop('offsetHeight');\n\t\n\t        var shiftWidth = {\n\t          center: function () {\n\t            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n\t          },\n\t          left: function () {\n\t            return hostElPos.left;\n\t          },\n\t          right: function () {\n\t            return hostElPos.left + hostElPos.width;\n\t          }\n\t        };\n\t\n\t        var shiftHeight = {\n\t          center: function () {\n\t            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n\t          },\n\t          top: function () {\n\t            return hostElPos.top;\n\t          },\n\t          bottom: function () {\n\t            return hostElPos.top + hostElPos.height;\n\t          }\n\t        };\n\t\n\t        switch (pos0) {\n\t          case 'right':\n\t            targetElPos = {\n\t              top: shiftHeight[pos1](),\n\t              left: shiftWidth[pos0]()\n\t            };\n\t            break;\n\t          case 'left':\n\t            targetElPos = {\n\t              top: shiftHeight[pos1](),\n\t              left: hostElPos.left - targetElWidth\n\t            };\n\t            break;\n\t          case 'bottom':\n\t            targetElPos = {\n\t              top: shiftHeight[pos0](),\n\t              left: shiftWidth[pos1]()\n\t            };\n\t            break;\n\t          default:\n\t            targetElPos = {\n\t              top: hostElPos.top - targetElHeight,\n\t              left: shiftWidth[pos1]()\n\t            };\n\t            break;\n\t        }\n\t\n\t        return targetElPos;\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])\n\t\n\t.constant('datepickerConfig', {\n\t  formatDay: 'dd',\n\t  formatMonth: 'MMMM',\n\t  formatYear: 'yyyy',\n\t  formatDayHeader: 'EEE',\n\t  formatDayTitle: 'MMMM yyyy',\n\t  formatMonthTitle: 'yyyy',\n\t  datepickerMode: 'day',\n\t  minMode: 'day',\n\t  maxMode: 'year',\n\t  showWeeks: true,\n\t  startingDay: 0,\n\t  yearRange: 20,\n\t  minDate: null,\n\t  maxDate: null\n\t})\n\t\n\t.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$timeout', '$log', 'dateFilter', 'datepickerConfig', function($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\t\n\t  // Modes chain\n\t  this.modes = ['day', 'month', 'year'];\n\t\n\t  // Configuration attributes\n\t  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n\t                   'minMode', 'maxMode', 'showWeeks', 'startingDay', 'yearRange'], function( key, index ) {\n\t    self[key] = angular.isDefined($attrs[key]) ? (index < 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n\t  });\n\t\n\t  // Watchable date attributes\n\t  angular.forEach(['minDate', 'maxDate'], function( key ) {\n\t    if ( $attrs[key] ) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = value ? new Date(value) : null;\n\t        self.refreshView();\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n\t    }\n\t  });\n\t\n\t  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n\t  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t  this.activeDate = angular.isDefined($attrs.initDate) ? $scope.$parent.$eval($attrs.initDate) : new Date();\n\t\n\t  $scope.isActive = function(dateObject) {\n\t    if (self.compare(dateObject.date, self.activeDate) === 0) {\n\t      $scope.activeDateId = dateObject.uid;\n\t      return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  this.init = function( ngModelCtrl_ ) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t  };\n\t\n\t  this.render = function() {\n\t    if ( ngModelCtrl.$modelValue ) {\n\t      var date = new Date( ngModelCtrl.$modelValue ),\n\t          isValid = !isNaN(date);\n\t\n\t      if ( isValid ) {\n\t        this.activeDate = date;\n\t      } else {\n\t        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t      }\n\t      ngModelCtrl.$setValidity('date', isValid);\n\t    }\n\t    this.refreshView();\n\t  };\n\t\n\t  this.refreshView = function() {\n\t    if ( this.element ) {\n\t      this._refreshView();\n\t\n\t      var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;\n\t      ngModelCtrl.$setValidity('date-disabled', !date || (this.element && !this.isDisabled(date)));\n\t    }\n\t  };\n\t\n\t  this.createDateObject = function(date, format) {\n\t    var model = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;\n\t    return {\n\t      date: date,\n\t      label: dateFilter(date, format),\n\t      selected: model && this.compare(date, model) === 0,\n\t      disabled: this.isDisabled(date),\n\t      current: this.compare(date, new Date()) === 0\n\t    };\n\t  };\n\t\n\t  this.isDisabled = function( date ) {\n\t    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n\t  };\n\t\n\t  // Split array into smaller arrays\n\t  this.split = function(arr, size) {\n\t    var arrays = [];\n\t    while (arr.length > 0) {\n\t      arrays.push(arr.splice(0, size));\n\t    }\n\t    return arrays;\n\t  };\n\t\n\t  $scope.select = function( date ) {\n\t    if ( $scope.datepickerMode === self.minMode ) {\n\t      var dt = ngModelCtrl.$modelValue ? new Date( ngModelCtrl.$modelValue ) : new Date(0, 0, 0, 0, 0, 0, 0);\n\t      dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );\n\t      ngModelCtrl.$setViewValue( dt );\n\t      ngModelCtrl.$render();\n\t    } else {\n\t      self.activeDate = date;\n\t      $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) - 1 ];\n\t    }\n\t  };\n\t\n\t  $scope.move = function( direction ) {\n\t    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n\t        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n\t    self.activeDate.setFullYear(year, month, 1);\n\t    self.refreshView();\n\t  };\n\t\n\t  $scope.toggleMode = function( direction ) {\n\t    direction = direction || 1;\n\t\n\t    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n\t      return;\n\t    }\n\t\n\t    $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) + direction ];\n\t  };\n\t\n\t  // Key event mapper\n\t  $scope.keys = { 13:'enter', 32:'space', 33:'pageup', 34:'pagedown', 35:'end', 36:'home', 37:'left', 38:'up', 39:'right', 40:'down' };\n\t\n\t  var focusElement = function() {\n\t    $timeout(function() {\n\t      self.element[0].focus();\n\t    }, 0 , false);\n\t  };\n\t\n\t  // Listen for focus requests from popup directive\n\t  $scope.$on('datepicker.focus', focusElement);\n\t\n\t  $scope.keydown = function( evt ) {\n\t    var key = $scope.keys[evt.which];\n\t\n\t    if ( !key || evt.shiftKey || evt.altKey ) {\n\t      return;\n\t    }\n\t\n\t    evt.preventDefault();\n\t    evt.stopPropagation();\n\t\n\t    if (key === 'enter' || key === 'space') {\n\t      if ( self.isDisabled(self.activeDate)) {\n\t        return; // do nothing\n\t      }\n\t      $scope.select(self.activeDate);\n\t      focusElement();\n\t    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n\t      $scope.toggleMode(key === 'up' ? 1 : -1);\n\t      focusElement();\n\t    } else {\n\t      self.handleKeyDown(key, evt);\n\t      self.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive( 'datepicker', function () {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/datepicker.html',\n\t    scope: {\n\t      datepickerMode: '=?',\n\t      dateDisabled: '&'\n\t    },\n\t    require: ['datepicker', '?^ngModel'],\n\t    controller: 'DatepickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if ( ngModelCtrl ) {\n\t        datepickerCtrl.init( ngModelCtrl );\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('daypicker', ['dateFilter', function (dateFilter) {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/day.html',\n\t    require: '^datepicker',\n\t    link: function(scope, element, attrs, ctrl) {\n\t      scope.showWeeks = ctrl.showWeeks;\n\t\n\t      ctrl.step = { months: 1 };\n\t      ctrl.element = element;\n\t\n\t      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\t      function getDaysInMonth( year, month ) {\n\t        return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];\n\t      }\n\t\n\t      function getDates(startDate, n) {\n\t        var dates = new Array(n), current = new Date(startDate), i = 0;\n\t        current.setHours(12); // Prevent repeated dates because of timezone bug\n\t        while ( i < n ) {\n\t          dates[i++] = new Date(current);\n\t          current.setDate( current.getDate() + 1 );\n\t        }\n\t        return dates;\n\t      }\n\t\n\t      ctrl._refreshView = function() {\n\t        var year = ctrl.activeDate.getFullYear(),\n\t          month = ctrl.activeDate.getMonth(),\n\t          firstDayOfMonth = new Date(year, month, 1),\n\t          difference = ctrl.startingDay - firstDayOfMonth.getDay(),\n\t          numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n\t          firstDate = new Date(firstDayOfMonth);\n\t\n\t        if ( numDisplayedFromPreviousMonth > 0 ) {\n\t          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );\n\t        }\n\t\n\t        // 42 is the number of days on a six-month calendar\n\t        var days = getDates(firstDate, 42);\n\t        for (var i = 0; i < 42; i ++) {\n\t          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {\n\t            secondary: days[i].getMonth() !== month,\n\t            uid: scope.uniqueId + '-' + i\n\t          });\n\t        }\n\t\n\t        scope.labels = new Array(7);\n\t        for (var j = 0; j < 7; j++) {\n\t          scope.labels[j] = {\n\t            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),\n\t            full: dateFilter(days[j].date, 'EEEE')\n\t          };\n\t        }\n\t\n\t        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);\n\t        scope.rows = ctrl.split(days, 7);\n\t\n\t        if ( scope.showWeeks ) {\n\t          scope.weekNumbers = [];\n\t          var weekNumber = getISO8601WeekNumber( scope.rows[0][0].date ),\n\t              numWeeks = scope.rows.length;\n\t          while( scope.weekNumbers.push(weekNumber++) < numWeeks ) {}\n\t        }\n\t      };\n\t\n\t      ctrl.compare = function(date1, date2) {\n\t        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );\n\t      };\n\t\n\t      function getISO8601WeekNumber(date) {\n\t        var checkDate = new Date(date);\n\t        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n\t        var time = checkDate.getTime();\n\t        checkDate.setMonth(0); // Compare with Jan 1\n\t        checkDate.setDate(1);\n\t        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n\t      }\n\t\n\t      ctrl.handleKeyDown = function( key, evt ) {\n\t        var date = ctrl.activeDate.getDate();\n\t\n\t        if (key === 'left') {\n\t          date = date - 1;   // up\n\t        } else if (key === 'up') {\n\t          date = date - 7;   // down\n\t        } else if (key === 'right') {\n\t          date = date + 1;   // down\n\t        } else if (key === 'down') {\n\t          date = date + 7;\n\t        } else if (key === 'pageup' || key === 'pagedown') {\n\t          var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n\t          ctrl.activeDate.setMonth(month, 1);\n\t          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);\n\t        } else if (key === 'home') {\n\t          date = 1;\n\t        } else if (key === 'end') {\n\t          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());\n\t        }\n\t        ctrl.activeDate.setDate(date);\n\t      };\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('monthpicker', ['dateFilter', function (dateFilter) {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/month.html',\n\t    require: '^datepicker',\n\t    link: function(scope, element, attrs, ctrl) {\n\t      ctrl.step = { years: 1 };\n\t      ctrl.element = element;\n\t\n\t      ctrl._refreshView = function() {\n\t        var months = new Array(12),\n\t            year = ctrl.activeDate.getFullYear();\n\t\n\t        for ( var i = 0; i < 12; i++ ) {\n\t          months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {\n\t            uid: scope.uniqueId + '-' + i\n\t          });\n\t        }\n\t\n\t        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);\n\t        scope.rows = ctrl.split(months, 3);\n\t      };\n\t\n\t      ctrl.compare = function(date1, date2) {\n\t        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );\n\t      };\n\t\n\t      ctrl.handleKeyDown = function( key, evt ) {\n\t        var date = ctrl.activeDate.getMonth();\n\t\n\t        if (key === 'left') {\n\t          date = date - 1;   // up\n\t        } else if (key === 'up') {\n\t          date = date - 3;   // down\n\t        } else if (key === 'right') {\n\t          date = date + 1;   // down\n\t        } else if (key === 'down') {\n\t          date = date + 3;\n\t        } else if (key === 'pageup' || key === 'pagedown') {\n\t          var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n\t          ctrl.activeDate.setFullYear(year);\n\t        } else if (key === 'home') {\n\t          date = 0;\n\t        } else if (key === 'end') {\n\t          date = 11;\n\t        }\n\t        ctrl.activeDate.setMonth(date);\n\t      };\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('yearpicker', ['dateFilter', function (dateFilter) {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/year.html',\n\t    require: '^datepicker',\n\t    link: function(scope, element, attrs, ctrl) {\n\t      var range = ctrl.yearRange;\n\t\n\t      ctrl.step = { years: range };\n\t      ctrl.element = element;\n\t\n\t      function getStartingYear( year ) {\n\t        return parseInt((year - 1) / range, 10) * range + 1;\n\t      }\n\t\n\t      ctrl._refreshView = function() {\n\t        var years = new Array(range);\n\t\n\t        for ( var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++ ) {\n\t          years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {\n\t            uid: scope.uniqueId + '-' + i\n\t          });\n\t        }\n\t\n\t        scope.title = [years[0].label, years[range - 1].label].join(' - ');\n\t        scope.rows = ctrl.split(years, 5);\n\t      };\n\t\n\t      ctrl.compare = function(date1, date2) {\n\t        return date1.getFullYear() - date2.getFullYear();\n\t      };\n\t\n\t      ctrl.handleKeyDown = function( key, evt ) {\n\t        var date = ctrl.activeDate.getFullYear();\n\t\n\t        if (key === 'left') {\n\t          date = date - 1;   // up\n\t        } else if (key === 'up') {\n\t          date = date - 5;   // down\n\t        } else if (key === 'right') {\n\t          date = date + 1;   // down\n\t        } else if (key === 'down') {\n\t          date = date + 5;\n\t        } else if (key === 'pageup' || key === 'pagedown') {\n\t          date += (key === 'pageup' ? - 1 : 1) * ctrl.step.years;\n\t        } else if (key === 'home') {\n\t          date = getStartingYear( ctrl.activeDate.getFullYear() );\n\t        } else if (key === 'end') {\n\t          date = getStartingYear( ctrl.activeDate.getFullYear() ) + range - 1;\n\t        }\n\t        ctrl.activeDate.setFullYear(date);\n\t      };\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.constant('datepickerPopupConfig', {\n\t  datepickerPopup: 'yyyy-MM-dd',\n\t  currentText: 'Today',\n\t  clearText: 'Clear',\n\t  closeText: 'Done',\n\t  closeOnDateSelection: true,\n\t  appendToBody: false,\n\t  showButtonBar: true\n\t})\n\t\n\t.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig',\n\tfunction ($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    require: 'ngModel',\n\t    scope: {\n\t      isOpen: '=?',\n\t      currentText: '@',\n\t      clearText: '@',\n\t      closeText: '@',\n\t      dateDisabled: '&'\n\t    },\n\t    link: function(scope, element, attrs, ngModel) {\n\t      var dateFormat,\n\t          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,\n\t          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n\t\n\t      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\t\n\t      scope.getText = function( key ) {\n\t        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n\t      };\n\t\n\t      attrs.$observe('datepickerPopup', function(value) {\n\t          dateFormat = value || datepickerPopupConfig.datepickerPopup;\n\t          ngModel.$render();\n\t      });\n\t\n\t      // popup element used to display calendar\n\t      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');\n\t      popupEl.attr({\n\t        'ng-model': 'date',\n\t        'ng-change': 'dateSelection()'\n\t      });\n\t\n\t      function cameltoDash( string ){\n\t        return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n\t      }\n\t\n\t      // datepicker element\n\t      var datepickerEl = angular.element(popupEl.children()[0]);\n\t      if ( attrs.datepickerOptions ) {\n\t        angular.forEach(scope.$parent.$eval(attrs.datepickerOptions), function( value, option ) {\n\t          datepickerEl.attr( cameltoDash(option), value );\n\t        });\n\t      }\n\t\n\t      scope.watchData = {};\n\t      angular.forEach(['minDate', 'maxDate', 'datepickerMode'], function( key ) {\n\t        if ( attrs[key] ) {\n\t          var getAttribute = $parse(attrs[key]);\n\t          scope.$parent.$watch(getAttribute, function(value){\n\t            scope.watchData[key] = value;\n\t          });\n\t          datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\t\n\t          // Propagate changes from datepicker to outside\n\t          if ( key === 'datepickerMode' ) {\n\t            var setAttribute = getAttribute.assign;\n\t            scope.$watch('watchData.' + key, function(value, oldvalue) {\n\t              if ( value !== oldvalue ) {\n\t                setAttribute(scope.$parent, value);\n\t              }\n\t            });\n\t          }\n\t        }\n\t      });\n\t      if (attrs.dateDisabled) {\n\t        datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n\t      }\n\t\n\t      function parseDate(viewValue) {\n\t        if (!viewValue) {\n\t          ngModel.$setValidity('date', true);\n\t          return null;\n\t        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n\t          ngModel.$setValidity('date', true);\n\t          return viewValue;\n\t        } else if (angular.isString(viewValue)) {\n\t          var date = dateParser.parse(viewValue, dateFormat) || new Date(viewValue);\n\t          if (isNaN(date)) {\n\t            ngModel.$setValidity('date', false);\n\t            return undefined;\n\t          } else {\n\t            ngModel.$setValidity('date', true);\n\t            return date;\n\t          }\n\t        } else {\n\t          ngModel.$setValidity('date', false);\n\t          return undefined;\n\t        }\n\t      }\n\t      ngModel.$parsers.unshift(parseDate);\n\t\n\t      // Inner change\n\t      scope.dateSelection = function(dt) {\n\t        if (angular.isDefined(dt)) {\n\t          scope.date = dt;\n\t        }\n\t        ngModel.$setViewValue(scope.date);\n\t        ngModel.$render();\n\t\n\t        if ( closeOnDateSelection ) {\n\t          scope.isOpen = false;\n\t          element[0].focus();\n\t        }\n\t      };\n\t\n\t      element.bind('input change keyup', function() {\n\t        scope.$apply(function() {\n\t          scope.date = ngModel.$modelValue;\n\t        });\n\t      });\n\t\n\t      // Outter change\n\t      ngModel.$render = function() {\n\t        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';\n\t        element.val(date);\n\t        scope.date = parseDate( ngModel.$modelValue );\n\t      };\n\t\n\t      var documentClickBind = function(event) {\n\t        if (scope.isOpen && event.target !== element[0]) {\n\t          scope.$apply(function() {\n\t            scope.isOpen = false;\n\t          });\n\t        }\n\t      };\n\t\n\t      var keydown = function(evt, noApply) {\n\t        scope.keydown(evt);\n\t      };\n\t      element.bind('keydown', keydown);\n\t\n\t      scope.keydown = function(evt) {\n\t        if (evt.which === 27) {\n\t          evt.preventDefault();\n\t          evt.stopPropagation();\n\t          scope.close();\n\t        } else if (evt.which === 40 && !scope.isOpen) {\n\t          scope.isOpen = true;\n\t        }\n\t      };\n\t\n\t      scope.$watch('isOpen', function(value) {\n\t        if (value) {\n\t          scope.$broadcast('datepicker.focus');\n\t          scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t          scope.position.top = scope.position.top + element.prop('offsetHeight');\n\t\n\t          $document.bind('click', documentClickBind);\n\t        } else {\n\t          $document.unbind('click', documentClickBind);\n\t        }\n\t      });\n\t\n\t      scope.select = function( date ) {\n\t        if (date === 'today') {\n\t          var today = new Date();\n\t          if (angular.isDate(ngModel.$modelValue)) {\n\t            date = new Date(ngModel.$modelValue);\n\t            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n\t          } else {\n\t            date = new Date(today.setHours(0, 0, 0, 0));\n\t          }\n\t        }\n\t        scope.dateSelection( date );\n\t      };\n\t\n\t      scope.close = function() {\n\t        scope.isOpen = false;\n\t        element[0].focus();\n\t      };\n\t\n\t      var $popup = $compile(popupEl)(scope);\n\t      // Prevent jQuery cache memory leak (template is now redundant after linking)\n\t      popupEl.remove();\n\t\n\t      if ( appendToBody ) {\n\t        $document.find('body').append($popup);\n\t      } else {\n\t        element.after($popup);\n\t      }\n\t\n\t      scope.$on('$destroy', function() {\n\t        $popup.remove();\n\t        element.unbind('keydown', keydown);\n\t        $document.unbind('click', documentClickBind);\n\t      });\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('datepickerPopupWrap', function() {\n\t  return {\n\t    restrict:'EA',\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: 'template/datepicker/popup.html',\n\t    link:function (scope, element, attrs) {\n\t      element.bind('click', function(event) {\n\t        event.preventDefault();\n\t        event.stopPropagation();\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.dropdown', [])\n\t\n\t.constant('dropdownConfig', {\n\t  openClass: 'open'\n\t})\n\t\n\t.service('dropdownService', ['$document', function($document) {\n\t  var openScope = null;\n\t\n\t  this.open = function( dropdownScope ) {\n\t    if ( !openScope ) {\n\t      $document.bind('click', closeDropdown);\n\t      $document.bind('keydown', escapeKeyBind);\n\t    }\n\t\n\t    if ( openScope && openScope !== dropdownScope ) {\n\t        openScope.isOpen = false;\n\t    }\n\t\n\t    openScope = dropdownScope;\n\t  };\n\t\n\t  this.close = function( dropdownScope ) {\n\t    if ( openScope === dropdownScope ) {\n\t      openScope = null;\n\t      $document.unbind('click', closeDropdown);\n\t      $document.unbind('keydown', escapeKeyBind);\n\t    }\n\t  };\n\t\n\t  var closeDropdown = function( evt ) {\n\t    var toggleElement = openScope.getToggleElement();\n\t    if ( evt && toggleElement && toggleElement[0].contains(evt.target) ) {\n\t        return;\n\t    }\n\t\n\t    openScope.$apply(function() {\n\t      openScope.isOpen = false;\n\t    });\n\t  };\n\t\n\t  var escapeKeyBind = function( evt ) {\n\t    if ( evt.which === 27 ) {\n\t      openScope.focusToggleElement();\n\t      closeDropdown();\n\t    }\n\t  };\n\t}])\n\t\n\t.controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {\n\t  var self = this,\n\t      scope = $scope.$new(), // create a child scope so we are not polluting original one\n\t      openClass = dropdownConfig.openClass,\n\t      getIsOpen,\n\t      setIsOpen = angular.noop,\n\t      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop;\n\t\n\t  this.init = function( element ) {\n\t    self.$element = element;\n\t\n\t    if ( $attrs.isOpen ) {\n\t      getIsOpen = $parse($attrs.isOpen);\n\t      setIsOpen = getIsOpen.assign;\n\t\n\t      $scope.$watch(getIsOpen, function(value) {\n\t        scope.isOpen = !!value;\n\t      });\n\t    }\n\t  };\n\t\n\t  this.toggle = function( open ) {\n\t    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n\t  };\n\t\n\t  // Allow other directives to watch status\n\t  this.isOpen = function() {\n\t    return scope.isOpen;\n\t  };\n\t\n\t  scope.getToggleElement = function() {\n\t    return self.toggleElement;\n\t  };\n\t\n\t  scope.focusToggleElement = function() {\n\t    if ( self.toggleElement ) {\n\t      self.toggleElement[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.$watch('isOpen', function( isOpen, wasOpen ) {\n\t    $animate[isOpen ? 'addClass' : 'removeClass'](self.$element, openClass);\n\t\n\t    if ( isOpen ) {\n\t      scope.focusToggleElement();\n\t      dropdownService.open( scope );\n\t    } else {\n\t      dropdownService.close( scope );\n\t    }\n\t\n\t    setIsOpen($scope, isOpen);\n\t    if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n\t      toggleInvoker($scope, { open: !!isOpen });\n\t    }\n\t  });\n\t\n\t  $scope.$on('$locationChangeSuccess', function() {\n\t    scope.isOpen = false;\n\t  });\n\t\n\t  $scope.$on('$destroy', function() {\n\t    scope.$destroy();\n\t  });\n\t}])\n\t\n\t.directive('dropdown', function() {\n\t  return {\n\t    restrict: 'CA',\n\t    controller: 'DropdownController',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      dropdownCtrl.init( element );\n\t    }\n\t  };\n\t})\n\t\n\t.directive('dropdownToggle', function() {\n\t  return {\n\t    restrict: 'CA',\n\t    require: '?^dropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if ( !dropdownCtrl ) {\n\t        return;\n\t      }\n\t\n\t      dropdownCtrl.toggleElement = element;\n\t\n\t      var toggleDropdown = function(event) {\n\t        event.preventDefault();\n\t\n\t        if ( !element.hasClass('disabled') && !attrs.disabled ) {\n\t          scope.$apply(function() {\n\t            dropdownCtrl.toggle();\n\t          });\n\t        }\n\t      };\n\t\n\t      element.bind('click', toggleDropdown);\n\t\n\t      // WAI-ARIA\n\t      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n\t      scope.$watch(dropdownCtrl.isOpen, function( isOpen ) {\n\t        element.attr('aria-expanded', !!isOpen);\n\t      });\n\t\n\t      scope.$on('$destroy', function() {\n\t        element.unbind('click', toggleDropdown);\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.modal', ['ui.bootstrap.transition'])\n\t\n\t/**\n\t * A helper, internal data structure that acts as a map but also allows getting / removing\n\t * elements in the LIFO order\n\t */\n\t  .factory('$$stackedMap', function () {\n\t    return {\n\t      createNew: function () {\n\t        var stack = [];\n\t\n\t        return {\n\t          add: function (key, value) {\n\t            stack.push({\n\t              key: key,\n\t              value: value\n\t            });\n\t          },\n\t          get: function (key) {\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key == stack[i].key) {\n\t                return stack[i];\n\t              }\n\t            }\n\t          },\n\t          keys: function() {\n\t            var keys = [];\n\t            for (var i = 0; i < stack.length; i++) {\n\t              keys.push(stack[i].key);\n\t            }\n\t            return keys;\n\t          },\n\t          top: function () {\n\t            return stack[stack.length - 1];\n\t          },\n\t          remove: function (key) {\n\t            var idx = -1;\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key == stack[i].key) {\n\t                idx = i;\n\t                break;\n\t              }\n\t            }\n\t            return stack.splice(idx, 1)[0];\n\t          },\n\t          removeTop: function () {\n\t            return stack.splice(stack.length - 1, 1)[0];\n\t          },\n\t          length: function () {\n\t            return stack.length;\n\t          }\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t/**\n\t * A helper directive for the $modal service. It creates a backdrop element.\n\t */\n\t  .directive('modalBackdrop', ['$timeout', function ($timeout) {\n\t    return {\n\t      restrict: 'EA',\n\t      replace: true,\n\t      templateUrl: 'template/modal/backdrop.html',\n\t      link: function (scope, element, attrs) {\n\t        scope.backdropClass = attrs.backdropClass || '';\n\t\n\t        scope.animate = false;\n\t\n\t        //trigger CSS transitions\n\t        $timeout(function () {\n\t          scope.animate = true;\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('modalWindow', ['$modalStack', '$timeout', function ($modalStack, $timeout) {\n\t    return {\n\t      restrict: 'EA',\n\t      scope: {\n\t        index: '@',\n\t        animate: '='\n\t      },\n\t      replace: true,\n\t      transclude: true,\n\t      templateUrl: function(tElement, tAttrs) {\n\t        return tAttrs.templateUrl || 'template/modal/window.html';\n\t      },\n\t      link: function (scope, element, attrs) {\n\t        element.addClass(attrs.windowClass || '');\n\t        scope.size = attrs.size;\n\t\n\t        $timeout(function () {\n\t          // trigger CSS transitions\n\t          scope.animate = true;\n\t\n\t          /**\n\t           * Auto-focusing of a freshly-opened modal element causes any child elements\n\t           * with the autofocus attribute to loose focus. This is an issue on touch\n\t           * based devices which will show and then hide the onscreen keyboard.\n\t           * Attempts to refocus the autofocus element via JavaScript will not reopen\n\t           * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n\t           * the modal element if the modal does not contain an autofocus element.\n\t           */\n\t          if (!element[0].querySelectorAll('[autofocus]').length) {\n\t            element[0].focus();\n\t          }\n\t        });\n\t\n\t        scope.close = function (evt) {\n\t          var modal = $modalStack.getTop();\n\t          if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && (evt.target === evt.currentTarget)) {\n\t            evt.preventDefault();\n\t            evt.stopPropagation();\n\t            $modalStack.dismiss(modal.key, 'backdrop click');\n\t          }\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('modalTransclude', function () {\n\t    return {\n\t      link: function($scope, $element, $attrs, controller, $transclude) {\n\t        $transclude($scope.$parent, function(clone) {\n\t          $element.empty();\n\t          $element.append(clone);\n\t        });\n\t      }\n\t    };\n\t  })\n\t\n\t  .factory('$modalStack', ['$transition', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap',\n\t    function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {\n\t\n\t      var OPENED_MODAL_CLASS = 'modal-open';\n\t\n\t      var backdropDomEl, backdropScope;\n\t      var openedWindows = $$stackedMap.createNew();\n\t      var $modalStack = {};\n\t\n\t      function backdropIndex() {\n\t        var topBackdropIndex = -1;\n\t        var opened = openedWindows.keys();\n\t        for (var i = 0; i < opened.length; i++) {\n\t          if (openedWindows.get(opened[i]).value.backdrop) {\n\t            topBackdropIndex = i;\n\t          }\n\t        }\n\t        return topBackdropIndex;\n\t      }\n\t\n\t      $rootScope.$watch(backdropIndex, function(newBackdropIndex){\n\t        if (backdropScope) {\n\t          backdropScope.index = newBackdropIndex;\n\t        }\n\t      });\n\t\n\t      function removeModalWindow(modalInstance) {\n\t\n\t        var body = $document.find('body').eq(0);\n\t        var modalWindow = openedWindows.get(modalInstance).value;\n\t\n\t        //clean up the stack\n\t        openedWindows.remove(modalInstance);\n\t\n\t        //remove window DOM element\n\t        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {\n\t          modalWindow.modalScope.$destroy();\n\t          body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);\n\t          checkRemoveBackdrop();\n\t        });\n\t      }\n\t\n\t      function checkRemoveBackdrop() {\n\t          //remove backdrop if no longer needed\n\t          if (backdropDomEl && backdropIndex() == -1) {\n\t            var backdropScopeRef = backdropScope;\n\t            removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {\n\t              backdropScopeRef.$destroy();\n\t              backdropScopeRef = null;\n\t            });\n\t            backdropDomEl = undefined;\n\t            backdropScope = undefined;\n\t          }\n\t      }\n\t\n\t      function removeAfterAnimate(domEl, scope, emulateTime, done) {\n\t        // Closing animation\n\t        scope.animate = false;\n\t\n\t        var transitionEndEventName = $transition.transitionEndEventName;\n\t        if (transitionEndEventName) {\n\t          // transition out\n\t          var timeout = $timeout(afterAnimating, emulateTime);\n\t\n\t          domEl.bind(transitionEndEventName, function () {\n\t            $timeout.cancel(timeout);\n\t            afterAnimating();\n\t            scope.$apply();\n\t          });\n\t        } else {\n\t          // Ensure this call is async\n\t          $timeout(afterAnimating);\n\t        }\n\t\n\t        function afterAnimating() {\n\t          if (afterAnimating.done) {\n\t            return;\n\t          }\n\t          afterAnimating.done = true;\n\t\n\t          domEl.remove();\n\t          if (done) {\n\t            done();\n\t          }\n\t        }\n\t      }\n\t\n\t      $document.bind('keydown', function (evt) {\n\t        var modal;\n\t\n\t        if (evt.which === 27) {\n\t          modal = openedWindows.top();\n\t          if (modal && modal.value.keyboard) {\n\t            evt.preventDefault();\n\t            $rootScope.$apply(function () {\n\t              $modalStack.dismiss(modal.key, 'escape key press');\n\t            });\n\t          }\n\t        }\n\t      });\n\t\n\t      $modalStack.open = function (modalInstance, modal) {\n\t\n\t        openedWindows.add(modalInstance, {\n\t          deferred: modal.deferred,\n\t          modalScope: modal.scope,\n\t          backdrop: modal.backdrop,\n\t          keyboard: modal.keyboard\n\t        });\n\t\n\t        var body = $document.find('body').eq(0),\n\t            currBackdropIndex = backdropIndex();\n\t\n\t        if (currBackdropIndex >= 0 && !backdropDomEl) {\n\t          backdropScope = $rootScope.$new(true);\n\t          backdropScope.index = currBackdropIndex;\n\t          var angularBackgroundDomEl = angular.element('<div modal-backdrop></div>');\n\t          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);\n\t          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n\t          body.append(backdropDomEl);\n\t        }\n\t\n\t        var angularDomEl = angular.element('<div modal-window></div>');\n\t        angularDomEl.attr({\n\t          'template-url': modal.windowTemplateUrl,\n\t          'window-class': modal.windowClass,\n\t          'size': modal.size,\n\t          'index': openedWindows.length() - 1,\n\t          'animate': 'animate'\n\t        }).html(modal.content);\n\t\n\t        var modalDomEl = $compile(angularDomEl)(modal.scope);\n\t        openedWindows.top().value.modalDomEl = modalDomEl;\n\t        body.append(modalDomEl);\n\t        body.addClass(OPENED_MODAL_CLASS);\n\t      };\n\t\n\t      $modalStack.close = function (modalInstance, result) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow) {\n\t          modalWindow.value.deferred.resolve(result);\n\t          removeModalWindow(modalInstance);\n\t        }\n\t      };\n\t\n\t      $modalStack.dismiss = function (modalInstance, reason) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow) {\n\t          modalWindow.value.deferred.reject(reason);\n\t          removeModalWindow(modalInstance);\n\t        }\n\t      };\n\t\n\t      $modalStack.dismissAll = function (reason) {\n\t        var topModal = this.getTop();\n\t        while (topModal) {\n\t          this.dismiss(topModal.key, reason);\n\t          topModal = this.getTop();\n\t        }\n\t      };\n\t\n\t      $modalStack.getTop = function () {\n\t        return openedWindows.top();\n\t      };\n\t\n\t      return $modalStack;\n\t    }])\n\t\n\t  .provider('$modal', function () {\n\t\n\t    var $modalProvider = {\n\t      options: {\n\t        backdrop: true, //can be also false or 'static'\n\t        keyboard: true\n\t      },\n\t      $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack',\n\t        function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {\n\t\n\t          var $modal = {};\n\t\n\t          function getTemplatePromise(options) {\n\t            return options.template ? $q.when(options.template) :\n\t              $http.get(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl,\n\t                {cache: $templateCache}).then(function (result) {\n\t                  return result.data;\n\t              });\n\t          }\n\t\n\t          function getResolvePromises(resolves) {\n\t            var promisesArr = [];\n\t            angular.forEach(resolves, function (value) {\n\t              if (angular.isFunction(value) || angular.isArray(value)) {\n\t                promisesArr.push($q.when($injector.invoke(value)));\n\t              }\n\t            });\n\t            return promisesArr;\n\t          }\n\t\n\t          $modal.open = function (modalOptions) {\n\t\n\t            var modalResultDeferred = $q.defer();\n\t            var modalOpenedDeferred = $q.defer();\n\t\n\t            //prepare an instance of a modal to be injected into controllers and returned to a caller\n\t            var modalInstance = {\n\t              result: modalResultDeferred.promise,\n\t              opened: modalOpenedDeferred.promise,\n\t              close: function (result) {\n\t                $modalStack.close(modalInstance, result);\n\t              },\n\t              dismiss: function (reason) {\n\t                $modalStack.dismiss(modalInstance, reason);\n\t              }\n\t            };\n\t\n\t            //merge and clean up options\n\t            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n\t            modalOptions.resolve = modalOptions.resolve || {};\n\t\n\t            //verify options\n\t            if (!modalOptions.template && !modalOptions.templateUrl) {\n\t              throw new Error('One of template or templateUrl options is required.');\n\t            }\n\t\n\t            var templateAndResolvePromise =\n\t              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\t\n\t\n\t            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {\n\t\n\t              var modalScope = (modalOptions.scope || $rootScope).$new();\n\t              modalScope.$close = modalInstance.close;\n\t              modalScope.$dismiss = modalInstance.dismiss;\n\t\n\t              var ctrlInstance, ctrlLocals = {};\n\t              var resolveIter = 1;\n\t\n\t              //controllers\n\t              if (modalOptions.controller) {\n\t                ctrlLocals.$scope = modalScope;\n\t                ctrlLocals.$modalInstance = modalInstance;\n\t                angular.forEach(modalOptions.resolve, function (value, key) {\n\t                  ctrlLocals[key] = tplAndVars[resolveIter++];\n\t                });\n\t\n\t                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n\t                if (modalOptions.controllerAs) {\n\t                  modalScope[modalOptions.controllerAs] = ctrlInstance;\n\t                }\n\t              }\n\t\n\t              $modalStack.open(modalInstance, {\n\t                scope: modalScope,\n\t                deferred: modalResultDeferred,\n\t                content: tplAndVars[0],\n\t                backdrop: modalOptions.backdrop,\n\t                keyboard: modalOptions.keyboard,\n\t                backdropClass: modalOptions.backdropClass,\n\t                windowClass: modalOptions.windowClass,\n\t                windowTemplateUrl: modalOptions.windowTemplateUrl,\n\t                size: modalOptions.size\n\t              });\n\t\n\t            }, function resolveError(reason) {\n\t              modalResultDeferred.reject(reason);\n\t            });\n\t\n\t            templateAndResolvePromise.then(function () {\n\t              modalOpenedDeferred.resolve(true);\n\t            }, function () {\n\t              modalOpenedDeferred.reject(false);\n\t            });\n\t\n\t            return modalInstance;\n\t          };\n\t\n\t          return $modal;\n\t        }]\n\t    };\n\t\n\t    return $modalProvider;\n\t  });\n\t\n\tangular.module('ui.bootstrap.pagination', [])\n\t\n\t.controller('PaginationController', ['$scope', '$attrs', '$parse', function ($scope, $attrs, $parse) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\t\n\t  this.init = function(ngModelCtrl_, config) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    this.config = config;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t\n\t    if ($attrs.itemsPerPage) {\n\t      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n\t        self.itemsPerPage = parseInt(value, 10);\n\t        $scope.totalPages = self.calculateTotalPages();\n\t      });\n\t    } else {\n\t      this.itemsPerPage = config.itemsPerPage;\n\t    }\n\t  };\n\t\n\t  this.calculateTotalPages = function() {\n\t    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n\t    return Math.max(totalPages || 0, 1);\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n\t  };\n\t\n\t  $scope.selectPage = function(page) {\n\t    if ( $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n\t      ngModelCtrl.$setViewValue(page);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.getText = function( key ) {\n\t    return $scope[key + 'Text'] || self.config[key + 'Text'];\n\t  };\n\t  $scope.noPrevious = function() {\n\t    return $scope.page === 1;\n\t  };\n\t  $scope.noNext = function() {\n\t    return $scope.page === $scope.totalPages;\n\t  };\n\t\n\t  $scope.$watch('totalItems', function() {\n\t    $scope.totalPages = self.calculateTotalPages();\n\t  });\n\t\n\t  $scope.$watch('totalPages', function(value) {\n\t    setNumPages($scope.$parent, value); // Readonly variable\n\t\n\t    if ( $scope.page > value ) {\n\t      $scope.selectPage(value);\n\t    } else {\n\t      ngModelCtrl.$render();\n\t    }\n\t  });\n\t}])\n\t\n\t.constant('paginationConfig', {\n\t  itemsPerPage: 10,\n\t  boundaryLinks: false,\n\t  directionLinks: true,\n\t  firstText: 'First',\n\t  previousText: 'Previous',\n\t  nextText: 'Next',\n\t  lastText: 'Last',\n\t  rotate: true\n\t})\n\t\n\t.directive('pagination', ['$parse', 'paginationConfig', function($parse, paginationConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      firstText: '@',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      lastText: '@'\n\t    },\n\t    require: ['pagination', '?ngModel'],\n\t    controller: 'PaginationController',\n\t    templateUrl: 'template/pagination/pagination.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      // Setup configuration parameters\n\t      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n\t          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n\t      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n\t      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\t\n\t      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\t\n\t      if (attrs.maxSize) {\n\t        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n\t          maxSize = parseInt(value, 10);\n\t          paginationCtrl.render();\n\t        });\n\t      }\n\t\n\t      // Create page object used in template\n\t      function makePage(number, text, isActive) {\n\t        return {\n\t          number: number,\n\t          text: text,\n\t          active: isActive\n\t        };\n\t      }\n\t\n\t      function getPages(currentPage, totalPages) {\n\t        var pages = [];\n\t\n\t        // Default page limits\n\t        var startPage = 1, endPage = totalPages;\n\t        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );\n\t\n\t        // recompute if maxSize\n\t        if ( isMaxSized ) {\n\t          if ( rotate ) {\n\t            // Current page is displayed in the middle of the visible ones\n\t            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n\t            endPage   = startPage + maxSize - 1;\n\t\n\t            // Adjust if limit is exceeded\n\t            if (endPage > totalPages) {\n\t              endPage   = totalPages;\n\t              startPage = endPage - maxSize + 1;\n\t            }\n\t          } else {\n\t            // Visible pages are paginated with maxSize\n\t            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\t\n\t            // Adjust last page if limit is exceeded\n\t            endPage = Math.min(startPage + maxSize - 1, totalPages);\n\t          }\n\t        }\n\t\n\t        // Add page number links\n\t        for (var number = startPage; number <= endPage; number++) {\n\t          var page = makePage(number, number, number === currentPage);\n\t          pages.push(page);\n\t        }\n\t\n\t        // Add links to move between page sets\n\t        if ( isMaxSized && ! rotate ) {\n\t          if ( startPage > 1 ) {\n\t            var previousPageSet = makePage(startPage - 1, '...', false);\n\t            pages.unshift(previousPageSet);\n\t          }\n\t\n\t          if ( endPage < totalPages ) {\n\t            var nextPageSet = makePage(endPage + 1, '...', false);\n\t            pages.push(nextPageSet);\n\t          }\n\t        }\n\t\n\t        return pages;\n\t      }\n\t\n\t      var originalRender = paginationCtrl.render;\n\t      paginationCtrl.render = function() {\n\t        originalRender();\n\t        if (scope.page > 0 && scope.page <= scope.totalPages) {\n\t          scope.pages = getPages(scope.page, scope.totalPages);\n\t        }\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t.constant('pagerConfig', {\n\t  itemsPerPage: 10,\n\t  previousText: ' Previous',\n\t  nextText: 'Next ',\n\t  align: true\n\t})\n\t\n\t.directive('pager', ['pagerConfig', function(pagerConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      previousText: '@',\n\t      nextText: '@'\n\t    },\n\t    require: ['pager', '?ngModel'],\n\t    controller: 'PaginationController',\n\t    templateUrl: 'template/pagination/pager.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n\t      paginationCtrl.init(ngModelCtrl, pagerConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, html tooltips, and selector delegation.\n\t */\n\tangular.module( 'ui.bootstrap.tooltip', [ 'ui.bootstrap.position', 'ui.bootstrap.bindHtml' ] )\n\t\n\t/**\n\t * The $tooltip service creates tooltip- and popover-like directives as well as\n\t * houses global options for them.\n\t */\n\t.provider( '$tooltip', function () {\n\t  // The default options tooltip and popover.\n\t  var defaultOptions = {\n\t    placement: 'top',\n\t    animation: true,\n\t    popupDelay: 0\n\t  };\n\t\n\t  // Default hide triggers for each show trigger\n\t  var triggerMap = {\n\t    'mouseenter': 'mouseleave',\n\t    'click': 'click',\n\t    'focus': 'blur'\n\t  };\n\t\n\t  // The options specified to the provider globally.\n\t  var globalOptions = {};\n\t\n\t  /**\n\t   * `options({})` allows global configuration of all tooltips in the\n\t   * application.\n\t   *\n\t   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n\t   *     // place tooltips left instead of top by default\n\t   *     $tooltipProvider.options( { placement: 'left' } );\n\t   *   });\n\t   */\n\t\tthis.options = function( value ) {\n\t\t\tangular.extend( globalOptions, value );\n\t\t};\n\t\n\t  /**\n\t   * This allows you to extend the set of trigger mappings available. E.g.:\n\t   *\n\t   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n\t   */\n\t  this.setTriggers = function setTriggers ( triggers ) {\n\t    angular.extend( triggerMap, triggers );\n\t  };\n\t\n\t  /**\n\t   * This is a helper function for translating camel-case to snake-case.\n\t   */\n\t  function snake_case(name){\n\t    var regexp = /[A-Z]/g;\n\t    var separator = '-';\n\t    return name.replace(regexp, function(letter, pos) {\n\t      return (pos ? separator : '') + letter.toLowerCase();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Returns the actual instance of the $tooltip service.\n\t   * TODO support multiple triggers\n\t   */\n\t  this.$get = [ '$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ( $window, $compile, $timeout, $parse, $document, $position, $interpolate ) {\n\t    return function $tooltip ( type, prefix, defaultTriggerShow ) {\n\t      var options = angular.extend( {}, defaultOptions, globalOptions );\n\t\n\t      /**\n\t       * Returns an object of show and hide triggers.\n\t       *\n\t       * If a trigger is supplied,\n\t       * it is used to show the tooltip; otherwise, it will use the `trigger`\n\t       * option passed to the `$tooltipProvider.options` method; else it will\n\t       * default to the trigger supplied to this directive factory.\n\t       *\n\t       * The hide trigger is based on the show trigger. If the `trigger` option\n\t       * was passed to the `$tooltipProvider.options` method, it will use the\n\t       * mapped trigger from `triggerMap` or the passed trigger if the map is\n\t       * undefined; otherwise, it uses the `triggerMap` value of the show\n\t       * trigger; else it will just use the show trigger.\n\t       */\n\t      function getTriggers ( trigger ) {\n\t        var show = trigger || options.trigger || defaultTriggerShow;\n\t        var hide = triggerMap[show] || show;\n\t        return {\n\t          show: show,\n\t          hide: hide\n\t        };\n\t      }\n\t\n\t      var directiveName = snake_case( type );\n\t\n\t      var startSym = $interpolate.startSymbol();\n\t      var endSym = $interpolate.endSymbol();\n\t      var template =\n\t        '<div '+ directiveName +'-popup '+\n\t          'title=\"'+startSym+'tt_title'+endSym+'\" '+\n\t          'content=\"'+startSym+'tt_content'+endSym+'\" '+\n\t          'placement=\"'+startSym+'tt_placement'+endSym+'\" '+\n\t          'animation=\"tt_animation\" '+\n\t          'is-open=\"tt_isOpen\"'+\n\t          '>'+\n\t        '</div>';\n\t\n\t      return {\n\t        restrict: 'EA',\n\t        scope: true,\n\t        compile: function (tElem, tAttrs) {\n\t          var tooltipLinker = $compile( template );\n\t\n\t          return function link ( scope, element, attrs ) {\n\t            var tooltip;\n\t            var transitionTimeout;\n\t            var popupTimeout;\n\t            var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;\n\t            var triggers = getTriggers( undefined );\n\t            var hasEnableExp = angular.isDefined(attrs[prefix+'Enable']);\n\t\n\t            var positionTooltip = function () {\n\t\n\t              var ttPosition = $position.positionElements(element, tooltip, scope.tt_placement, appendToBody);\n\t              ttPosition.top += 'px';\n\t              ttPosition.left += 'px';\n\t\n\t              // Now set the calculated positioning.\n\t              tooltip.css( ttPosition );\n\t            };\n\t\n\t            // By default, the tooltip is not open.\n\t            // TODO add ability to start tooltip opened\n\t            scope.tt_isOpen = false;\n\t\n\t            function toggleTooltipBind () {\n\t              if ( ! scope.tt_isOpen ) {\n\t                showTooltipBind();\n\t              } else {\n\t                hideTooltipBind();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip with delay if specified, otherwise show it immediately\n\t            function showTooltipBind() {\n\t              if(hasEnableExp && !scope.$eval(attrs[prefix+'Enable'])) {\n\t                return;\n\t              }\n\t              if ( scope.tt_popupDelay ) {\n\t                // Do nothing if the tooltip was already scheduled to pop-up.\n\t                // This happens if show is triggered multiple times before any hide is triggered.\n\t                if (!popupTimeout) {\n\t                  popupTimeout = $timeout( show, scope.tt_popupDelay, false );\n\t                  popupTimeout.then(function(reposition){reposition();});\n\t                }\n\t              } else {\n\t                show()();\n\t              }\n\t            }\n\t\n\t            function hideTooltipBind () {\n\t              scope.$apply(function () {\n\t                hide();\n\t              });\n\t            }\n\t\n\t            // Show the tooltip popup element.\n\t            function show() {\n\t\n\t              popupTimeout = null;\n\t\n\t              // If there is a pending remove transition, we must cancel it, lest the\n\t              // tooltip be mysteriously removed.\n\t              if ( transitionTimeout ) {\n\t                $timeout.cancel( transitionTimeout );\n\t                transitionTimeout = null;\n\t              }\n\t\n\t              // Don't show empty tooltips.\n\t              if ( ! scope.tt_content ) {\n\t                return angular.noop;\n\t              }\n\t\n\t              createTooltip();\n\t\n\t              // Set the initial positioning.\n\t              tooltip.css({ top: 0, left: 0, display: 'block' });\n\t\n\t              // Now we add it to the DOM because need some info about it. But it's not \n\t              // visible yet anyway.\n\t              if ( appendToBody ) {\n\t                  $document.find( 'body' ).append( tooltip );\n\t              } else {\n\t                element.after( tooltip );\n\t              }\n\t\n\t              positionTooltip();\n\t\n\t              // And show the tooltip.\n\t              scope.tt_isOpen = true;\n\t              scope.$digest(); // digest required as $apply is not called\n\t\n\t              // Return positioning function as promise callback for correct\n\t              // positioning after draw.\n\t              return positionTooltip;\n\t            }\n\t\n\t            // Hide the tooltip popup element.\n\t            function hide() {\n\t              // First things first: we don't show it anymore.\n\t              scope.tt_isOpen = false;\n\t\n\t              //if tooltip is going to be shown after delay, we must cancel this\n\t              $timeout.cancel( popupTimeout );\n\t              popupTimeout = null;\n\t\n\t              // And now we remove it from the DOM. However, if we have animation, we \n\t              // need to wait for it to expire beforehand.\n\t              // FIXME: this is a placeholder for a port of the transitions library.\n\t              if ( scope.tt_animation ) {\n\t                if (!transitionTimeout) {\n\t                  transitionTimeout = $timeout(removeTooltip, 500);\n\t                }\n\t              } else {\n\t                removeTooltip();\n\t              }\n\t            }\n\t\n\t            function createTooltip() {\n\t              // There can only be one tooltip element per directive shown at once.\n\t              if (tooltip) {\n\t                removeTooltip();\n\t              }\n\t              tooltip = tooltipLinker(scope, function () {});\n\t\n\t              // Get contents rendered into the tooltip\n\t              scope.$digest();\n\t            }\n\t\n\t            function removeTooltip() {\n\t              transitionTimeout = null;\n\t              if (tooltip) {\n\t                tooltip.remove();\n\t                tooltip = null;\n\t              }\n\t            }\n\t\n\t            /**\n\t             * Observe the relevant attributes.\n\t             */\n\t            attrs.$observe( type, function ( val ) {\n\t              scope.tt_content = val;\n\t\n\t              if (!val && scope.tt_isOpen ) {\n\t                hide();\n\t              }\n\t            });\n\t\n\t            attrs.$observe( prefix+'Title', function ( val ) {\n\t              scope.tt_title = val;\n\t            });\n\t\n\t            attrs.$observe( prefix+'Placement', function ( val ) {\n\t              scope.tt_placement = angular.isDefined( val ) ? val : options.placement;\n\t            });\n\t\n\t            attrs.$observe( prefix+'PopupDelay', function ( val ) {\n\t              var delay = parseInt( val, 10 );\n\t              scope.tt_popupDelay = ! isNaN(delay) ? delay : options.popupDelay;\n\t            });\n\t\n\t            var unregisterTriggers = function () {\n\t              element.unbind(triggers.show, showTooltipBind);\n\t              element.unbind(triggers.hide, hideTooltipBind);\n\t            };\n\t\n\t            attrs.$observe( prefix+'Trigger', function ( val ) {\n\t              unregisterTriggers();\n\t\n\t              triggers = getTriggers( val );\n\t\n\t              if ( triggers.show === triggers.hide ) {\n\t                element.bind( triggers.show, toggleTooltipBind );\n\t              } else {\n\t                element.bind( triggers.show, showTooltipBind );\n\t                element.bind( triggers.hide, hideTooltipBind );\n\t              }\n\t            });\n\t\n\t            var animation = scope.$eval(attrs[prefix + 'Animation']);\n\t            scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation;\n\t\n\t            attrs.$observe( prefix+'AppendToBody', function ( val ) {\n\t              appendToBody = angular.isDefined( val ) ? $parse( val )( scope ) : appendToBody;\n\t            });\n\t\n\t            // if a tooltip is attached to <body> we need to remove it on\n\t            // location change as its parent scope will probably not be destroyed\n\t            // by the change.\n\t            if ( appendToBody ) {\n\t              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {\n\t              if ( scope.tt_isOpen ) {\n\t                hide();\n\t              }\n\t            });\n\t            }\n\t\n\t            // Make sure tooltip is destroyed and removed.\n\t            scope.$on('$destroy', function onDestroyTooltip() {\n\t              $timeout.cancel( transitionTimeout );\n\t              $timeout.cancel( popupTimeout );\n\t              unregisterTriggers();\n\t              removeTooltip();\n\t            });\n\t          };\n\t        }\n\t      };\n\t    };\n\t  }];\n\t})\n\t\n\t.directive( 'tooltipPopup', function () {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-popup.html'\n\t  };\n\t})\n\t\n\t.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {\n\t  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );\n\t}])\n\t\n\t.directive( 'tooltipHtmlUnsafePopup', function () {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'\n\t  };\n\t})\n\t\n\t.directive( 'tooltipHtmlUnsafe', [ '$tooltip', function ( $tooltip ) {\n\t  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: popup delay, animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, html popovers, and selector delegatation.\n\t */\n\tangular.module( 'ui.bootstrap.popover', [ 'ui.bootstrap.tooltip' ] )\n\t\n\t.directive( 'popoverPopup', function () {\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover.html'\n\t  };\n\t})\n\t\n\t.directive( 'popover', [ '$tooltip', function ( $tooltip ) {\n\t  return $tooltip( 'popover', 'popover', 'click' );\n\t}]);\n\t\n\tangular.module('ui.bootstrap.progressbar', [])\n\t\n\t.constant('progressConfig', {\n\t  animate: true,\n\t  max: 100\n\t})\n\t\n\t.controller('ProgressController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {\n\t    var self = this,\n\t        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\t\n\t    this.bars = [];\n\t    $scope.max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max;\n\t\n\t    this.addBar = function(bar, element) {\n\t        if ( !animate ) {\n\t            element.css({'transition': 'none'});\n\t        }\n\t\n\t        this.bars.push(bar);\n\t\n\t        bar.$watch('value', function( value ) {\n\t            bar.percent = +(100 * value / $scope.max).toFixed(2);\n\t        });\n\t\n\t        bar.$on('$destroy', function() {\n\t            element = null;\n\t            self.removeBar(bar);\n\t        });\n\t    };\n\t\n\t    this.removeBar = function(bar) {\n\t        this.bars.splice(this.bars.indexOf(bar), 1);\n\t    };\n\t}])\n\t\n\t.directive('progress', function() {\n\t    return {\n\t        restrict: 'EA',\n\t        replace: true,\n\t        transclude: true,\n\t        controller: 'ProgressController',\n\t        require: 'progress',\n\t        scope: {},\n\t        templateUrl: 'template/progressbar/progress.html'\n\t    };\n\t})\n\t\n\t.directive('bar', function() {\n\t    return {\n\t        restrict: 'EA',\n\t        replace: true,\n\t        transclude: true,\n\t        require: '^progress',\n\t        scope: {\n\t            value: '=',\n\t            type: '@'\n\t        },\n\t        templateUrl: 'template/progressbar/bar.html',\n\t        link: function(scope, element, attrs, progressCtrl) {\n\t            progressCtrl.addBar(scope, element);\n\t        }\n\t    };\n\t})\n\t\n\t.directive('progressbar', function() {\n\t    return {\n\t        restrict: 'EA',\n\t        replace: true,\n\t        transclude: true,\n\t        controller: 'ProgressController',\n\t        scope: {\n\t            value: '=',\n\t            type: '@'\n\t        },\n\t        templateUrl: 'template/progressbar/progressbar.html',\n\t        link: function(scope, element, attrs, progressCtrl) {\n\t            progressCtrl.addBar(scope, angular.element(element.children()[0]));\n\t        }\n\t    };\n\t});\n\tangular.module('ui.bootstrap.rating', [])\n\t\n\t.constant('ratingConfig', {\n\t  max: 5,\n\t  stateOn: null,\n\t  stateOff: null\n\t})\n\t\n\t.controller('RatingController', ['$scope', '$attrs', 'ratingConfig', function($scope, $attrs, ratingConfig) {\n\t  var ngModelCtrl  = { $setViewValue: angular.noop };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n\t    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\t\n\t    var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) :\n\t                        new Array( angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max );\n\t    $scope.range = this.buildTemplateObjects(ratingStates);\n\t  };\n\t\n\t  this.buildTemplateObjects = function(states) {\n\t    for (var i = 0, n = states.length; i < n; i++) {\n\t      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff }, states[i]);\n\t    }\n\t    return states;\n\t  };\n\t\n\t  $scope.rate = function(value) {\n\t    if ( !$scope.readonly && value >= 0 && value <= $scope.range.length ) {\n\t      ngModelCtrl.$setViewValue(value);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.enter = function(value) {\n\t    if ( !$scope.readonly ) {\n\t      $scope.value = value;\n\t    }\n\t    $scope.onHover({value: value});\n\t  };\n\t\n\t  $scope.reset = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t    $scope.onLeave();\n\t  };\n\t\n\t  $scope.onKeydown = function(evt) {\n\t    if (/(37|38|39|40)/.test(evt.which)) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.rate( $scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1) );\n\t    }\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t  };\n\t}])\n\t\n\t.directive('rating', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    require: ['rating', 'ngModel'],\n\t    scope: {\n\t      readonly: '=?',\n\t      onHover: '&',\n\t      onLeave: '&'\n\t    },\n\t    controller: 'RatingController',\n\t    templateUrl: 'template/rating/rating.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if ( ngModelCtrl ) {\n\t        ratingCtrl.init( ngModelCtrl );\n\t      }\n\t    }\n\t  };\n\t});\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.bootstrap.tabs\n\t *\n\t * @description\n\t * AngularJS version of the tabs directive.\n\t */\n\t\n\tangular.module('ui.bootstrap.tabs', [])\n\t\n\t.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {\n\t  var ctrl = this,\n\t      tabs = ctrl.tabs = $scope.tabs = [];\n\t\n\t  ctrl.select = function(selectedTab) {\n\t    angular.forEach(tabs, function(tab) {\n\t      if (tab.active && tab !== selectedTab) {\n\t        tab.active = false;\n\t        tab.onDeselect();\n\t      }\n\t    });\n\t    selectedTab.active = true;\n\t    selectedTab.onSelect();\n\t  };\n\t\n\t  ctrl.addTab = function addTab(tab) {\n\t    tabs.push(tab);\n\t    // we can't run the select function on the first tab\n\t    // since that would select it twice\n\t    if (tabs.length === 1) {\n\t      tab.active = true;\n\t    } else if (tab.active) {\n\t      ctrl.select(tab);\n\t    }\n\t  };\n\t\n\t  ctrl.removeTab = function removeTab(tab) {\n\t    var index = tabs.indexOf(tab);\n\t    //Select a new tab if the tab to be removed is selected\n\t    if (tab.active && tabs.length > 1) {\n\t      //If this is the last tab, select the previous tab. else, the next tab.\n\t      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n\t      ctrl.select(tabs[newActiveIndex]);\n\t    }\n\t    tabs.splice(index, 1);\n\t  };\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tabset\n\t * @restrict EA\n\t *\n\t * @description\n\t * Tabset is the outer container for the tabs directive\n\t *\n\t * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n\t * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <tabset>\n\t      <tab heading=\"Tab 1\"><b>First</b> Content!</tab>\n\t      <tab heading=\"Tab 2\"><i>Second</i> Content!</tab>\n\t    </tabset>\n\t    <hr />\n\t    <tabset vertical=\"true\">\n\t      <tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</tab>\n\t      <tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</tab>\n\t    </tabset>\n\t    <tabset justified=\"true\">\n\t      <tab heading=\"Justified Tab 1\"><b>First</b> Justified Content!</tab>\n\t      <tab heading=\"Justified Tab 2\"><i>Second</i> Justified Content!</tab>\n\t    </tabset>\n\t  </file>\n\t</example>\n\t */\n\t.directive('tabset', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@'\n\t    },\n\t    controller: 'TabsetController',\n\t    templateUrl: 'template/tabs/tabset.html',\n\t    link: function(scope, element, attrs) {\n\t      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n\t      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n\t    }\n\t  };\n\t})\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tab\n\t * @restrict EA\n\t *\n\t * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\n\t * @param {string=} select An expression to evaluate when the tab is selected.\n\t * @param {boolean=} active A binding, telling whether or not this tab is selected.\n\t * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n\t *\n\t * @description\n\t * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <div ng-controller=\"TabsDemoCtrl\">\n\t      <button class=\"btn btn-small\" ng-click=\"items[0].active = true\">\n\t        Select item 1, using active binding\n\t      </button>\n\t      <button class=\"btn btn-small\" ng-click=\"items[1].disabled = !items[1].disabled\">\n\t        Enable/disable item 2, using disabled binding\n\t      </button>\n\t      <br />\n\t      <tabset>\n\t        <tab heading=\"Tab 1\">First Tab</tab>\n\t        <tab select=\"alertMe()\">\n\t          <tab-heading><i class=\"icon-bell\"></i> Alert me!</tab-heading>\n\t          Second Tab, with alert callback and html heading!\n\t        </tab>\n\t        <tab ng-repeat=\"item in items\"\n\t          heading=\"{{item.title}}\"\n\t          disabled=\"item.disabled\"\n\t          active=\"item.active\">\n\t          {{item.content}}\n\t        </tab>\n\t      </tabset>\n\t    </div>\n\t  </file>\n\t  <file name=\"script.js\">\n\t    function TabsDemoCtrl($scope) {\n\t      $scope.items = [\n\t        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\n\t        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\n\t      ];\n\t\n\t      $scope.alertMe = function() {\n\t        setTimeout(function() {\n\t          alert(\"You've selected the alert tab!\");\n\t        });\n\t      };\n\t    };\n\t  </file>\n\t</example>\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tabHeading\n\t * @restrict EA\n\t *\n\t * @description\n\t * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <tabset>\n\t      <tab>\n\t        <tab-heading><b>HTML</b> in my titles?!</tab-heading>\n\t        And some content, too!\n\t      </tab>\n\t      <tab>\n\t        <tab-heading><i class=\"icon-heart\"></i> Icon heading?!?</tab-heading>\n\t        That's right.\n\t      </tab>\n\t    </tabset>\n\t  </file>\n\t</example>\n\t */\n\t.directive('tab', ['$parse', function($parse) {\n\t  return {\n\t    require: '^tabset',\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/tabs/tab.html',\n\t    transclude: true,\n\t    scope: {\n\t      active: '=?',\n\t      heading: '@',\n\t      onSelect: '&select', //This callback is called in contentHeadingTransclude\n\t                          //once it inserts the tab's content into the dom\n\t      onDeselect: '&deselect'\n\t    },\n\t    controller: function() {\n\t      //Empty controller so other directives can require being 'under' a tab\n\t    },\n\t    compile: function(elm, attrs, transclude) {\n\t      return function postLink(scope, elm, attrs, tabsetCtrl) {\n\t        scope.$watch('active', function(active) {\n\t          if (active) {\n\t            tabsetCtrl.select(scope);\n\t          }\n\t        });\n\t\n\t        scope.disabled = false;\n\t        if ( attrs.disabled ) {\n\t          scope.$parent.$watch($parse(attrs.disabled), function(value) {\n\t            scope.disabled = !! value;\n\t          });\n\t        }\n\t\n\t        scope.select = function() {\n\t          if ( !scope.disabled ) {\n\t            scope.active = true;\n\t          }\n\t        };\n\t\n\t        tabsetCtrl.addTab(scope);\n\t        scope.$on('$destroy', function() {\n\t          tabsetCtrl.removeTab(scope);\n\t        });\n\t\n\t        //We need to transclude later, once the content container is ready.\n\t        //when this link happens, we're inside a tab heading.\n\t        scope.$transcludeFn = transclude;\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tabHeadingTransclude', [function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^tab',\n\t    link: function(scope, elm, attrs, tabCtrl) {\n\t      scope.$watch('headingElement', function updateHeadingElement(heading) {\n\t        if (heading) {\n\t          elm.html('');\n\t          elm.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tabContentTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^tabset',\n\t    link: function(scope, elm, attrs) {\n\t      var tab = scope.$eval(attrs.tabContentTransclude);\n\t\n\t      //Now our tab is ready to be transcluded: both the tab heading area\n\t      //and the tab content area are loaded.  Transclude 'em both.\n\t      tab.$transcludeFn(tab.$parent, function(contents) {\n\t        angular.forEach(contents, function(node) {\n\t          if (isTabHeading(node)) {\n\t            //Let tabHeadingTransclude know.\n\t            tab.headingElement = node;\n\t          } else {\n\t            elm.append(node);\n\t          }\n\t        });\n\t      });\n\t    }\n\t  };\n\t  function isTabHeading(node) {\n\t    return node.tagName &&  (\n\t      node.hasAttribute('tab-heading') ||\n\t      node.hasAttribute('data-tab-heading') ||\n\t      node.tagName.toLowerCase() === 'tab-heading' ||\n\t      node.tagName.toLowerCase() === 'data-tab-heading'\n\t    );\n\t  }\n\t})\n\t\n\t;\n\t\n\tangular.module('ui.bootstrap.timepicker', [])\n\t\n\t.constant('timepickerConfig', {\n\t  hourStep: 1,\n\t  minuteStep: 1,\n\t  showMeridian: true,\n\t  meridians: null,\n\t  readonlyInput: false,\n\t  mousewheel: true\n\t})\n\t\n\t.controller('TimepickerController', ['$scope', '$attrs', '$parse', '$log', '$locale', 'timepickerConfig', function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {\n\t  var selected = new Date(),\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\t\n\t  this.init = function( ngModelCtrl_, inputs ) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    var hoursInputEl = inputs.eq(0),\n\t        minutesInputEl = inputs.eq(1);\n\t\n\t    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\t    if ( mousewheel ) {\n\t      this.setupMousewheelEvents( hoursInputEl, minutesInputEl );\n\t    }\n\t\n\t    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n\t    this.setupInputEvents( hoursInputEl, minutesInputEl );\n\t  };\n\t\n\t  var hourStep = timepickerConfig.hourStep;\n\t  if ($attrs.hourStep) {\n\t    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n\t      hourStep = parseInt(value, 10);\n\t    });\n\t  }\n\t\n\t  var minuteStep = timepickerConfig.minuteStep;\n\t  if ($attrs.minuteStep) {\n\t    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n\t      minuteStep = parseInt(value, 10);\n\t    });\n\t  }\n\t\n\t  // 12H / 24H mode\n\t  $scope.showMeridian = timepickerConfig.showMeridian;\n\t  if ($attrs.showMeridian) {\n\t    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n\t      $scope.showMeridian = !!value;\n\t\n\t      if ( ngModelCtrl.$error.time ) {\n\t        // Evaluate from template\n\t        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n\t        if (angular.isDefined( hours ) && angular.isDefined( minutes )) {\n\t          selected.setHours( hours );\n\t          refresh();\n\t        }\n\t      } else {\n\t        updateTemplate();\n\t      }\n\t    });\n\t  }\n\t\n\t  // Get $scope.hours in 24H mode if valid\n\t  function getHoursFromTemplate ( ) {\n\t    var hours = parseInt( $scope.hours, 10 );\n\t    var valid = ( $scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n\t    if ( !valid ) {\n\t      return undefined;\n\t    }\n\t\n\t    if ( $scope.showMeridian ) {\n\t      if ( hours === 12 ) {\n\t        hours = 0;\n\t      }\n\t      if ( $scope.meridian === meridians[1] ) {\n\t        hours = hours + 12;\n\t      }\n\t    }\n\t    return hours;\n\t  }\n\t\n\t  function getMinutesFromTemplate() {\n\t    var minutes = parseInt($scope.minutes, 10);\n\t    return ( minutes >= 0 && minutes < 60 ) ? minutes : undefined;\n\t  }\n\t\n\t  function pad( value ) {\n\t    return ( angular.isDefined(value) && value.toString().length < 2 ) ? '0' + value : value;\n\t  }\n\t\n\t  // Respond on mousewheel spin\n\t  this.setupMousewheelEvents = function( hoursInputEl, minutesInputEl ) {\n\t    var isScrollingUp = function(e) {\n\t      if (e.originalEvent) {\n\t        e = e.originalEvent;\n\t      }\n\t      //pick correct delta variable depending on event\n\t      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n\t      return (e.detail || delta > 0);\n\t    };\n\t\n\t    hoursInputEl.bind('mousewheel wheel', function(e) {\n\t      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementHours() : $scope.decrementHours() );\n\t      e.preventDefault();\n\t    });\n\t\n\t    minutesInputEl.bind('mousewheel wheel', function(e) {\n\t      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementMinutes() : $scope.decrementMinutes() );\n\t      e.preventDefault();\n\t    });\n\t\n\t  };\n\t\n\t  this.setupInputEvents = function( hoursInputEl, minutesInputEl ) {\n\t    if ( $scope.readonlyInput ) {\n\t      $scope.updateHours = angular.noop;\n\t      $scope.updateMinutes = angular.noop;\n\t      return;\n\t    }\n\t\n\t    var invalidate = function(invalidHours, invalidMinutes) {\n\t      ngModelCtrl.$setViewValue( null );\n\t      ngModelCtrl.$setValidity('time', false);\n\t      if (angular.isDefined(invalidHours)) {\n\t        $scope.invalidHours = invalidHours;\n\t      }\n\t      if (angular.isDefined(invalidMinutes)) {\n\t        $scope.invalidMinutes = invalidMinutes;\n\t      }\n\t    };\n\t\n\t    $scope.updateHours = function() {\n\t      var hours = getHoursFromTemplate();\n\t\n\t      if ( angular.isDefined(hours) ) {\n\t        selected.setHours( hours );\n\t        refresh( 'h' );\n\t      } else {\n\t        invalidate(true);\n\t      }\n\t    };\n\t\n\t    hoursInputEl.bind('blur', function(e) {\n\t      if ( !$scope.invalidHours && $scope.hours < 10) {\n\t        $scope.$apply( function() {\n\t          $scope.hours = pad( $scope.hours );\n\t        });\n\t      }\n\t    });\n\t\n\t    $scope.updateMinutes = function() {\n\t      var minutes = getMinutesFromTemplate();\n\t\n\t      if ( angular.isDefined(minutes) ) {\n\t        selected.setMinutes( minutes );\n\t        refresh( 'm' );\n\t      } else {\n\t        invalidate(undefined, true);\n\t      }\n\t    };\n\t\n\t    minutesInputEl.bind('blur', function(e) {\n\t      if ( !$scope.invalidMinutes && $scope.minutes < 10 ) {\n\t        $scope.$apply( function() {\n\t          $scope.minutes = pad( $scope.minutes );\n\t        });\n\t      }\n\t    });\n\t\n\t  };\n\t\n\t  this.render = function() {\n\t    var date = ngModelCtrl.$modelValue ? new Date( ngModelCtrl.$modelValue ) : null;\n\t\n\t    if ( isNaN(date) ) {\n\t      ngModelCtrl.$setValidity('time', false);\n\t      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t    } else {\n\t      if ( date ) {\n\t        selected = date;\n\t      }\n\t      makeValid();\n\t      updateTemplate();\n\t    }\n\t  };\n\t\n\t  // Call internally when we know that model is valid.\n\t  function refresh( keyboardChange ) {\n\t    makeValid();\n\t    ngModelCtrl.$setViewValue( new Date(selected) );\n\t    updateTemplate( keyboardChange );\n\t  }\n\t\n\t  function makeValid() {\n\t    ngModelCtrl.$setValidity('time', true);\n\t    $scope.invalidHours = false;\n\t    $scope.invalidMinutes = false;\n\t  }\n\t\n\t  function updateTemplate( keyboardChange ) {\n\t    var hours = selected.getHours(), minutes = selected.getMinutes();\n\t\n\t    if ( $scope.showMeridian ) {\n\t      hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system\n\t    }\n\t\n\t    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n\t    $scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);\n\t    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\t  }\n\t\n\t  function addMinutes( minutes ) {\n\t    var dt = new Date( selected.getTime() + minutes * 60000 );\n\t    selected.setHours( dt.getHours(), dt.getMinutes() );\n\t    refresh();\n\t  }\n\t\n\t  $scope.incrementHours = function() {\n\t    addMinutes( hourStep * 60 );\n\t  };\n\t  $scope.decrementHours = function() {\n\t    addMinutes( - hourStep * 60 );\n\t  };\n\t  $scope.incrementMinutes = function() {\n\t    addMinutes( minuteStep );\n\t  };\n\t  $scope.decrementMinutes = function() {\n\t    addMinutes( - minuteStep );\n\t  };\n\t  $scope.toggleMeridian = function() {\n\t    addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );\n\t  };\n\t}])\n\t\n\t.directive('timepicker', function () {\n\t  return {\n\t    restrict: 'EA',\n\t    require: ['timepicker', '?^ngModel'],\n\t    controller:'TimepickerController',\n\t    replace: true,\n\t    scope: {},\n\t    templateUrl: 'template/timepicker/timepicker.html',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if ( ngModelCtrl ) {\n\t        timepickerCtrl.init( ngModelCtrl, element.find('input') );\n\t      }\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])\n\t\n\t/**\n\t * A helper service that can parse typeahead's syntax (string provided by users)\n\t * Extracted to a separate service for ease of unit testing\n\t */\n\t  .factory('typeaheadParser', ['$parse', function ($parse) {\n\t\n\t  //                      00000111000000000000022200000000000000003333333333333330000000000044000\n\t  var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n\t\n\t  return {\n\t    parse:function (input) {\n\t\n\t      var match = input.match(TYPEAHEAD_REGEXP);\n\t      if (!match) {\n\t        throw new Error(\n\t          'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n\t            ' but got \"' + input + '\".');\n\t      }\n\t\n\t      return {\n\t        itemName:match[3],\n\t        source:$parse(match[4]),\n\t        viewMapper:$parse(match[2] || match[1]),\n\t        modelMapper:$parse(match[1])\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',\n\t    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {\n\t\n\t  var HOT_KEYS = [9, 13, 27, 38, 40];\n\t\n\t  return {\n\t    require:'ngModel',\n\t    link:function (originalScope, element, attrs, modelCtrl) {\n\t\n\t      //SUPPORTED ATTRIBUTES (OPTIONS)\n\t\n\t      //minimal no of characters that needs to be entered before typeahead kicks-in\n\t      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;\n\t\n\t      //minimal wait time after last character typed before typehead kicks-in\n\t      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\t\n\t      //should it restrict model values to the ones selected from the popup only?\n\t      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\t\n\t      //binding to a variable that indicates if matches are being retrieved asynchronously\n\t      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\t\n\t      //a callback executed when a match is selected\n\t      var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\t\n\t      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\t\n\t      var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\t\n\t      //INTERNAL VARIABLES\n\t\n\t      //model setter executed upon match selection\n\t      var $setModelValue = $parse(attrs.ngModel).assign;\n\t\n\t      //expressions used by typeahead\n\t      var parserResult = typeaheadParser.parse(attrs.typeahead);\n\t\n\t      var hasFocus;\n\t\n\t      //create a child scope for the typeahead directive so we are not polluting original scope\n\t      //with typeahead-specific data (matches, query etc.)\n\t      var scope = originalScope.$new();\n\t      originalScope.$on('$destroy', function(){\n\t        scope.$destroy();\n\t      });\n\t\n\t      // WAI-ARIA\n\t      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t      element.attr({\n\t        'aria-autocomplete': 'list',\n\t        'aria-expanded': false,\n\t        'aria-owns': popupId\n\t      });\n\t\n\t      //pop-up element used to display matches\n\t      var popUpEl = angular.element('<div typeahead-popup></div>');\n\t      popUpEl.attr({\n\t        id: popupId,\n\t        matches: 'matches',\n\t        active: 'activeIdx',\n\t        select: 'select(activeIdx)',\n\t        query: 'query',\n\t        position: 'position'\n\t      });\n\t      //custom item template\n\t      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n\t        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n\t      }\n\t\n\t      var resetMatches = function() {\n\t        scope.matches = [];\n\t        scope.activeIdx = -1;\n\t        element.attr('aria-expanded', false);\n\t      };\n\t\n\t      var getMatchId = function(index) {\n\t        return popupId + '-option-' + index;\n\t      };\n\t\n\t      // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n\t      // This attribute is added or removed automatically when the `activeIdx` changes.\n\t      scope.$watch('activeIdx', function(index) {\n\t        if (index < 0) {\n\t          element.removeAttr('aria-activedescendant');\n\t        } else {\n\t          element.attr('aria-activedescendant', getMatchId(index));\n\t        }\n\t      });\n\t\n\t      var getMatchesAsync = function(inputValue) {\n\t\n\t        var locals = {$viewValue: inputValue};\n\t        isLoadingSetter(originalScope, true);\n\t        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\t\n\t          //it might happen that several async queries were in progress if a user were typing fast\n\t          //but we are interested only in responses that correspond to the current view value\n\t          var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n\t          if (onCurrentRequest && hasFocus) {\n\t            if (matches.length > 0) {\n\t\n\t              scope.activeIdx = 0;\n\t              scope.matches.length = 0;\n\t\n\t              //transform labels\n\t              for(var i=0; i<matches.length; i++) {\n\t                locals[parserResult.itemName] = matches[i];\n\t                scope.matches.push({\n\t                  id: getMatchId(i),\n\t                  label: parserResult.viewMapper(scope, locals),\n\t                  model: matches[i]\n\t                });\n\t              }\n\t\n\t              scope.query = inputValue;\n\t              //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n\t              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n\t              //due to other elements being rendered\n\t              scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t              scope.position.top = scope.position.top + element.prop('offsetHeight');\n\t\n\t              element.attr('aria-expanded', true);\n\t            } else {\n\t              resetMatches();\n\t            }\n\t          }\n\t          if (onCurrentRequest) {\n\t            isLoadingSetter(originalScope, false);\n\t          }\n\t        }, function(){\n\t          resetMatches();\n\t          isLoadingSetter(originalScope, false);\n\t        });\n\t      };\n\t\n\t      resetMatches();\n\t\n\t      //we need to propagate user's query so we can higlight matches\n\t      scope.query = undefined;\n\t\n\t      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later \n\t      var timeoutPromise;\n\t\n\t      var scheduleSearchWithTimeout = function(inputValue) {\n\t        timeoutPromise = $timeout(function () {\n\t          getMatchesAsync(inputValue);\n\t        }, waitTime);\n\t      };\n\t\n\t      var cancelPreviousTimeout = function() {\n\t        if (timeoutPromise) {\n\t          $timeout.cancel(timeoutPromise);\n\t        }\n\t      };\n\t\n\t      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n\t      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n\t      modelCtrl.$parsers.unshift(function (inputValue) {\n\t\n\t        hasFocus = true;\n\t\n\t        if (inputValue && inputValue.length >= minSearch) {\n\t          if (waitTime > 0) {\n\t            cancelPreviousTimeout();\n\t            scheduleSearchWithTimeout(inputValue);\n\t          } else {\n\t            getMatchesAsync(inputValue);\n\t          }\n\t        } else {\n\t          isLoadingSetter(originalScope, false);\n\t          cancelPreviousTimeout();\n\t          resetMatches();\n\t        }\n\t\n\t        if (isEditable) {\n\t          return inputValue;\n\t        } else {\n\t          if (!inputValue) {\n\t            // Reset in case user had typed something previously.\n\t            modelCtrl.$setValidity('editable', true);\n\t            return inputValue;\n\t          } else {\n\t            modelCtrl.$setValidity('editable', false);\n\t            return undefined;\n\t          }\n\t        }\n\t      });\n\t\n\t      modelCtrl.$formatters.push(function (modelValue) {\n\t\n\t        var candidateViewValue, emptyViewValue;\n\t        var locals = {};\n\t\n\t        if (inputFormatter) {\n\t\n\t          locals['$model'] = modelValue;\n\t          return inputFormatter(originalScope, locals);\n\t\n\t        } else {\n\t\n\t          //it might happen that we don't have enough info to properly render input value\n\t          //we need to check for this situation and simply return model value if we can't apply custom formatting\n\t          locals[parserResult.itemName] = modelValue;\n\t          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n\t          locals[parserResult.itemName] = undefined;\n\t          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\t\n\t          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;\n\t        }\n\t      });\n\t\n\t      scope.select = function (activeIdx) {\n\t        //called from within the $digest() cycle\n\t        var locals = {};\n\t        var model, item;\n\t\n\t        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n\t        model = parserResult.modelMapper(originalScope, locals);\n\t        $setModelValue(originalScope, model);\n\t        modelCtrl.$setValidity('editable', true);\n\t\n\t        onSelectCallback(originalScope, {\n\t          $item: item,\n\t          $model: model,\n\t          $label: parserResult.viewMapper(originalScope, locals)\n\t        });\n\t\n\t        resetMatches();\n\t\n\t        //return focus to the input element if a match was selected via a mouse click event\n\t        // use timeout to avoid $rootScope:inprog error\n\t        $timeout(function() { element[0].focus(); }, 0, false);\n\t      };\n\t\n\t      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n\t      element.bind('keydown', function (evt) {\n\t\n\t        //typeahead is open and an \"interesting\" key was pressed\n\t        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n\t          return;\n\t        }\n\t\n\t        evt.preventDefault();\n\t\n\t        if (evt.which === 40) {\n\t          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n\t          scope.$digest();\n\t\n\t        } else if (evt.which === 38) {\n\t          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;\n\t          scope.$digest();\n\t\n\t        } else if (evt.which === 13 || evt.which === 9) {\n\t          scope.$apply(function () {\n\t            scope.select(scope.activeIdx);\n\t          });\n\t\n\t        } else if (evt.which === 27) {\n\t          evt.stopPropagation();\n\t\n\t          resetMatches();\n\t          scope.$digest();\n\t        }\n\t      });\n\t\n\t      element.bind('blur', function (evt) {\n\t        hasFocus = false;\n\t      });\n\t\n\t      // Keep reference to click handler to unbind it.\n\t      var dismissClickHandler = function (evt) {\n\t        if (element[0] !== evt.target) {\n\t          resetMatches();\n\t          scope.$digest();\n\t        }\n\t      };\n\t\n\t      $document.bind('click', dismissClickHandler);\n\t\n\t      originalScope.$on('$destroy', function(){\n\t        $document.unbind('click', dismissClickHandler);\n\t      });\n\t\n\t      var $popup = $compile(popUpEl)(scope);\n\t      if ( appendToBody ) {\n\t        $document.find('body').append($popup);\n\t      } else {\n\t        element.after($popup);\n\t      }\n\t    }\n\t  };\n\t\n\t}])\n\t\n\t  .directive('typeaheadPopup', function () {\n\t    return {\n\t      restrict:'EA',\n\t      scope:{\n\t        matches:'=',\n\t        query:'=',\n\t        active:'=',\n\t        position:'=',\n\t        select:'&'\n\t      },\n\t      replace:true,\n\t      templateUrl:'template/typeahead/typeahead-popup.html',\n\t      link:function (scope, element, attrs) {\n\t\n\t        scope.templateUrl = attrs.templateUrl;\n\t\n\t        scope.isOpen = function () {\n\t          return scope.matches.length > 0;\n\t        };\n\t\n\t        scope.isActive = function (matchIdx) {\n\t          return scope.active == matchIdx;\n\t        };\n\t\n\t        scope.selectActive = function (matchIdx) {\n\t          scope.active = matchIdx;\n\t        };\n\t\n\t        scope.selectMatch = function (activeIdx) {\n\t          scope.select({activeIdx:activeIdx});\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {\n\t    return {\n\t      restrict:'EA',\n\t      scope:{\n\t        index:'=',\n\t        match:'=',\n\t        query:'='\n\t      },\n\t      link:function (scope, element, attrs) {\n\t        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n\t        $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent){\n\t           element.replaceWith($compile(tplContent.trim())(scope));\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .filter('typeaheadHighlight', function() {\n\t\n\t    function escapeRegexp(queryToEscape) {\n\t      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n\t    }\n\t\n\t    return function(matchItem, query) {\n\t      return query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;\n\t    };\n\t  });\n\t\n\tangular.module(\"template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/accordion/accordion-group.html\",\n\t    \"<div class=\\\"panel panel-default\\\">\\n\" +\n\t    \"  <div class=\\\"panel-heading\\\">\\n\" +\n\t    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n\t    \"      <a class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" accordion-transclude=\\\"heading\\\"><span ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n\t    \"    </h4>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"  <div class=\\\"panel-collapse\\\" collapse=\\\"!isOpen\\\">\\n\" +\n\t    \"\t  <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/accordion/accordion.html\",\n\t    \"<div class=\\\"panel-group\\\" ng-transclude></div>\");\n\t}]);\n\t\n\tangular.module(\"template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/alert/alert.html\",\n\t    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissable' : null]\\\" role=\\\"alert\\\">\\n\" +\n\t    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close()\\\">\\n\" +\n\t    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n\t    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n\t    \"    </button>\\n\" +\n\t    \"    <div ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/carousel/carousel.html\",\n\t    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n\t    \"    <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"        <li ng-repeat=\\\"slide in slides track by $index\\\" ng-class=\\\"{active: isActive(slide)}\\\" ng-click=\\\"select(slide)\\\"></li>\\n\" +\n\t    \"    </ol>\\n\" +\n\t    \"    <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n\t    \"    <a class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\"><span class=\\\"glyphicon glyphicon-chevron-left\\\"></span></a>\\n\" +\n\t    \"    <a class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\"><span class=\\\"glyphicon glyphicon-chevron-right\\\"></span></a>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/carousel/slide.html\",\n\t    \"<div ng-class=\\\"{\\n\" +\n\t    \"    'active': leaving || (active && !entering),\\n\" +\n\t    \"    'prev': (next || active) && direction=='prev',\\n\" +\n\t    \"    'next': (next || active) && direction=='next',\\n\" +\n\t    \"    'right': direction=='prev',\\n\" +\n\t    \"    'left': direction=='next'\\n\" +\n\t    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/datepicker.html\",\n\t    \"<div ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n\t    \"  <daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></daypicker>\\n\" +\n\t    \"  <monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></monthpicker>\\n\" +\n\t    \"  <yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></yearpicker>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/day.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"{{5 + showWeeks}}\\\"><button id=\\\"{{uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th ng-show=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n\t    \"      <th ng-repeat=\\\"label in labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{label.full}}\\\">{{label.abbr}}</small></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-show=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{dt.uid}}\\\" aria-disabled=\\\"{{!!dt.disabled}}\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"width:100%;\\\" class=\\\"btn btn-default btn-sm\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/month.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th><button id=\\\"{{uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{dt.uid}}\\\" aria-disabled=\\\"{{!!dt.disabled}}\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"{'text-info': dt.current}\\\">{{dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/popup.html\",\n\t    \"<ul class=\\\"dropdown-menu\\\" ng-style=\\\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n\t    \"\t<li ng-transclude></li>\\n\" +\n\t    \"\t<li ng-if=\\\"showButtonBar\\\" style=\\\"padding:10px 9px 2px\\\">\\n\" +\n\t    \"\t\t<span class=\\\"btn-group\\\">\\n\" +\n\t    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-info\\\" ng-click=\\\"select('today')\\\">{{ getText('current') }}</button>\\n\" +\n\t    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger\\\" ng-click=\\\"select(null)\\\">{{ getText('clear') }}</button>\\n\" +\n\t    \"\t\t</span>\\n\" +\n\t    \"\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right\\\" ng-click=\\\"close()\\\">{{ getText('close') }}</button>\\n\" +\n\t    \"\t</li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/year.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"3\\\"><button id=\\\"{{uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{dt.uid}}\\\" aria-disabled=\\\"{{!!dt.disabled}}\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"{'text-info': dt.current}\\\">{{dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/modal/backdrop.html\",\n\t    \"<div class=\\\"modal-backdrop fade {{ backdropClass }}\\\"\\n\" +\n\t    \"     ng-class=\\\"{in: animate}\\\"\\n\" +\n\t    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n\t    \"></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/modal/window.html\",\n\t    \"<div tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal fade\\\" ng-class=\\\"{in: animate}\\\" ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\" ng-click=\\\"close($event)\\\">\\n\" +\n\t    \"    <div class=\\\"modal-dialog\\\" ng-class=\\\"{'modal-sm': size == 'sm', 'modal-lg': size == 'lg'}\\\"><div class=\\\"modal-content\\\" modal-transclude></div></div>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/pagination/pager.html\",\n\t    \"<ul class=\\\"pager\\\">\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noPrevious(), previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1)\\\">{{getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noNext(), next: align}\\\"><a href ng-click=\\\"selectPage(page + 1)\\\">{{getText('next')}}</a></li>\\n\" +\n\t    \"</ul>\");\n\t}]);\n\t\n\tangular.module(\"template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/pagination/pagination.html\",\n\t    \"<ul class=\\\"pagination\\\">\\n\" +\n\t    \"  <li ng-if=\\\"boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()}\\\"><a href ng-click=\\\"selectPage(1)\\\">{{getText('first')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"directionLinks\\\" ng-class=\\\"{disabled: noPrevious()}\\\"><a href ng-click=\\\"selectPage(page - 1)\\\">{{getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active}\\\"><a href ng-click=\\\"selectPage(page.number)\\\">{{page.text}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"directionLinks\\\" ng-class=\\\"{disabled: noNext()}\\\"><a href ng-click=\\\"selectPage(page + 1)\\\">{{getText('next')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"boundaryLinks\\\" ng-class=\\\"{disabled: noNext()}\\\"><a href ng-click=\\\"selectPage(totalPages)\\\">{{getText('last')}}</a></li>\\n\" +\n\t    \"</ul>\");\n\t}]);\n\t\n\tangular.module(\"template/tooltip/tooltip-html-unsafe-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tooltip/tooltip-html-unsafe-popup.html\",\n\t    \"<div class=\\\"tooltip {{placement}}\\\" ng-class=\\\"{ in: isOpen(), fade: animation() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" bind-html-unsafe=\\\"content\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tooltip/tooltip-popup.html\",\n\t    \"<div class=\\\"tooltip {{placement}}\\\" ng-class=\\\"{ in: isOpen(), fade: animation() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/popover/popover.html\",\n\t    \"<div class=\\\"popover {{placement}}\\\" ng-class=\\\"{ in: isOpen(), fade: animation() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-show=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/bar.html\",\n\t    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: percent + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" ng-transclude></div>\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/progress.html\",\n\t    \"<div class=\\\"progress\\\" ng-transclude></div>\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/progressbar.html\",\n\t    \"<div class=\\\"progress\\\">\\n\" +\n\t    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: percent + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" ng-transclude></div>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/rating/rating.html\",\n\t    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n\t    \"    <i ng-repeat=\\\"r in range track by $index\\\" ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\">\\n\" +\n\t    \"        <span class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n\t    \"    </i>\\n\" +\n\t    \"</span>\");\n\t}]);\n\t\n\tangular.module(\"template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tabs/tab.html\",\n\t    \"<li ng-class=\\\"{active: active, disabled: disabled}\\\">\\n\" +\n\t    \"  <a ng-click=\\\"select()\\\" tab-heading-transclude>{{heading}}</a>\\n\" +\n\t    \"</li>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tabs/tabset.html\",\n\t    \"<div>\\n\" +\n\t    \"  <ul class=\\\"nav nav-{{type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n\t    \"  <div class=\\\"tab-content\\\">\\n\" +\n\t    \"    <div class=\\\"tab-pane\\\" \\n\" +\n\t    \"         ng-repeat=\\\"tab in tabs\\\" \\n\" +\n\t    \"         ng-class=\\\"{active: tab.active}\\\"\\n\" +\n\t    \"         tab-content-transclude=\\\"tab\\\">\\n\" +\n\t    \"    </div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/timepicker/timepicker.html\",\n\t    \"<table>\\n\" +\n\t    \"\t<tbody>\\n\" +\n\t    \"\t\t<tr class=\\\"text-center\\\">\\n\" +\n\t    \"\t\t\t<td><a ng-click=\\\"incrementHours()\\\" class=\\\"btn btn-link\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"\t\t\t<td>&nbsp;</td>\\n\" +\n\t    \"\t\t\t<td><a ng-click=\\\"incrementMinutes()\\\" class=\\\"btn btn-link\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"\t\t\t<td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"\t\t</tr>\\n\" +\n\t    \"\t\t<tr>\\n\" +\n\t    \"\t\t\t<td style=\\\"width:50px;\\\" class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n\t    \"\t\t\t\t<input type=\\\"text\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-mousewheel=\\\"incrementHours()\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\">\\n\" +\n\t    \"\t\t\t</td>\\n\" +\n\t    \"\t\t\t<td>:</td>\\n\" +\n\t    \"\t\t\t<td style=\\\"width:50px;\\\" class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n\t    \"\t\t\t\t<input type=\\\"text\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\">\\n\" +\n\t    \"\t\t\t</td>\\n\" +\n\t    \"\t\t\t<td ng-show=\\\"showMeridian\\\"><button type=\\\"button\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\">{{meridian}}</button></td>\\n\" +\n\t    \"\t\t</tr>\\n\" +\n\t    \"\t\t<tr class=\\\"text-center\\\">\\n\" +\n\t    \"\t\t\t<td><a ng-click=\\\"decrementHours()\\\" class=\\\"btn btn-link\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"\t\t\t<td>&nbsp;</td>\\n\" +\n\t    \"\t\t\t<td><a ng-click=\\\"decrementMinutes()\\\" class=\\\"btn btn-link\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"\t\t\t<td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"\t\t</tr>\\n\" +\n\t    \"\t</tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/typeahead/typeahead-match.html\",\n\t    \"<a tabindex=\\\"-1\\\" bind-html-unsafe=\\\"match.label | typeaheadHighlight:query\\\"></a>\");\n\t}]);\n\t\n\tangular.module(\"template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/typeahead/typeahead-popup.html\",\n\t    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen()\\\" ng-style=\\\"{top: position.top+'px', left: position.left+'px'}\\\" style=\\\"display: block;\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index)\\\" role=\\\"option\\\" id=\\\"{{match.id}}\\\">\\n\" +\n\t    \"        <div typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar jade = __webpack_require__(6);\n\t\n\tmodule.exports = function template(locals) {\n\tvar buf = [];\n\tvar jade_mixins = {};\n\tvar jade_interp;\n\t\n\tbuf.push(\"<a href=\\\"https://github.com/applicaster/siren-browser\\\"><img style=\\\"position: absolute; top: 0; right: 0; border: 0; z-index:2;\\\" src=\\\"https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67\\\" alt=\\\"Fork me on GitHub\\\" data-canonical-src=\\\"https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png\\\"/></a><div cg-busy=\\\"{promise:myPromise,message:'Loading Your Data', minDuration: 500}\\\"> <div role=\\\"navigation\\\" style=\\\"z-index:1;\\\" class=\\\"navbar navbar-inverse navbar-fixed-top\\\"><div class=\\\"container\\\"><div class=\\\"navbar-header\\\"><button type=\\\"button\\\" data-toggle=\\\"collapse\\\" data-target=\\\".navbar-collapse\\\" class=\\\"navbar-toggle\\\"><span class=\\\"sr-only\\\">Toggle navigation</span><span class=\\\"icon-bar\\\"></span><span class=\\\"icon-bar\\\"></span><span class=\\\"icon-bar\\\"></span></button><a href=\\\"#\\\" class=\\\"navbar-brand\\\">Siren API Browser</a></div></div></div><div style=\\\"padding-top:60px;\\\" class=\\\"container\\\"><div class=\\\"row\\\"><div class=\\\"col-md-12\\\"><div ui-view=\\\"\\\"></div></div></div></div></div>\");;return buf.join(\"\");\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * State-based routing for AngularJS\n\t * @version v0.2.11\n\t * @link http://angular-ui.github.com/\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t/* commonjs package manager support (eg componentjs) */\n\tif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n\t  module.exports = 'ui.router';\n\t}\n\t\n\t(function (window, angular, undefined) {\n\t/*jshint globalstrict:true*/\n\t/*global angular:false*/\n\t'use strict';\n\t\n\tvar isDefined = angular.isDefined,\n\t    isFunction = angular.isFunction,\n\t    isString = angular.isString,\n\t    isObject = angular.isObject,\n\t    isArray = angular.isArray,\n\t    forEach = angular.forEach,\n\t    extend = angular.extend,\n\t    copy = angular.copy;\n\t\n\tfunction inherit(parent, extra) {\n\t  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n\t}\n\t\n\tfunction merge(dst) {\n\t  forEach(arguments, function(obj) {\n\t    if (obj !== dst) {\n\t      forEach(obj, function(value, key) {\n\t        if (!dst.hasOwnProperty(key)) dst[key] = value;\n\t      });\n\t    }\n\t  });\n\t  return dst;\n\t}\n\t\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t  var path = [];\n\t\n\t  for (var n in first.path) {\n\t    if (first.path[n] !== second.path[n]) break;\n\t    path.push(first.path[n]);\n\t  }\n\t  return path;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Object.keys()`.\n\t *\n\t * @param {Object} object A JavaScript object.\n\t * @return {Array} Returns the keys of the object as an array.\n\t */\n\tfunction objectKeys(object) {\n\t  if (Object.keys) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t\n\t  angular.forEach(object, function(val, key) {\n\t    result.push(key);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Array.prototype.indexOf()`.\n\t *\n\t * @param {Array} array A JavaScript array.\n\t * @param {*} value A value to search the array for.\n\t * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n\t */\n\tfunction arraySearch(array, value) {\n\t  if (Array.prototype.indexOf) {\n\t    return array.indexOf(value, Number(arguments[2]) || 0);\n\t  }\n\t  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n\t  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\t\n\t  if (from < 0) from += len;\n\t\n\t  for (; from < len; from++) {\n\t    if (from in array && array[from] === value) return from;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Merges a set of parameters with all parameters inherited between the common parents of the\n\t * current state and a given destination state.\n\t *\n\t * @param {Object} currentParams The value of the current state parameters ($stateParams).\n\t * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t * @param {Object} $current Internal definition of object representing the current state.\n\t * @param {Object} $to Internal definition of object representing state to transition to.\n\t */\n\tfunction inheritParams(currentParams, newParams, $current, $to) {\n\t  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t\n\t  for (var i in parents) {\n\t    if (!parents[i].params) continue;\n\t    parentParams = objectKeys(parents[i].params);\n\t    if (!parentParams.length) continue;\n\t\n\t    for (var j in parentParams) {\n\t      if (arraySearch(inheritList, parentParams[j]) >= 0) continue;\n\t      inheritList.push(parentParams[j]);\n\t      inherited[parentParams[j]] = currentParams[parentParams[j]];\n\t    }\n\t  }\n\t  return extend({}, inherited, newParams);\n\t}\n\t\n\t/**\n\t * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n\t *\n\t * @param {Object} a The first object.\n\t * @param {Object} b The second object.\n\t * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n\t *                     it defaults to the list of keys in `a`.\n\t * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n\t */\n\tfunction equalForKeys(a, b, keys) {\n\t  if (!keys) {\n\t    keys = [];\n\t    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n\t  }\n\t\n\t  for (var i=0; i<keys.length; i++) {\n\t    var k = keys[i];\n\t    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Returns the subset of an object, based on a list of keys.\n\t *\n\t * @param {Array} keys\n\t * @param {Object} values\n\t * @return {Boolean} Returns a subset of `values`.\n\t */\n\tfunction filterByKeys(keys, values) {\n\t  var filtered = {};\n\t\n\t  forEach(keys, function (name) {\n\t    filtered[name] = values[name];\n\t  });\n\t  return filtered;\n\t}\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.util\n\t *\n\t * @description\n\t * # ui.router.util sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t *\n\t */\n\tangular.module('ui.router.util', ['ng']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.router\n\t * \n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.router sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t */\n\tangular.module('ui.router.router', ['ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.state\n\t * \n\t * @requires ui.router.router\n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.state sub-module\n\t *\n\t * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t * \n\t */\n\tangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router\n\t *\n\t * @requires ui.router.state\n\t *\n\t * @description\n\t * # ui.router\n\t * \n\t * ## The main module for ui.router \n\t * There are several sub-modules included with the ui.router module, however only this module is needed\n\t * as a dependency within your angular app. The other modules are for organization purposes. \n\t *\n\t * The modules are:\n\t * * ui.router - the main \"umbrella\" module\n\t * * ui.router.router - \n\t * \n\t * *You'll need to include **only** this module as the dependency within your angular app.*\n\t * \n\t * <pre>\n\t * <!doctype html>\n\t * <html ng-app=\"myApp\">\n\t * <head>\n\t *   <script src=\"js/angular.js\"></script>\n\t *   <!-- Include the ui-router script -->\n\t *   <script src=\"js/angular-ui-router.min.js\"></script>\n\t *   <script>\n\t *     // ...and add 'ui.router' as a dependency\n\t *     var myApp = angular.module('myApp', ['ui.router']);\n\t *   </script>\n\t * </head>\n\t * <body>\n\t * </body>\n\t * </html>\n\t * </pre>\n\t */\n\tangular.module('ui.router', ['ui.router.state']);\n\t\n\tangular.module('ui.router.compat', ['ui.router']);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$resolve\n\t *\n\t * @requires $q\n\t * @requires $injector\n\t *\n\t * @description\n\t * Manages resolution of (acyclic) graphs of promises.\n\t */\n\t$Resolve.$inject = ['$q', '$injector'];\n\tfunction $Resolve(  $q,    $injector) {\n\t  \n\t  var VISIT_IN_PROGRESS = 1,\n\t      VISIT_DONE = 2,\n\t      NOTHING = {},\n\t      NO_DEPENDENCIES = [],\n\t      NO_LOCALS = NOTHING,\n\t      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n\t  \n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#study\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Studies a set of invocables that are likely to be used multiple times.\n\t   * <pre>\n\t   * $resolve.study(invocables)(locals, parent, self)\n\t   * </pre>\n\t   * is equivalent to\n\t   * <pre>\n\t   * $resolve.resolve(invocables, locals, parent, self)\n\t   * </pre>\n\t   * but the former is more efficient (in fact `resolve` just calls `study` \n\t   * internally).\n\t   *\n\t   * @param {object} invocables Invocable objects\n\t   * @return {function} a function to pass in locals, parent and self\n\t   */\n\t  this.study = function (invocables) {\n\t    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n\t    \n\t    // Perform a topological sort of invocables to build an ordered plan\n\t    var plan = [], cycle = [], visited = {};\n\t    function visit(value, key) {\n\t      if (visited[key] === VISIT_DONE) return;\n\t      \n\t      cycle.push(key);\n\t      if (visited[key] === VISIT_IN_PROGRESS) {\n\t        cycle.splice(0, cycle.indexOf(key));\n\t        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n\t      }\n\t      visited[key] = VISIT_IN_PROGRESS;\n\t      \n\t      if (isString(value)) {\n\t        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n\t      } else {\n\t        var params = $injector.annotate(value);\n\t        forEach(params, function (param) {\n\t          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n\t        });\n\t        plan.push(key, value, params);\n\t      }\n\t      \n\t      cycle.pop();\n\t      visited[key] = VISIT_DONE;\n\t    }\n\t    forEach(invocables, visit);\n\t    invocables = cycle = visited = null; // plan is all that's required\n\t    \n\t    function isResolve(value) {\n\t      return isObject(value) && value.then && value.$$promises;\n\t    }\n\t    \n\t    return function (locals, parent, self) {\n\t      if (isResolve(locals) && self === undefined) {\n\t        self = parent; parent = locals; locals = null;\n\t      }\n\t      if (!locals) locals = NO_LOCALS;\n\t      else if (!isObject(locals)) {\n\t        throw new Error(\"'locals' must be an object\");\n\t      }       \n\t      if (!parent) parent = NO_PARENT;\n\t      else if (!isResolve(parent)) {\n\t        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n\t      }\n\t      \n\t      // To complete the overall resolution, we have to wait for the parent\n\t      // promise and for the promise for each invokable in our plan.\n\t      var resolution = $q.defer(),\n\t          result = resolution.promise,\n\t          promises = result.$$promises = {},\n\t          values = extend({}, locals),\n\t          wait = 1 + plan.length/3,\n\t          merged = false;\n\t          \n\t      function done() {\n\t        // Merge parent values we haven't got yet and publish our own $$values\n\t        if (!--wait) {\n\t          if (!merged) merge(values, parent.$$values); \n\t          result.$$values = values;\n\t          result.$$promises = true; // keep for isResolve()\n\t          delete result.$$inheritedValues;\n\t          resolution.resolve(values);\n\t        }\n\t      }\n\t      \n\t      function fail(reason) {\n\t        result.$$failure = reason;\n\t        resolution.reject(reason);\n\t      }\n\t      \n\t      // Short-circuit if parent has already failed\n\t      if (isDefined(parent.$$failure)) {\n\t        fail(parent.$$failure);\n\t        return result;\n\t      }\n\t      \n\t      if (parent.$$inheritedValues) {\n\t        merge(values, parent.$$inheritedValues);\n\t      }\n\t\n\t      // Merge parent values if the parent has already resolved, or merge\n\t      // parent promises and wait if the parent resolve is still in progress.\n\t      if (parent.$$values) {\n\t        merged = merge(values, parent.$$values);\n\t        result.$$inheritedValues = parent.$$values;\n\t        done();\n\t      } else {\n\t        if (parent.$$inheritedValues) {\n\t          result.$$inheritedValues = parent.$$inheritedValues;\n\t        }        \n\t        extend(promises, parent.$$promises);\n\t        parent.then(done, fail);\n\t      }\n\t      \n\t      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n\t      for (var i=0, ii=plan.length; i<ii; i+=3) {\n\t        if (locals.hasOwnProperty(plan[i])) done();\n\t        else invoke(plan[i], plan[i+1], plan[i+2]);\n\t      }\n\t      \n\t      function invoke(key, invocable, params) {\n\t        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n\t        var invocation = $q.defer(), waitParams = 0;\n\t        function onfailure(reason) {\n\t          invocation.reject(reason);\n\t          fail(reason);\n\t        }\n\t        // Wait for any parameter that we have a promise for (either from parent or from this\n\t        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n\t        forEach(params, function (dep) {\n\t          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n\t            waitParams++;\n\t            promises[dep].then(function (result) {\n\t              values[dep] = result;\n\t              if (!(--waitParams)) proceed();\n\t            }, onfailure);\n\t          }\n\t        });\n\t        if (!waitParams) proceed();\n\t        function proceed() {\n\t          if (isDefined(result.$$failure)) return;\n\t          try {\n\t            invocation.resolve($injector.invoke(invocable, self, values));\n\t            invocation.promise.then(function (result) {\n\t              values[key] = result;\n\t              done();\n\t            }, onfailure);\n\t          } catch (e) {\n\t            onfailure(e);\n\t          }\n\t        }\n\t        // Publish promise synchronously; invocations further down in the plan may depend on it.\n\t        promises[key] = invocation.promise;\n\t      }\n\t      \n\t      return result;\n\t    };\n\t  };\n\t  \n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#resolve\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Resolves a set of invocables. An invocable is a function to be invoked via \n\t   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n\t   * An invocable can either return a value directly,\n\t   * or a `$q` promise. If a promise is returned it will be resolved and the \n\t   * resulting value will be used instead. Dependencies of invocables are resolved \n\t   * (in this order of precedence)\n\t   *\n\t   * - from the specified `locals`\n\t   * - from another invocable that is part of this `$resolve` call\n\t   * - from an invocable that is inherited from a `parent` call to `$resolve` \n\t   *   (or recursively\n\t   * - from any ancestor `$resolve` of that parent).\n\t   *\n\t   * The return value of `$resolve` is a promise for an object that contains \n\t   * (in this order of precedence)\n\t   *\n\t   * - any `locals` (if specified)\n\t   * - the resolved return values of all injectables\n\t   * - any values inherited from a `parent` call to `$resolve` (if specified)\n\t   *\n\t   * The promise will resolve after the `parent` promise (if any) and all promises \n\t   * returned by injectables have been resolved. If any invocable \n\t   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n\t   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n\t   * same error. A rejection of a `parent` promise (if specified) will likewise be \n\t   * propagated immediately. Once the `$resolve` promise has been rejected, no \n\t   * further invocables will be called.\n\t   * \n\t   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n\t   * to throw an error. As a special case, an injectable can depend on a parameter \n\t   * with the same name as the injectable, which will be fulfilled from the `parent` \n\t   * injectable of the same name. This allows inherited values to be decorated. \n\t   * Note that in this case any other injectable in the same `$resolve` with the same\n\t   * dependency would see the decorated value, not the inherited value.\n\t   *\n\t   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n\t   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n\t   * exception.\n\t   *\n\t   * Invocables are invoked eagerly as soon as all dependencies are available. \n\t   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n\t   *\n\t   * As a special case, an invocable can be a string, in which case it is taken to \n\t   * be a service name to be passed to `$injector.get()`. This is supported primarily \n\t   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n\t   * routes.\n\t   *\n\t   * @param {object} invocables functions to invoke or \n\t   * `$injector` services to fetch.\n\t   * @param {object} locals  values to make available to the injectables\n\t   * @param {object} parent  a promise returned by another call to `$resolve`.\n\t   * @param {object} self  the `this` for the invoked methods\n\t   * @return {object} Promise for an object that contains the resolved return value\n\t   * of all invocables, as well as any inherited and local values.\n\t   */\n\t  this.resolve = function (invocables, locals, parent, self) {\n\t    return this.study(invocables)(locals, parent, self);\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$resolve', $Resolve);\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$templateFactory\n\t *\n\t * @requires $http\n\t * @requires $templateCache\n\t * @requires $injector\n\t *\n\t * @description\n\t * Service. Manages loading of templates.\n\t */\n\t$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\n\tfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromConfig\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a configuration object. \n\t   *\n\t   * @param {object} config Configuration object for which to load a template. \n\t   * The following properties are search in the specified order, and the first one \n\t   * that is defined is used to create the template:\n\t   *\n\t   * @param {string|object} config.template html string template or function to \n\t   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n\t   * @param {string|object} config.templateUrl url to load or a function returning \n\t   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n\t   * @param {Function} config.templateProvider function to invoke via \n\t   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n\t   * @param {object} params  Parameters to pass to the template function.\n\t   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n\t   * via a `templateProvider`. Defaults to `{ params: params }`.\n\t   *\n\t   * @return {string|object}  The template html as a string, or a promise for \n\t   * that string,or `null` if no template is configured.\n\t   */\n\t  this.fromConfig = function (config, params, locals) {\n\t    return (\n\t      isDefined(config.template) ? this.fromString(config.template, params) :\n\t      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n\t      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n\t      null\n\t    );\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromString\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a string or a function returning a string.\n\t   *\n\t   * @param {string|object} template html template as a string or function that \n\t   * returns an html template as a string.\n\t   * @param {object} params Parameters to pass to the template function.\n\t   *\n\t   * @return {string|object} The template html as a string, or a promise for that \n\t   * string.\n\t   */\n\t  this.fromString = function (template, params) {\n\t    return isFunction(template) ? template(params) : template;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromUrl\n\t   * @methodOf ui.router.util.$templateFactory\n\t   * \n\t   * @description\n\t   * Loads a template from the a URL via `$http` and `$templateCache`.\n\t   *\n\t   * @param {string|Function} url url of the template to load, or a function \n\t   * that returns a url.\n\t   * @param {Object} params Parameters to pass to the url function.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromUrl = function (url, params) {\n\t    if (isFunction(url)) url = url(params);\n\t    if (url == null) return null;\n\t    else return $http\n\t        .get(url, { cache: $templateCache })\n\t        .then(function(response) { return response.data; });\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromProvider\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template by invoking an injectable provider function.\n\t   *\n\t   * @param {Function} provider Function to invoke via `$injector.invoke`\n\t   * @param {Object} params Parameters for the template.\n\t   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n\t   * `{ params: params }`.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromProvider = function (provider, params, locals) {\n\t    return $injector.invoke(provider, null, locals || { params: params });\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n\t * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n\t * \n\t * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n\t * syntax, which optionally allows a regular expression for the parameter to be specified:\n\t *\n\t * * `':'` name - colon placeholder\n\t * * `'*'` name - catch-all placeholder\n\t * * `'{' name '}'` - curly placeholder\n\t * * `'{' name ':' regexp '}'` - curly placeholder with regexp. Should the regexp itself contain\n\t *   curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters). For colon \n\t * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n\t * number of characters other than '/'. For catch-all placeholders the path parameter matches\n\t * any number of characters.\n\t * \n\t * Examples:\n\t * \n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t *\n\t * @param {string} pattern  The pattern to compile into a matcher.\n\t * @param {Object} config  A configuration object hash:\n\t *\n\t * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t *\n\t * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n\t *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n\t *   non-null) will start with this prefix.\n\t *\n\t * @property {string} source  The pattern that was passed into the constructor\n\t *\n\t * @property {string} sourcePath  The path portion of the source property\n\t *\n\t * @property {string} sourceSearch  The search portion of the source property\n\t *\n\t * @property {string} regex  The constructed regex that will be used to match against the url when \n\t *   it is time to determine which url will match.\n\t *\n\t * @returns {Object}  New `UrlMatcher` object\n\t */\n\tfunction UrlMatcher(pattern, config) {\n\t  config = angular.isObject(config) ? config : {};\n\t\n\t  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t  //   '*' name\n\t  //   ':' name\n\t  //   '{' name '}'\n\t  //   '{' name ':' regexp '}'\n\t  // The regular expression is somewhat complicated due to the need to allow curly braces\n\t  // inside the regular expression. The placeholder regexp breaks down as follows:\n\t  //    ([:*])(\\w+)               classic placeholder ($1 / $2)\n\t  //    \\{(\\w+)(?:\\:( ... ))?\\}   curly brace placeholder ($3) with optional regexp ... ($4)\n\t  //    (?: ... | ... | ... )+    the regexp consists of any number of atoms, an atom being either\n\t  //    [^{}\\\\]+                  - anything other than curly braces or backslash\n\t  //    \\\\.                       - a backslash escape\n\t  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}     - a matched set of curly braces containing other atoms\n\t  var placeholder = /([:*])(\\w+)|\\{(\\w+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      compiled = '^', last = 0, m,\n\t      segments = this.segments = [],\n\t      params = this.params = {};\n\t\n\t  /**\n\t   * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t   * default value, which may be the result of an injectable function.\n\t   */\n\t  function $value(value) {\n\t    /*jshint validthis: true */\n\t    return isDefined(value) ? this.type.decode(value) : $UrlMatcherFactory.$$getDefaultValue(this);\n\t  }\n\t\n\t  function addParameter(id, type, config) {\n\t    if (!/^\\w+(-+\\w+)*$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    params[id] = extend({ type: type || new Type(), $value: $value }, config);\n\t  }\n\t\n\t  function quoteRegExp(string, pattern, isOptional) {\n\t    var result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!pattern) return result;\n\t    var flag = isOptional ? '?' : '';\n\t    return result + flag + '(' + pattern + ')' + flag;\n\t  }\n\t\n\t  function paramConfig(param) {\n\t    if (!config.params || !config.params[param]) return {};\n\t    var cfg = config.params[param];\n\t    return isObject(cfg) ? cfg : { value: cfg };\n\t  }\n\t\n\t  this.source = pattern;\n\t\n\t  // Split into static segments separated by path parameter placeholders.\n\t  // The number of segments is always 1 more than the number of parameters.\n\t  var id, regexp, segment, type, cfg;\n\t\n\t  while ((m = placeholder.exec(pattern))) {\n\t    id      = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n\t    regexp  = m[4] || (m[1] == '*' ? '.*' : '[^/]*');\n\t    segment = pattern.substring(last, m.index);\n\t    type    = this.$types[regexp] || new Type({ pattern: new RegExp(regexp) });\n\t    cfg     = paramConfig(id);\n\t\n\t    if (segment.indexOf('?') >= 0) break; // we're into the search part\n\t\n\t    compiled += quoteRegExp(segment, type.$subPattern(), isDefined(cfg.value));\n\t    addParameter(id, type, cfg);\n\t    segments.push(segment);\n\t    last = placeholder.lastIndex;\n\t  }\n\t  segment = pattern.substring(last);\n\t\n\t  // Find any search parameter names and remove them from the last segment\n\t  var i = segment.indexOf('?');\n\t\n\t  if (i >= 0) {\n\t    var search = this.sourceSearch = segment.substring(i);\n\t    segment = segment.substring(0, i);\n\t    this.sourcePath = pattern.substring(0, last + i);\n\t\n\t    // Allow parameters to be separated by '?' as well as '&' to make concat() easier\n\t    forEach(search.substring(1).split(/[&?]/), function(key) {\n\t      addParameter(key, null, paramConfig(key));\n\t    });\n\t  } else {\n\t    this.sourcePath = pattern;\n\t    this.sourceSearch = '';\n\t  }\n\t\n\t  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n\t  segments.push(segment);\n\t\n\t  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n\t  this.prefix = segments[0];\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#concat\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns a new matcher for a pattern constructed by appending the path part and adding the\n\t * search parameters of the specified pattern to this pattern. The current pattern is not\n\t * modified. This can be understood as creating a pattern for URLs that are relative to (or\n\t * suffixes of) the current pattern.\n\t *\n\t * @example\n\t * The following two matchers are equivalent:\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').concat('/details?date');\n\t * new UrlMatcher('/user/{id}/details?q&date');\n\t * </pre>\n\t *\n\t * @param {string} pattern  The pattern to append.\n\t * @param {Object} config  An object hash of the configuration for the matcher.\n\t * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n\t */\n\tUrlMatcher.prototype.concat = function (pattern, config) {\n\t  // Because order of search parameters is irrelevant, we can add our own search\n\t  // parameters to the end of the new pattern. Parse the new pattern by itself\n\t  // and then join the bits together, but it's much easier to do this on a string level.\n\t  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, config);\n\t};\n\t\n\tUrlMatcher.prototype.toString = function () {\n\t  return this.source;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#exec\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Tests the specified path against this matcher, and returns an object containing the captured\n\t * parameter values, or null if the path does not match. The returned object contains the values\n\t * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t * they are not present in `searchParams`. This means that search parameters are always treated\n\t * as optional.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t *   x: '1', q: 'hello'\n\t * });\n\t * // returns { id: 'bob', q: 'hello', r: null }\n\t * </pre>\n\t *\n\t * @param {string} path  The URL path to match, e.g. `$location.path()`.\n\t * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n\t * @returns {Object}  The captured parameter values.\n\t */\n\tUrlMatcher.prototype.exec = function (path, searchParams) {\n\t  var m = this.regexp.exec(path);\n\t  if (!m) return null;\n\t  searchParams = searchParams || {};\n\t\n\t  var params = this.parameters(), nTotal = params.length,\n\t    nPath = this.segments.length - 1,\n\t    values = {}, i, cfg, param;\n\t\n\t  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\t\n\t  for (i = 0; i < nPath; i++) {\n\t    param = params[i];\n\t    cfg = this.params[param];\n\t    values[param] = cfg.$value(m[i + 1]);\n\t  }\n\t  for (/**/; i < nTotal; i++) {\n\t    param = params[i];\n\t    cfg = this.params[param];\n\t    values[param] = cfg.$value(searchParams[param]);\n\t  }\n\t\n\t  return values;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#parameters\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns the names of all path and search parameters of this pattern in an unspecified order.\n\t * \n\t * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n\t *    pattern has no parameters, an empty array is returned.\n\t */\n\tUrlMatcher.prototype.parameters = function (param) {\n\t  if (!isDefined(param)) return objectKeys(this.params);\n\t  return this.params[param] || null;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#validate\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Checks an object hash of parameters to validate their correctness according to the parameter\n\t * types of this `UrlMatcher`.\n\t *\n\t * @param {Object} params The object hash of parameters to validate.\n\t * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n\t */\n\tUrlMatcher.prototype.validates = function (params) {\n\t  var result = true, isOptional, cfg, self = this;\n\t\n\t  forEach(params, function(val, key) {\n\t    if (!self.params[key]) return;\n\t    cfg = self.params[key];\n\t    isOptional = !val && isDefined(cfg.value);\n\t    result = result && (isOptional || cfg.type.is(val));\n\t  });\n\t  return result;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#format\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Creates a URL that matches this pattern by substituting the specified values\n\t * for the path and search parameters. Null values for path parameters are\n\t * treated as empty strings.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t * // returns '/user/bob?q=yes'\n\t * </pre>\n\t *\n\t * @param {Object} values  the values to substitute for the parameters in this pattern.\n\t * @returns {string}  the formatted URL (path and optionally search part).\n\t */\n\tUrlMatcher.prototype.format = function (values) {\n\t  var segments = this.segments, params = this.parameters();\n\t\n\t  if (!values) return segments.join('').replace('//', '/');\n\t\n\t  var nPath = segments.length - 1, nTotal = params.length,\n\t    result = segments[0], i, search, value, param, cfg, array;\n\t\n\t  if (!this.validates(values)) return null;\n\t\n\t  for (i = 0; i < nPath; i++) {\n\t    param = params[i];\n\t    value = values[param];\n\t    cfg   = this.params[param];\n\t\n\t    if (!isDefined(value) && (segments[i] === '/' || segments[i + 1] === '/')) continue;\n\t    if (value != null) result += encodeURIComponent(cfg.type.encode(value));\n\t    result += segments[i + 1];\n\t  }\n\t\n\t  for (/**/; i < nTotal; i++) {\n\t    param = params[i];\n\t    value = values[param];\n\t    if (value == null) continue;\n\t    array = isArray(value);\n\t\n\t    if (array) {\n\t      value = value.map(encodeURIComponent).join('&' + param + '=');\n\t    }\n\t    result += (search ? '&' : '?') + param + '=' + (array ? value : encodeURIComponent(value));\n\t    search = true;\n\t  }\n\t  return result;\n\t};\n\t\n\tUrlMatcher.prototype.$types = {};\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:Type\n\t *\n\t * @description\n\t * Implements an interface to define custom parameter types that can be decoded from and encoded to\n\t * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n\t * objects when matching or formatting URLs, or comparing or validating parameter values.\n\t *\n\t * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n\t * information on registering custom types.\n\t *\n\t * @param {Object} config  A configuration object hash that includes any method in `Type`'s public\n\t *        interface, and/or `pattern`, which should contain a custom regular expression used to match\n\t *        string parameters originating from a URL.\n\t *\n\t * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n\t *           coming from a substring of a URL.\n\t *\n\t * @returns {Object}  Returns a new `Type` object.\n\t */\n\tfunction Type(config) {\n\t  extend(this, config);\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#is\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Detects whether a value is of a particular type. Accepts a native (decoded) value\n\t * and determines whether it matches the current `Type` object.\n\t *\n\t * @param {*} val  The value to check.\n\t * @param {string} key  Optional. If the type check is happening in the context of a specific\n\t *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n\t *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n\t * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n\t */\n\tType.prototype.is = function(val, key) {\n\t  return true;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#encode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n\t * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n\t * only needs to be a representation of `val` that has been coerced to a string.\n\t *\n\t * @param {*} val  The value to encode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n\t */\n\tType.prototype.encode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#decode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Converts a string URL parameter value to a custom/native value.\n\t *\n\t * @param {string} val  The URL parameter value to decode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {*}  Returns a custom representation of the URL parameter value.\n\t */\n\tType.prototype.decode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#equals\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Determines whether two decoded values are equivalent.\n\t *\n\t * @param {*} a  A value to compare against.\n\t * @param {*} b  A value to compare against.\n\t * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n\t */\n\tType.prototype.equals = function(a, b) {\n\t  return a == b;\n\t};\n\t\n\tType.prototype.$subPattern = function() {\n\t  var sub = this.pattern.toString();\n\t  return sub.substr(1, sub.length - 2);\n\t};\n\t\n\tType.prototype.pattern = /.*/;\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$urlMatcherFactory\n\t *\n\t * @description\n\t * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n\t * is also available to providers under the name `$urlMatcherFactoryProvider`.\n\t */\n\tfunction $UrlMatcherFactory() {\n\t\n\t  var isCaseInsensitive = false, isStrictMode = true;\n\t\n\t  var enqueue = true, typeQueue = [], injector, defaultTypes = {\n\t    int: {\n\t      decode: function(val) {\n\t        return parseInt(val, 10);\n\t      },\n\t      is: function(val) {\n\t        if (!isDefined(val)) return false;\n\t        return this.decode(val.toString()) === val;\n\t      },\n\t      pattern: /\\d+/\n\t    },\n\t    bool: {\n\t      encode: function(val) {\n\t        return val ? 1 : 0;\n\t      },\n\t      decode: function(val) {\n\t        return parseInt(val, 10) === 0 ? false : true;\n\t      },\n\t      is: function(val) {\n\t        return val === true || val === false;\n\t      },\n\t      pattern: /0|1/\n\t    },\n\t    string: {\n\t      pattern: /[^\\/]*/\n\t    },\n\t    date: {\n\t      equals: function (a, b) {\n\t        return a.toISOString() === b.toISOString();\n\t      },\n\t      decode: function (val) {\n\t        return new Date(val);\n\t      },\n\t      encode: function (val) {\n\t        return [\n\t          val.getFullYear(),\n\t          ('0' + (val.getMonth() + 1)).slice(-2),\n\t          ('0' + val.getDate()).slice(-2)\n\t        ].join(\"-\");\n\t      },\n\t      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/\n\t    }\n\t  };\n\t\n\t  function getDefaultConfig() {\n\t    return {\n\t      strict: isStrictMode,\n\t      caseInsensitive: isCaseInsensitive\n\t    };\n\t  }\n\t\n\t  function isInjectable(value) {\n\t    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n\t  }\n\t\n\t  /**\n\t   * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t   */\n\t  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n\t    if (!isInjectable(config.value)) return config.value;\n\t    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t    return injector.invoke(config.value);\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n\t   *\n\t   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n\t   */\n\t  this.caseInsensitive = function(value) {\n\t    isCaseInsensitive = value;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#strictMode\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n\t   *\n\t   * @param {boolean} value `false` to match trailing slashes in URLs, otherwise `true`.\n\t   */\n\t  this.strictMode = function(value) {\n\t    isStrictMode = value;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#compile\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n\t   *   \n\t   * @param {string} pattern  The URL pattern.\n\t   * @param {Object} config  The config object hash.\n\t   * @returns {UrlMatcher}  The UrlMatcher.\n\t   */\n\t  this.compile = function (pattern, config) {\n\t    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#isMatcher\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n\t   *\n\t   * @param {Object} object  The object to perform the type check against.\n\t   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n\t   *          implementing all the same methods.\n\t   */\n\t  this.isMatcher = function (o) {\n\t    if (!isObject(o)) return false;\n\t    var result = true;\n\t\n\t    forEach(UrlMatcher.prototype, function(val, name) {\n\t      if (isFunction(val)) {\n\t        result = result && (isDefined(o[name]) && isFunction(o[name]));\n\t      }\n\t    });\n\t    return result;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#type\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n\t   * generate URLs with typed parameters.\n\t   *\n\t   * @param {string} name  The type name.\n\t   * @param {Object|Function} def  The type definition. See\n\t   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   *\n\t   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n\t   *\n\t   * @example\n\t   * This is a simple example of a custom type that encodes and decodes items from an\n\t   * array, using the array index as the URL-encoded value:\n\t   *\n\t   * <pre>\n\t   * var list = ['John', 'Paul', 'George', 'Ringo'];\n\t   *\n\t   * $urlMatcherFactoryProvider.type('listItem', {\n\t   *   encode: function(item) {\n\t   *     // Represent the list item in the URL using its corresponding index\n\t   *     return list.indexOf(item);\n\t   *   },\n\t   *   decode: function(item) {\n\t   *     // Look up the list item by index\n\t   *     return list[parseInt(item, 10)];\n\t   *   },\n\t   *   is: function(item) {\n\t   *     // Ensure the item is valid by checking to see that it appears\n\t   *     // in the list\n\t   *     return list.indexOf(item) > -1;\n\t   *   }\n\t   * });\n\t   *\n\t   * $stateProvider.state('list', {\n\t   *   url: \"/list/{item:listItem}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     console.log($stateParams.item);\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n\t   * $state.go('list', { item: \"Ringo\" });\n\t   * </pre>\n\t   *\n\t   * This is a more complex example of a type that relies on dependency injection to\n\t   * interact with services, and uses the parameter name from the URL to infer how to\n\t   * handle encoding and decoding parameter values:\n\t   *\n\t   * <pre>\n\t   * // Defines a custom type that gets a value from a service,\n\t   * // where each service gets different types of values from\n\t   * // a backend API:\n\t   * $urlMatcherFactoryProvider.type('dbObject', function(Users, Posts) {\n\t   *\n\t   *   // Matches up services to URL parameter names\n\t   *   var services = {\n\t   *     user: Users,\n\t   *     post: Posts\n\t   *   };\n\t   *\n\t   *   return {\n\t   *     encode: function(object) {\n\t   *       // Represent the object in the URL using its unique ID\n\t   *       return object.id;\n\t   *     },\n\t   *     decode: function(value, key) {\n\t   *       // Look up the object by ID, using the parameter\n\t   *       // name (key) to call the correct service\n\t   *       return services[key].findById(value);\n\t   *     },\n\t   *     is: function(object, key) {\n\t   *       // Check that object is a valid dbObject\n\t   *       return angular.isObject(object) && object.id && services[key];\n\t   *     }\n\t   *     equals: function(a, b) {\n\t   *       // Check the equality of decoded objects by comparing\n\t   *       // their unique IDs\n\t   *       return a.id === b.id;\n\t   *     }\n\t   *   };\n\t   * });\n\t   *\n\t   * // In a config() block, you can then attach URLs with\n\t   * // type-annotated parameters:\n\t   * $stateProvider.state('users', {\n\t   *   url: \"/users\",\n\t   *   // ...\n\t   * }).state('users.item', {\n\t   *   url: \"/{user:dbObject}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     // $stateParams.user will now be an object returned from\n\t   *     // the Users service\n\t   *   },\n\t   *   // ...\n\t   * });\n\t   * </pre>\n\t   */\n\t  this.type = function (name, def) {\n\t    if (!isDefined(def)) return UrlMatcher.prototype.$types[name];\n\t    typeQueue.push({ name: name, def: def });\n\t    if (!enqueue) flushTypeQueue();\n\t    return this;\n\t  };\n\t\n\t  /* No need to document $get, since it returns this */\n\t  this.$get = ['$injector', function ($injector) {\n\t    injector = $injector;\n\t    enqueue = false;\n\t    UrlMatcher.prototype.$types = {};\n\t    flushTypeQueue();\n\t\n\t    forEach(defaultTypes, function(type, name) {\n\t      if (!UrlMatcher.prototype.$types[name]) UrlMatcher.prototype.$types[name] = new Type(type);\n\t    });\n\t    return this;\n\t  }];\n\t\n\t  // To ensure proper order of operations in object configuration, and to allow internal\n\t  // types to be overridden, `flushTypeQueue()` waits until `$urlMatcherFactory` is injected\n\t  // before actually wiring up and assigning type definitions\n\t  function flushTypeQueue() {\n\t    forEach(typeQueue, function(type) {\n\t      if (UrlMatcher.prototype.$types[type.name]) {\n\t        throw new Error(\"A type named '\" + type.name + \"' has already been defined.\");\n\t      }\n\t      var def = new Type(isInjectable(type.def) ? injector.invoke(type.def) : type.def);\n\t      UrlMatcher.prototype.$types[type.name] = def;\n\t    });\n\t  }\n\t}\n\t\n\t// Register as a provider so it's available to other providers\n\tangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.router.$urlRouterProvider\n\t *\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t * @requires $locationProvider\n\t *\n\t * @description\n\t * `$urlRouterProvider` has the responsibility of watching `$location`. \n\t * When `$location` changes it runs through a list of rules one by one until a \n\t * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n\t * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n\t *\n\t * There are several methods on `$urlRouterProvider` that make it useful to use directly\n\t * in your module config.\n\t */\n\t$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\n\tfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n\t  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\t\n\t  // Returns a string that is a prefix of all strings matching the RegExp\n\t  function regExpPrefix(re) {\n\t    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n\t    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n\t  }\n\t\n\t  // Interpolates matched values into a String.replace()-style pattern\n\t  function interpolate(pattern, match) {\n\t    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t      return match[what === '$' ? 0 : Number(what)];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#rule\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines rules that are used by `$urlRouterProvider` to find matches for\n\t   * specific URLs.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // Here's an example of how you might allow case insensitive urls\n\t   *   $urlRouterProvider.rule(function ($injector, $location) {\n\t   *     var path = $location.path(),\n\t   *         normalized = path.toLowerCase();\n\t   *\n\t   *     if (path !== normalized) {\n\t   *       return normalized;\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {object} rule Handler function that takes `$injector` and `$location`\n\t   * services as arguments. You can use them to return a valid path as a string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.rule = function (rule) {\n\t    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    rules.push(rule);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouterProvider#otherwise\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines a path that is used when an invalid route is requested.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // if the path doesn't match any of the urls you configured\n\t   *   // otherwise will take care of routing the user to the\n\t   *   // specified url\n\t   *   $urlRouterProvider.otherwise('/index');\n\t   *\n\t   *   // Example of using function rule as param\n\t   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t   *     return '/a/valid/url';\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} rule The url path you want to redirect to or a function \n\t   * rule that returns the url path. The function version is passed two params: \n\t   * `$injector` and `$location` services, and must return a url string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.otherwise = function (rule) {\n\t    if (isString(rule)) {\n\t      var redirect = rule;\n\t      rule = function () { return redirect; };\n\t    }\n\t    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    otherwise = rule;\n\t    return this;\n\t  };\n\t\n\t\n\t  function handleIfMatch($injector, handler, match) {\n\t    if (!match) return false;\n\t    var result = $injector.invoke(handler, handler, { $match: match });\n\t    return isDefined(result) ? result : true;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#when\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Registers a handler for a given url matching. if handle is a string, it is\n\t   * treated as a redirect, and is interpolated according to the syntax of match\n\t   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t   *\n\t   * If the handler is a function, it is injectable. It gets invoked if `$location`\n\t   * matches. You have the option of inject the match object as `$match`.\n\t   *\n\t   * The handler can return\n\t   *\n\t   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t   *   will continue trying to find another one that matches.\n\t   * - **string** which is treated as a redirect and passed to `$location.url()`\n\t   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t   *     if ($state.$current.navigable !== state ||\n\t   *         !equalForKeys($match, $stateParams) {\n\t   *      $state.transitionTo(state, $match, false);\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} what The incoming path that you want to redirect.\n\t   * @param {string|object} handler The path you want to redirect your user to.\n\t   */\n\t  this.when = function (what, handler) {\n\t    var redirect, handlerIsString = isString(handler);\n\t    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\t\n\t    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n\t      throw new Error(\"invalid 'handler' in when()\");\n\t\n\t    var strategies = {\n\t      matcher: function (what, handler) {\n\t        if (handlerIsString) {\n\t          redirect = $urlMatcherFactory.compile(handler);\n\t          handler = ['$match', function ($match) { return redirect.format($match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n\t        }, {\n\t          prefix: isString(what.prefix) ? what.prefix : ''\n\t        });\n\t      },\n\t      regex: function (what, handler) {\n\t        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\t\n\t        if (handlerIsString) {\n\t          redirect = handler;\n\t          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path()));\n\t        }, {\n\t          prefix: regExpPrefix(what)\n\t        });\n\t      }\n\t    };\n\t\n\t    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\t\n\t    for (var n in check) {\n\t      if (check[n]) return this.rule(strategies[n](what, handler));\n\t    }\n\t\n\t    throw new Error(\"invalid 'what' in when()\");\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#deferIntercept\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Disables (or enables) deferring location change interception.\n\t   *\n\t   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n\t   * defer a transition but maintain the current URL), call this method at configuration time.\n\t   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n\t   * `$locationChangeSuccess` event handler.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *\n\t   *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t   *   // this allows you to configure custom behavior in between\n\t   *   // location changes and route synchronization:\n\t   *   $urlRouterProvider.deferIntercept();\n\t   *\n\t   * }).run(function ($rootScope, $urlRouter, UserService) {\n\t   *\n\t   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n\t   *     // UserService is an example service for managing user state\n\t   *     if (UserService.isLoggedIn()) return;\n\t   *\n\t   *     // Prevent $urlRouter's default handler from firing\n\t   *     e.preventDefault();\n\t   *\n\t   *     UserService.handleLogin().then(function() {\n\t   *       // Once the user has logged in, sync the current URL\n\t   *       // to the router:\n\t   *       $urlRouter.sync();\n\t   *     });\n\t   *   });\n\t   *\n\t   *   // Configures $urlRouter's listener *after* your custom listener\n\t   *   $urlRouter.listen();\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n\t            no parameter is equivalent to `true`.\n\t   */\n\t  this.deferIntercept = function (defer) {\n\t    if (defer === undefined) defer = true;\n\t    interceptDeferred = defer;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouter\n\t   *\n\t   * @requires $location\n\t   * @requires $rootScope\n\t   * @requires $injector\n\t   * @requires $browser\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];\n\t  function $get(   $location,   $rootScope,   $injector,   $browser) {\n\t\n\t    var baseHref = $browser.baseHref(), location = $location.url();\n\t\n\t    function appendBasePath(url, isHtml5, absolute) {\n\t      if (baseHref === '/') return url;\n\t      if (isHtml5) return baseHref.slice(0, -1) + url;\n\t      if (absolute) return baseHref.slice(1) + url;\n\t      return url;\n\t    }\n\t\n\t    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n\t    function update(evt) {\n\t      if (evt && evt.defaultPrevented) return;\n\t\n\t      function check(rule) {\n\t        var handled = rule($injector, $location);\n\t\n\t        if (!handled) return false;\n\t        if (isString(handled)) $location.replace().url(handled);\n\t        return true;\n\t      }\n\t      var n = rules.length, i;\n\t\n\t      for (i = 0; i < n; i++) {\n\t        if (check(rules[i])) return;\n\t      }\n\t      // always check otherwise last to allow dynamic updates to the set of rules\n\t      if (otherwise) check(otherwise);\n\t    }\n\t\n\t    function listen() {\n\t      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n\t      return listener;\n\t    }\n\t\n\t    if (!interceptDeferred) listen();\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#sync\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n\t       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n\t       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n\t       * with the transition by calling `$urlRouter.sync()`.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * angular.module('app', ['ui.router'])\n\t       *   .run(function($rootScope, $urlRouter) {\n\t       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n\t       *       // Halt state change from even starting\n\t       *       evt.preventDefault();\n\t       *       // Perform custom logic\n\t       *       var meetsRequirement = ...\n\t       *       // Continue with the update and state transition if logic allows\n\t       *       if (meetsRequirement) $urlRouter.sync();\n\t       *     });\n\t       * });\n\t       * </pre>\n\t       */\n\t      sync: function() {\n\t        update();\n\t      },\n\t\n\t      listen: function() {\n\t        return listen();\n\t      },\n\t\n\t      update: function(read) {\n\t        if (read) {\n\t          location = $location.url();\n\t          return;\n\t        }\n\t        if ($location.url() === location) return;\n\t\n\t        $location.url(location);\n\t        $location.replace();\n\t      },\n\t\n\t      push: function(urlMatcher, params, options) {\n\t        $location.url(urlMatcher.format(params || {}));\n\t        if (options && options.replace) $location.replace();\n\t      },\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#href\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * A URL generation method that returns the compiled URL for a given\n\t       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n\t       *   person: \"bob\"\n\t       * });\n\t       * // $bob == \"/about/bob\";\n\t       * </pre>\n\t       *\n\t       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n\t       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n\t       * @param {object=} options Options object. The options are:\n\t       *\n\t       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t       *\n\t       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t       */\n\t      href: function(urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params)) return null;\n\t\n\t        var isHtml5 = $locationProvider.html5Mode();\n\t        var url = urlMatcher.format(params);\n\t        options = options || {};\n\t\n\t        if (!isHtml5 && url !== null) {\n\t          url = \"#\" + $locationProvider.hashPrefix() + url;\n\t        }\n\t        url = appendBasePath(url, isHtml5, options.absolute);\n\t\n\t        if (!options.absolute || !url) {\n\t          return url;\n\t        }\n\t\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t\n\t        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$stateProvider\n\t *\n\t * @requires ui.router.router.$urlRouterProvider\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t *\n\t * @description\n\t * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t * on state.\n\t *\n\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t * navigation. A state describes (via the controller / template / view properties) what\n\t * the UI looks like and does at that place.\n\t *\n\t * States often have things in common, and the primary way of factoring out these\n\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t * nested states.\n\t *\n\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t */\n\t$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\n\tfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\t\n\t  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\t\n\t  // Builds state properties from definition passed to registerState()\n\t  var stateBuilder = {\n\t\n\t    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n\t    // state.children = [];\n\t    // if (parent) parent.children.push(state);\n\t    parent: function(state) {\n\t      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n\t      // regex matches any valid composite state name\n\t      // would match \"contact.list\" but not \"contacts\"\n\t      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n\t      return compositeName ? findState(compositeName[1]) : root;\n\t    },\n\t\n\t    // inherit 'data' from parent and override by own values (if any)\n\t    data: function(state) {\n\t      if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = extend({}, state.parent.data, state.data);\n\t      }\n\t      return state.data;\n\t    },\n\t\n\t    // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t    url: function(state) {\n\t      var url = state.url, config = { params: state.params || {} };\n\t\n\t      if (isString(url)) {\n\t        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n\t        return (state.parent.navigable || root).url.concat(url, config);\n\t      }\n\t\n\t      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n\t      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t    },\n\t\n\t    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t    navigable: function(state) {\n\t      return state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    },\n\t\n\t    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n\t    params: function(state) {\n\t      if (!state.params) {\n\t        return state.url ? state.url.params : state.parent.params;\n\t      }\n\t      return state.params;\n\t    },\n\t\n\t    // If there is no explicit multi-view configuration, make one up so we don't have\n\t    // to handle both cases in the view directive later. Note that having an explicit\n\t    // 'views' property will mean the default unnamed view properties are ignored. This\n\t    // is also a good time to resolve view names to absolute names, so everything is a\n\t    // straight lookup at link time.\n\t    views: function(state) {\n\t      var views = {};\n\t\n\t      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n\t        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n\t        views[name] = view;\n\t      });\n\t      return views;\n\t    },\n\t\n\t    ownParams: function(state) {\n\t      state.params = state.params || {};\n\t\n\t      if (!state.parent) {\n\t          return objectKeys(state.params);\n\t      }\n\t      var paramNames = {}; forEach(state.params, function (v, k) { paramNames[k] = true; });\n\t\n\t      forEach(state.parent.params, function (v, k) {\n\t        if (!paramNames[k]) {\n\t          throw new Error(\"Missing required parameter '\" + k + \"' in state '\" + state.name + \"'\");\n\t        }\n\t        paramNames[k] = false;\n\t      });\n\t      var ownParams = [];\n\t\n\t      forEach(paramNames, function (own, p) {\n\t        if (own) ownParams.push(p);\n\t      });\n\t      return ownParams;\n\t    },\n\t\n\t    // Keep a full path from the root down to this state as this is needed for state activation.\n\t    path: function(state) {\n\t      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n\t    },\n\t\n\t    // Speed up $state.contains() as it's used a lot\n\t    includes: function(state) {\n\t      var includes = state.parent ? extend({}, state.parent.includes) : {};\n\t      includes[state.name] = true;\n\t      return includes;\n\t    },\n\t\n\t    $delegates: {}\n\t  };\n\t\n\t  function isRelative(stateName) {\n\t    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t  }\n\t\n\t  function findState(stateOrName, base) {\n\t    if (!stateOrName) return undefined;\n\t\n\t    var isStr = isString(stateOrName),\n\t        name  = isStr ? stateOrName : stateOrName.name,\n\t        path  = isRelative(name);\n\t\n\t    if (path) {\n\t      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n\t      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\t\n\t      for (; i < pathLength; i++) {\n\t        if (rel[i] === \"\" && i === 0) {\n\t          current = base;\n\t          continue;\n\t        }\n\t        if (rel[i] === \"^\") {\n\t          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n\t          current = current.parent;\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t      rel = rel.slice(i).join(\".\");\n\t      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n\t    }\n\t    var state = states[name];\n\t\n\t    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t      return state;\n\t    }\n\t    return undefined;\n\t  }\n\t\n\t  function queueState(parentName, state) {\n\t    if (!queue[parentName]) {\n\t      queue[parentName] = [];\n\t    }\n\t    queue[parentName].push(state);\n\t  }\n\t\n\t  function registerState(state) {\n\t    // Wrap a new object around the state so we can store our private details easily.\n\t    state = inherit(state, {\n\t      self: state,\n\t      resolve: state.resolve || {},\n\t      toString: function() { return this.name; }\n\t    });\n\t\n\t    var name = state.name;\n\t    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n\t    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\t\n\t    // Get parent name\n\t    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n\t        : (isString(state.parent)) ? state.parent\n\t        : '';\n\t\n\t    // If parent is not registered yet, add state to queue and register later\n\t    if (parentName && !states[parentName]) {\n\t      return queueState(parentName, state.self);\n\t    }\n\t\n\t    for (var key in stateBuilder) {\n\t      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n\t    }\n\t    states[name] = state;\n\t\n\t    // Register the state in the global state list and with $urlRouter if necessary.\n\t    if (!state[abstractKey] && state.url) {\n\t      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n\t        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n\t          $state.transitionTo(state, $match, { location: false });\n\t        }\n\t      }]);\n\t    }\n\t\n\t    // Register any queued children\n\t    if (queue[name]) {\n\t      for (var i = 0; i < queue[name].length; i++) {\n\t        registerState(queue[name][i]);\n\t      }\n\t    }\n\t\n\t    return state;\n\t  }\n\t\n\t  // Checks text to see if it looks like a glob.\n\t  function isGlob (text) {\n\t    return text.indexOf('*') > -1;\n\t  }\n\t\n\t  // Returns true if glob matches current $state name.\n\t  function doesStateMatchGlob (glob) {\n\t    var globSegments = glob.split('.'),\n\t        segments = $state.$current.name.split('.');\n\t\n\t    //match greedy starts\n\t    if (globSegments[0] === '**') {\n\t       segments = segments.slice(segments.indexOf(globSegments[1]));\n\t       segments.unshift('**');\n\t    }\n\t    //match greedy ends\n\t    if (globSegments[globSegments.length - 1] === '**') {\n\t       segments.splice(segments.indexOf(globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n\t       segments.push('**');\n\t    }\n\t\n\t    if (globSegments.length != segments.length) {\n\t      return false;\n\t    }\n\t\n\t    //match single stars\n\t    for (var i = 0, l = globSegments.length; i < l; i++) {\n\t      if (globSegments[i] === '*') {\n\t        segments[i] = '*';\n\t      }\n\t    }\n\t\n\t    return segments.join('') === globSegments.join('');\n\t  }\n\t\n\t\n\t  // Implicit root state that is always active\n\t  root = registerState({\n\t    name: '',\n\t    url: '^',\n\t    views: null,\n\t    'abstract': true\n\t  });\n\t  root.navigable = null;\n\t\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#decorator\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Allows you to extend (carefully) or override (at your own peril) the \n\t   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n\t   * to add custom functionality to ui-router, for example inferring templateUrl \n\t   * based on the state name.\n\t   *\n\t   * When passing only a name, it returns the current (original or decorated) builder\n\t   * function that matches `name`.\n\t   *\n\t   * The builder functions that can be decorated are listed below. Though not all\n\t   * necessarily have a good use case for decoration, that is up to you to decide.\n\t   *\n\t   * In addition, users can attach custom decorators, which will generate new \n\t   * properties within the state's internal definition. There is currently no clear \n\t   * use-case for this beyond accessing internal states (i.e. $state.$current), \n\t   * however, expect this to become increasingly relevant as we introduce additional \n\t   * meta-programming features.\n\t   *\n\t   * **Warning**: Decorators should not be interdependent because the order of \n\t   * execution of the builder functions in non-deterministic. Builder functions \n\t   * should only be dependent on the state definition object and super function.\n\t   *\n\t   *\n\t   * Existing builder functions and current return values:\n\t   *\n\t   * - **parent** `{object}` - returns the parent state object.\n\t   * - **data** `{object}` - returns state data, including any inherited data that is not\n\t   *   overridden by own values (if any).\n\t   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t   *   or `null`.\n\t   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n\t   *   navigable).\n\t   * - **params** `{object}` - returns an array of state params that are ensured to \n\t   *   be a super-set of parent's params.\n\t   * - **views** `{object}` - returns a views object where each key is an absolute view \n\t   *   name (i.e. \"viewName@stateName\") and each value is the config object \n\t   *   (template, controller) for the view. Even when you don't use the views object \n\t   *   explicitly on a state config, one is still created for you internally.\n\t   *   So by decorating this builder function you have access to decorating template \n\t   *   and controller properties.\n\t   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n\t   *   not including any params defined by ancestor states.\n\t   * - **path** `{string}` - returns the full path from the root down to this state. \n\t   *   Needed for state activation.\n\t   * - **includes** `{object}` - returns an object that includes every state that \n\t   *   would pass a `$state.includes()` test.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Override the internal 'views' builder with a function that takes the state\n\t   * // definition, and a reference to the internal function being overridden:\n\t   * $stateProvider.decorator('views', function (state, parent) {\n\t   *   var result = {},\n\t   *       views = parent(state);\n\t   *\n\t   *   angular.forEach(views, function (config, name) {\n\t   *     var autoName = (state.name + '.' + name).replace('.', '/');\n\t   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t   *     result[name] = config;\n\t   *   });\n\t   *   return result;\n\t   * });\n\t   *\n\t   * $stateProvider.state('home', {\n\t   *   views: {\n\t   *     'contact.list': { controller: 'ListController' },\n\t   *     'contact.item': { controller: 'ItemController' }\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * $state.go('home');\n\t   * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t   * // and /partials/home/contact/item.html, respectively.\n\t   * </pre>\n\t   *\n\t   * @param {string} name The name of the builder function to decorate. \n\t   * @param {object} func A function that is responsible for decorating the original \n\t   * builder function. The function receives two parameters:\n\t   *\n\t   *   - `{object}` - state - The state config object.\n\t   *   - `{object}` - super - The original builder function.\n\t   *\n\t   * @return {object} $stateProvider - $stateProvider instance\n\t   */\n\t  this.decorator = decorator;\n\t  function decorator(name, func) {\n\t    /*jshint validthis: true */\n\t    if (isString(name) && !isDefined(func)) {\n\t      return stateBuilder[name];\n\t    }\n\t    if (!isFunction(func) || !isString(name)) {\n\t      return this;\n\t    }\n\t    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n\t      stateBuilder.$delegates[name] = stateBuilder[name];\n\t    }\n\t    stateBuilder[name] = func;\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#state\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Registers a state configuration under a given state name. The stateConfig object\n\t   * has the following acceptable properties.\n\t   *\n\t   * <a id='template'></a>\n\t   *\n\t   * - **`template`** - {string|function=} - html template as a string or a function that returns\n\t   *   an html template as a string which should be used by the uiView directives. This property \n\t   *   takes precedence over templateUrl.\n\t   *   \n\t   *   If `template` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t   *     applying the current state\n\t   *\n\t   * <a id='templateUrl'></a>\n\t   *\n\t   * - **`templateUrl`** - {string|function=} - path or function that returns a path to an html \n\t   *   template that should be used by uiView.\n\t   *   \n\t   *   If `templateUrl` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n\t   *     applying the current state\n\t   *\n\t   * <a id='templateProvider'></a>\n\t   *\n\t   * - **`templateProvider`** - {function=} - Provider function that returns HTML content\n\t   *   string.\n\t   *\n\t   * <a id='controller'></a>\n\t   *\n\t   * - **`controller`** - {string|function=} -  Controller fn that should be associated with newly \n\t   *   related scope or the name of a registered controller if passed as a string.\n\t   *\n\t   * <a id='controllerProvider'></a>\n\t   *\n\t   * - **`controllerProvider`** - {function=} - Injectable provider function that returns\n\t   *   the actual controller or string.\n\t   *\n\t   * <a id='controllerAs'></a>\n\t   * \n\t   * - **`controllerAs`**  {string=}  A controller alias name. If present the controller will be \n\t   *   published to scope under the controllerAs name.\n\t   *\n\t   * <a id='resolve'></a>\n\t   *\n\t   * - **`resolve`** - {object.&lt;string, function&gt;=} - An optional map of dependencies which \n\t   *   should be injected into the controller. If any of these dependencies are promises, \n\t   *   the router will wait for them all to be resolved or one to be rejected before the \n\t   *   controller is instantiated. If all the promises are resolved successfully, the values \n\t   *   of the resolved promises are injected and $stateChangeSuccess event is fired. If any \n\t   *   of the promises are rejected the $stateChangeError event is fired. The map object is:\n\t   *   \n\t   *   - key - {string}: name of dependency to be injected into controller\n\t   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n\t   *     it is injected and return value it treated as dependency. If result is a promise, it is \n\t   *     resolved before its value is injected into controller.\n\t   *\n\t   * <a id='url'></a>\n\t   *\n\t   * - **`url`** - {string=} - A url with optional parameters. When a state is navigated or\n\t   *   transitioned to, the `$stateParams` service will be populated with any \n\t   *   parameters that were passed.\n\t   *\n\t   * <a id='params'></a>\n\t   *\n\t   * - **`params`** - {object=} - An array of parameter names or regular expressions. Only \n\t   *   use this within a state if you are not using url. Otherwise you can specify your\n\t   *   parameters within the url. When a state is navigated or transitioned to, the \n\t   *   $stateParams service will be populated with any parameters that were passed.\n\t   *\n\t   * <a id='views'></a>\n\t   *\n\t   * - **`views`** - {object=} - Use the views property to set up multiple views or to target views\n\t   *   manually/explicitly.\n\t   *\n\t   * <a id='abstract'></a>\n\t   *\n\t   * - **`abstract`** - {boolean=} - An abstract state will never be directly activated, \n\t   *   but can provide inherited properties to its common children states.\n\t   *\n\t   * <a id='onEnter'></a>\n\t   *\n\t   * - **`onEnter`** - {object=} - Callback function for when a state is entered. Good way\n\t   *   to trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n\t   *\n\t   * <a id='onExit'></a>\n\t   *\n\t   * - **`onExit`** - {object=} - Callback function for when a state is exited. Good way to\n\t   *   trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n\t   *\n\t   * <a id='reloadOnSearch'></a>\n\t   *\n\t   * - **`reloadOnSearch = true`** - {boolean=} - If `false`, will not retrigger the same state \n\t   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n\t   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n\t   *\n\t   * <a id='data'></a>\n\t   *\n\t   * - **`data`** - {object=} - Arbitrary data object, useful for custom configuration.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Some state name examples\n\t   *\n\t   * // stateName can be a single top-level name (must be unique).\n\t   * $stateProvider.state(\"home\", {});\n\t   *\n\t   * // Or it can be a nested state name. This state is a child of the \n\t   * // above \"home\" state.\n\t   * $stateProvider.state(\"home.newest\", {});\n\t   *\n\t   * // Nest states as deeply as needed.\n\t   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n\t   *\n\t   * // state() returns $stateProvider, so you can chain state declarations.\n\t   * $stateProvider\n\t   *   .state(\"home\", {})\n\t   *   .state(\"about\", {})\n\t   *   .state(\"contacts\", {});\n\t   * </pre>\n\t   *\n\t   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\". \n\t   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n\t   * @param {object} definition State configuration object.\n\t   */\n\t  this.state = state;\n\t  function state(name, definition) {\n\t    /*jshint validthis: true */\n\t    if (isObject(name)) definition = name;\n\t    else definition.name = name;\n\t    registerState(definition);\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$state\n\t   *\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires ui.router.state.$view\n\t   * @requires $injector\n\t   * @requires ui.router.util.$resolve\n\t   * @requires ui.router.state.$stateParams\n\t   * @requires ui.router.router.$urlRouter\n\t   *\n\t   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n\t   * you'd like to test against the current active state.\n\t   * @property {object} current A reference to the state's config object. However \n\t   * you passed it in. Useful for accessing custom data.\n\t   * @property {object} transition Currently pending transition. A promise that'll \n\t   * resolve or reject.\n\t   *\n\t   * @description\n\t   * `$state` service is responsible for representing states as well as transitioning\n\t   * between them. It also provides interfaces to ask for current state or even states\n\t   * you're coming from.\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter'];\n\t  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter) {\n\t\n\t    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n\t    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n\t    var TransitionAborted = $q.reject(new Error('transition aborted'));\n\t    var TransitionFailed = $q.reject(new Error('transition failed'));\n\t\n\t    // Handles the case where a state which is the target of a transition is not found, and the user\n\t    // can optionally retry or defer the transition\n\t    function handleRedirect(redirect, state, params, options) {\n\t      /**\n\t       * @ngdoc event\n\t       * @name ui.router.state.$state#$stateNotFound\n\t       * @eventOf ui.router.state.$state\n\t       * @eventType broadcast on root scope\n\t       * @description\n\t       * Fired when a requested state **cannot be found** using the provided state name during transition.\n\t       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n\t       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n\t       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n\t       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n\t       *\n\t       * @param {Object} event Event object.\n\t       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n\t       * @param {State} fromState Current state object.\n\t       * @param {Object} fromParams Current state params.\n\t       *\n\t       * @example\n\t       *\n\t       * <pre>\n\t       * // somewhere, assume lazy.state has not been defined\n\t       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n\t       *\n\t       * // somewhere else\n\t       * $scope.$on('$stateNotFound',\n\t       * function(event, unfoundState, fromState, fromParams){\n\t       *     console.log(unfoundState.to); // \"lazy.state\"\n\t       *     console.log(unfoundState.toParams); // {a:1, b:2}\n\t       *     console.log(unfoundState.options); // {inherit:false} + default options\n\t       * })\n\t       * </pre>\n\t       */\n\t      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\t\n\t      if (evt.defaultPrevented) {\n\t        $urlRouter.update();\n\t        return TransitionAborted;\n\t      }\n\t\n\t      if (!evt.retry) {\n\t        return null;\n\t      }\n\t\n\t      // Allow the handler to return a promise to defer state lookup retry\n\t      if (options.$retry) {\n\t        $urlRouter.update();\n\t        return TransitionFailed;\n\t      }\n\t      var retryTransition = $state.transition = $q.when(evt.retry);\n\t\n\t      retryTransition.then(function() {\n\t        if (retryTransition !== $state.transition) return TransitionSuperseded;\n\t        redirect.options.$retry = true;\n\t        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n\t      }, function() {\n\t        return TransitionAborted;\n\t      });\n\t      $urlRouter.update();\n\t\n\t      return retryTransition;\n\t    }\n\t\n\t    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\t\n\t    $state = {\n\t      params: {},\n\t      current: root.self,\n\t      $current: root,\n\t      transition: null\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#reload\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method that force reloads the current state. All resolves are re-resolved, events are not re-fired, \n\t     * and controllers reinstantiated (bug with controllers reinstantiating right now, fixing soon).\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: false \n\t     * });\n\t     * </pre>\n\t     */\n\t    $state.reload = function reload() {\n\t      $state.transitionTo($state.current, $stateParams, { reload: true, inherit: false, notify: false });\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#go\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Convenience method for transitioning to a new state. `$state.go` calls \n\t     * `$state.transitionTo` internally but automatically sets options to \n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n\t     * This allows you to easily use an absolute or relative to path and specify \n\t     * only the parameters you'd like to update (while letting unspecified parameters \n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n\t     *\n\t     * @param {string} to Absolute state name or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param {object=} params A map of the parameters that will be sent to the state, \n\t     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n\t     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n\t     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n\t     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     * will get you all current parameters, etc.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * Possible success values:\n\t     *\n\t     * - $state.current\n\t     *\n\t     * <br/>Possible rejection values:\n\t     *\n\t     * - 'transition superseded' - when a newer transition has been started after this one\n\t     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n\t     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n\t     *   when a `$stateNotFound` `event.retry` promise errors.\n\t     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n\t     * - *resolve error* - when an error has occurred with a `resolve`\n\t     *\n\t     */\n\t    $state.go = function go(to, params, options) {\n\t      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#transitionTo\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n\t     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string} to State name.\n\t     * @param {object=} toParams A map of the parameters that will be sent to the state,\n\t     * will populate $stateParams.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.transitionTo = function transitionTo(to, toParams, options) {\n\t      toParams = toParams || {};\n\t      options = extend({\n\t        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n\t      }, options || {});\n\t\n\t      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n\t      var evt, toState = findState(to, options.relative);\n\t\n\t      if (!isDefined(toState)) {\n\t        var redirect = { to: to, toParams: toParams, options: options };\n\t        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\t\n\t        if (redirectResult) {\n\t          return redirectResult;\n\t        }\n\t\n\t        // Always retry once if the $stateNotFound was not prevented\n\t        // (handles either redirect changed or state lazy-definition)\n\t        to = redirect.to;\n\t        toParams = redirect.toParams;\n\t        options = redirect.options;\n\t        toState = findState(to, options.relative);\n\t\n\t        if (!isDefined(toState)) {\n\t          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n\t          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n\t        }\n\t      }\n\t      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n\t      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n\t      to = toState;\n\t\n\t      var toPath = to.path;\n\t\n\t      // Starting from the root of the path, keep all levels that haven't changed\n\t      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\t\n\t      if (!options.reload) {\n\t        while (state && state === fromPath[keep] && equalForKeys(toParams, fromParams, state.ownParams)) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      }\n\t\n\t      // If we're going to the same state and all locals are kept, we've got nothing to do.\n\t      // But clear 'transition', as we still want to cancel any other pending transitions.\n\t      // TODO: We may not want to bump 'transition' if we're called from a location change\n\t      // that we've initiated ourselves, because we might accidentally abort a legitimate\n\t      // transition initiated from code?\n\t      if (shouldTriggerReload(to, from, locals, options)) {\n\t        if (to.self.reloadOnSearch !== false) $urlRouter.update();\n\t        $state.transition = null;\n\t        return $q.when($state.current);\n\t      }\n\t\n\t      // Filter parameters before we pass them to event handlers etc.\n\t      toParams = filterByKeys(objectKeys(to.params), toParams || {});\n\t\n\t      // Broadcast start event and cancel the transition if requested\n\t      if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeStart\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n\t         * to prevent the transition from happening and then the transition promise will be\n\t         * rejected with a `'transition prevented'` value.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $rootScope.$on('$stateChangeStart',\n\t         * function(event, toState, toParams, fromState, fromParams){\n\t         *     event.preventDefault();\n\t         *     // transitionTo() promise will be rejected with\n\t         *     // a 'transition prevented' error\n\t         * })\n\t         * </pre>\n\t         */\n\t        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n\t          $urlRouter.update();\n\t          return TransitionPrevented;\n\t        }\n\t      }\n\t\n\t      // Resolve locals for the remaining states, but don't update any global state just\n\t      // yet -- if anything fails to resolve the current state needs to remain untouched.\n\t      // We also set up an inheritance chain for the locals here. This allows the view directive\n\t      // to quickly look up the correct definition for each view in the current state. Even\n\t      // though we create the locals object itself outside resolveState(), it is initially\n\t      // empty and gets filled asynchronously. We need to keep track of the promise for the\n\t      // (fully resolved) current locals, and pass this down the chain.\n\t      var resolved = $q.when(locals);\n\t\n\t      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n\t        locals = toLocals[l] = inherit(locals);\n\t        resolved = resolveState(state, toParams, state === to, resolved, locals);\n\t      }\n\t\n\t      // Once everything is resolved, we are ready to perform the actual transition\n\t      // and return a promise for the new state. We also keep track of what the\n\t      // current promise is, so that we can detect overlapping transitions and\n\t      // keep only the outcome of the last transition.\n\t      var transition = $state.transition = resolved.then(function () {\n\t        var l, entering, exiting;\n\t\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Exit 'from' states not kept\n\t        for (l = fromPath.length - 1; l >= keep; l--) {\n\t          exiting = fromPath[l];\n\t          if (exiting.self.onExit) {\n\t            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n\t          }\n\t          exiting.locals = null;\n\t        }\n\t\n\t        // Enter 'to' states not kept\n\t        for (l = keep; l < toPath.length; l++) {\n\t          entering = toPath[l];\n\t          entering.locals = toLocals[l];\n\t          if (entering.self.onEnter) {\n\t            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n\t          }\n\t        }\n\t\n\t        // Run it again, to catch any transitions in callbacks\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Update globals in $state\n\t        $state.$current = to;\n\t        $state.current = to.self;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        $state.transition = null;\n\t\n\t        if (options.location && to.navigable) {\n\t          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n\t            replace: options.location === 'replace'\n\t          });\n\t        }\n\t\n\t        if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeSuccess\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired once the state transition is **complete**.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         */\n\t          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n\t        }\n\t        $urlRouter.update(true);\n\t\n\t        return $state.current;\n\t      }, function (error) {\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        $state.transition = null;\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeError\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when an **error occurs** during transition. It's important to note that if you\n\t         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n\t         * they will not throw traditionally. You must listen for this $stateChangeError event to\n\t         * catch **ALL** errors.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         * @param {Error} error The resolve error object.\n\t         */\n\t        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\t\n\t        if (!evt.defaultPrevented) {\n\t            $urlRouter.update();\n\t        }\n\t\n\t        return $q.reject(error);\n\t      });\n\t\n\t      return transition;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#is\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n\t     * but only checks for the full state name. If params is supplied then it will be \n\t     * tested for strict equality against the current active params object, so all params \n\t     * must match with none missing and no extras.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like \n\t     * to test against the current active state.\n\t     * @returns {boolean} Returns true if it is the state.\n\t     */\n\t    $state.is = function is(stateOrName, params) {\n\t      var state = findState(stateOrName);\n\t\n\t      if (!isDefined(state)) {\n\t        return undefined;\n\t      }\n\t\n\t      if ($state.$current !== state) {\n\t        return false;\n\t      }\n\t\n\t      return isDefined(params) && params !== null ? angular.equals($stateParams, params) : true;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#includes\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * @example\n\t     * Partial and relative names\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     *\n\t     * // Using relative names (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * Basic globbing patterns\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item.url';\n\t     *\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * </pre>\n\t     *\n\t     * @param {string} stateOrName A partial name, relative name, or glob pattern\n\t     * to be searched for within the current state name.\n\t     * @param {object} params A param object, e.g. `{sectionId: section.id}`,\n\t     * that you'd like to test against the current active state.\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    $state.includes = function includes(stateOrName, params) {\n\t      if (isString(stateOrName) && isGlob(stateOrName)) {\n\t        if (!doesStateMatchGlob(stateOrName)) {\n\t          return false;\n\t        }\n\t        stateOrName = $state.$current.name;\n\t      }\n\t      var state = findState(stateOrName);\n\t\n\t      if (!isDefined(state)) {\n\t        return undefined;\n\t      }\n\t      if (!isDefined($state.$current.includes[state.name])) {\n\t        return false;\n\t      }\n\t      return equalForKeys(params, $stateParams);\n\t    };\n\t\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#href\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A url generation method that returns the compiled url for the given state populated with the given params.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param {object=} params An object of parameter values to fill the state's required parameters.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     * \n\t     * @returns {string} compiled state url\n\t     */\n\t    $state.href = function href(stateOrName, params, options) {\n\t      options = extend({\n\t        lossy:    true,\n\t        inherit:  true,\n\t        absolute: false,\n\t        relative: $state.$current\n\t      }, options || {});\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) return null;\n\t      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n\t      \n\t      var nav = (state && options.lossy) ? state.navigable : state;\n\t\n\t      if (!nav || !nav.url) {\n\t        return null;\n\t      }\n\t      return $urlRouter.href(nav.url, filterByKeys(objectKeys(state.params), params || {}), {\n\t        absolute: options.absolute\n\t      });\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#get\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Returns the state configuration object for any specific state or all states.\n\t     *\n\t     * @param {string|Sbject=} stateOrName (absolute or relative) If provided, will only get the config for\n\t     * the requested state. If not provided, returns an array of ALL state configs.\n\t     * @returns {Object|Array} State configuration object or array of all objects.\n\t     */\n\t    $state.get = function (stateOrName, context) {\n\t      if (arguments.length === 0) return objectKeys(states).map(function(name) { return states[name].self; });\n\t      var state = findState(stateOrName, context);\n\t      return (state && state.self) ? state.self : null;\n\t    };\n\t\n\t    function resolveState(state, params, paramsAreFiltered, inherited, dst) {\n\t      // Make a restricted $stateParams with only the parameters that apply to this state if\n\t      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n\t      // we also need $stateParams to be available for any $injector calls we make during the\n\t      // dependency resolution process.\n\t      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(objectKeys(state.params), params);\n\t      var locals = { $stateParams: $stateParams };\n\t\n\t      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n\t      // We're also including $stateParams in this; that way the parameters are restricted\n\t      // to the set that should be visible to the state, and are independent of when we update\n\t      // the global $state and $stateParams values.\n\t      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n\t      var promises = [dst.resolve.then(function (globals) {\n\t        dst.globals = globals;\n\t      })];\n\t      if (inherited) promises.push(inherited);\n\t\n\t      // Resolve template and dependencies for all views.\n\t      forEach(state.views, function (view, name) {\n\t        var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n\t        injectables.$template = [ function () {\n\t          return $view.load(name, { view: view, locals: locals, params: $stateParams }) || '';\n\t        }];\n\t\n\t        promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function (result) {\n\t          // References to the controller (only instantiated at link time)\n\t          if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n\t            var injectLocals = angular.extend({}, injectables, locals);\n\t            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n\t          } else {\n\t            result.$$controller = view.controller;\n\t          }\n\t          // Provide access to the state itself for internal use\n\t          result.$$state = state;\n\t          result.$$controllerAs = view.controllerAs;\n\t          dst[name] = result;\n\t        }));\n\t      });\n\t\n\t      // Wait for all the promises and then return the activation object\n\t      return $q.all(promises).then(function (values) {\n\t        return dst;\n\t      });\n\t    }\n\t\n\t    return $state;\n\t  }\n\t\n\t  function shouldTriggerReload(to, from, locals, options) {\n\t    if (to === from && ((locals === from.locals && !options.reload) || (to.self.reloadOnSearch === false))) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .value('$stateParams', {})\n\t  .provider('$state', $StateProvider);\n\t\n\t\n\t$ViewProvider.$inject = [];\n\tfunction $ViewProvider() {\n\t\n\t  this.$get = $get;\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$view\n\t   *\n\t   * @requires ui.router.util.$templateFactory\n\t   * @requires $rootScope\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  $get.$inject = ['$rootScope', '$templateFactory'];\n\t  function $get(   $rootScope,   $templateFactory) {\n\t    return {\n\t      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.state.$view#load\n\t       * @methodOf ui.router.state.$view\n\t       *\n\t       * @description\n\t       *\n\t       * @param {string} name name\n\t       * @param {object} options option object.\n\t       */\n\t      load: function load(name, options) {\n\t        var result, defaults = {\n\t          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n\t        };\n\t        options = extend(defaults, options);\n\t\n\t        if (options.view) {\n\t          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n\t        }\n\t        if (result && options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$viewContentLoading\n\t         * @eventOf ui.router.state.$view\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         *\n\t         * Fired once the view **begins loading**, *before* the DOM is rendered.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {Object} viewConfig The view config properties (template, controller, etc).\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $scope.$on('$viewContentLoading',\n\t         * function(event, viewConfig){\n\t         *     // Access to all the view config properties.\n\t         *     // and one special property 'targetView'\n\t         *     // viewConfig.targetView\n\t         * });\n\t         * </pre>\n\t         */\n\t          $rootScope.$broadcast('$viewContentLoading', options);\n\t        }\n\t        return result;\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state').provider('$view', $ViewProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$uiViewScrollProvider\n\t *\n\t * @description\n\t * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n\t */\n\tfunction $ViewScrollProvider() {\n\t\n\t  var useAnchorScroll = false;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n\t   * @methodOf ui.router.state.$uiViewScrollProvider\n\t   *\n\t   * @description\n\t   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n\t   * scrolling based on the url anchor.\n\t   */\n\t  this.useAnchorScroll = function () {\n\t    useAnchorScroll = true;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$uiViewScroll\n\t   *\n\t   * @requires $anchorScroll\n\t   * @requires $timeout\n\t   *\n\t   * @description\n\t   * When called with a jqLite element, it scrolls the element into view (after a\n\t   * `$timeout` so the DOM has time to refresh).\n\t   *\n\t   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n\t   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n\t   */\n\t  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t    if (useAnchorScroll) {\n\t      return $anchorScroll;\n\t    }\n\t\n\t    return function ($element) {\n\t      $timeout(function () {\n\t        $element[0].scrollIntoView();\n\t      }, 0, false);\n\t    };\n\t  }];\n\t}\n\t\n\tangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-view\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $compile\n\t * @requires $controller\n\t * @requires $injector\n\t * @requires ui.router.state.$uiViewScroll\n\t * @requires $document\n\t *\n\t * @restrict ECA\n\t *\n\t * @description\n\t * The ui-view directive tells $state where to place your templates.\n\t *\n\t * @param {string=} ui-view A view name. The name should be unique amongst the other views in the\n\t * same state. You can have views of the same name that live in different states.\n\t *\n\t * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n\t * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n\t * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n\t * scroll ui-view elements into view when they are populated during a state activation.\n\t *\n\t * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n\t * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n\t *\n\t * @param {string=} onload Expression to evaluate whenever the view updates.\n\t * \n\t * @example\n\t * A view can be unnamed or named. \n\t * <pre>\n\t * <!-- Unnamed -->\n\t * <div ui-view></div> \n\t * \n\t * <!-- Named -->\n\t * <div ui-view=\"viewName\"></div>\n\t * </pre>\n\t *\n\t * You can only have one unnamed view within any template (or root html). If you are only using a \n\t * single view and it is unnamed then you can populate it like so:\n\t * <pre>\n\t * <div ui-view></div> \n\t * $stateProvider.state(\"home\", {\n\t *   template: \"<h1>HELLO!</h1>\"\n\t * })\n\t * </pre>\n\t * \n\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n\t * config property, by name, in this case an empty name:\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * But typically you'll only use the views property if you name your view or have more than one view \n\t * in the same template. There's not really a compelling reason to name a view if its the only one, \n\t * but you could if you wanted, like so:\n\t * <pre>\n\t * <div ui-view=\"main\"></div>\n\t * </pre> \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"main\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * Really though, you'll use views to set up multiple views:\n\t * <pre>\n\t * <div ui-view></div>\n\t * <div ui-view=\"chart\"></div> \n\t * <div ui-view=\"data\"></div> \n\t * </pre>\n\t * \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     },\n\t *     \"chart\": {\n\t *       template: \"<chart_thing/>\"\n\t *     },\n\t *     \"data\": {\n\t *       template: \"<data_thing/>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Examples for `autoscroll`:\n\t *\n\t * <pre>\n\t * <!-- If autoscroll present with no expression,\n\t *      then scroll ui-view into view -->\n\t * <ui-view autoscroll/>\n\t *\n\t * <!-- If autoscroll present with valid expression,\n\t *      then scroll ui-view into view if expression evaluates to true -->\n\t * <ui-view autoscroll='true'/>\n\t * <ui-view autoscroll='false'/>\n\t * <ui-view autoscroll='scopeVariable'/>\n\t * </pre>\n\t */\n\t$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll'];\n\tfunction $ViewDirective(   $state,   $injector,   $uiViewScroll) {\n\t\n\t  function getService() {\n\t    return ($injector.has) ? function(service) {\n\t      return $injector.has(service) ? $injector.get(service) : null;\n\t    } : function(service) {\n\t      try {\n\t        return $injector.get(service);\n\t      } catch (e) {\n\t        return null;\n\t      }\n\t    };\n\t  }\n\t\n\t  var service = getService(),\n\t      $animator = service('$animator'),\n\t      $animate = service('$animate');\n\t\n\t  // Returns a set of DOM manipulation functions based on which Angular version\n\t  // it should use\n\t  function getRenderer(attrs, scope) {\n\t    var statics = function() {\n\t      return {\n\t        enter: function (element, target, cb) { target.after(element); cb(); },\n\t        leave: function (element, cb) { element.remove(); cb(); }\n\t      };\n\t    };\n\t\n\t    if ($animate) {\n\t      return {\n\t        enter: function(element, target, cb) { $animate.enter(element, null, target, cb); },\n\t        leave: function(element, cb) { $animate.leave(element, cb); }\n\t      };\n\t    }\n\t\n\t    if ($animator) {\n\t      var animate = $animator && $animator(scope, attrs);\n\t\n\t      return {\n\t        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n\t        leave: function(element, cb) { animate.leave(element); cb(); }\n\t      };\n\t    }\n\t\n\t    return statics();\n\t  }\n\t\n\t  var directive = {\n\t    restrict: 'ECA',\n\t    terminal: true,\n\t    priority: 400,\n\t    transclude: 'element',\n\t    compile: function (tElement, tAttrs, $transclude) {\n\t      return function (scope, $element, attrs) {\n\t        var previousEl, currentEl, currentScope, latestLocals,\n\t            onloadExp     = attrs.onload || '',\n\t            autoScrollExp = attrs.autoscroll,\n\t            renderer      = getRenderer(attrs, scope);\n\t\n\t        scope.$on('$stateChangeSuccess', function() {\n\t          updateView(false);\n\t        });\n\t        scope.$on('$viewContentLoading', function() {\n\t          updateView(false);\n\t        });\n\t\n\t        updateView(true);\n\t\n\t        function cleanupLastView() {\n\t          if (previousEl) {\n\t            previousEl.remove();\n\t            previousEl = null;\n\t          }\n\t\n\t          if (currentScope) {\n\t            currentScope.$destroy();\n\t            currentScope = null;\n\t          }\n\t\n\t          if (currentEl) {\n\t            renderer.leave(currentEl, function() {\n\t              previousEl = null;\n\t            });\n\t\n\t            previousEl = currentEl;\n\t            currentEl = null;\n\t          }\n\t        }\n\t\n\t        function updateView(firstTime) {\n\t          var newScope,\n\t              name            = getUiViewName(attrs, $element.inheritedData('$uiView')),\n\t              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\t\n\t          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n\t          newScope = scope.$new();\n\t          latestLocals = $state.$current.locals[name];\n\t\n\t          var clone = $transclude(newScope, function(clone) {\n\t            renderer.enter(clone, $element, function onUiViewEnter() {\n\t              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t                $uiViewScroll(clone);\n\t              }\n\t            });\n\t            cleanupLastView();\n\t          });\n\t\n\t          currentEl = clone;\n\t          currentScope = newScope;\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description           *\n\t           * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           */\n\t          currentScope.$emit('$viewContentLoaded');\n\t          currentScope.$eval(onloadExp);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  return directive;\n\t}\n\t\n\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state'];\n\tfunction $ViewDirectiveFill ($compile, $controller, $state) {\n\t  return {\n\t    restrict: 'ECA',\n\t    priority: -400,\n\t    compile: function (tElement) {\n\t      var initial = tElement.html();\n\t      return function (scope, $element, attrs) {\n\t        var current = $state.$current,\n\t            name = getUiViewName(attrs, $element.inheritedData('$uiView')),\n\t            locals  = current && current.locals[name];\n\t\n\t        if (! locals) {\n\t          return;\n\t        }\n\t\n\t        $element.data('$uiView', { name: name, state: locals.$$state });\n\t        $element.html(locals.$template ? locals.$template : initial);\n\t\n\t        var link = $compile($element.contents());\n\t\n\t        if (locals.$$controller) {\n\t          locals.$scope = scope;\n\t          var controller = $controller(locals.$$controller, locals);\n\t          if (locals.$$controllerAs) {\n\t            scope[locals.$$controllerAs] = controller;\n\t          }\n\t          $element.data('$ngControllerController', controller);\n\t          $element.children().data('$ngControllerController', controller);\n\t        }\n\t\n\t        link(scope);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Shared ui-view code for both directives:\n\t * Given attributes and inherited $uiView data, return the view's name\n\t */\n\tfunction getUiViewName(attrs, inherited) {\n\t  var name = attrs.uiView || attrs.name || '';\n\t  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n\t}\n\t\n\tangular.module('ui.router.state').directive('uiView', $ViewDirective);\n\tangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\t\n\tfunction parseStateRef(ref, current) {\n\t  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n\t  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n\t  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t  return { state: parsed[1], paramExpr: parsed[3] || null };\n\t}\n\t\n\tfunction stateContext(el) {\n\t  var stateData = el.parent().inheritedData('$uiView');\n\t\n\t  if (stateData && stateData.state && stateData.state.name) {\n\t    return stateData.state;\n\t  }\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $timeout\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive that binds a link (`<a>` tag) to a state. If the state has an associated \n\t * URL, the directive will automatically generate & update the `href` attribute via \n\t * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking \n\t * the link will trigger a state transition with optional parameters. \n\t *\n\t * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be \n\t * handled natively by the browser.\n\t *\n\t * You can also use relative state paths within ui-sref, just like the relative \n\t * paths passed to `$state.go()`. You just need to be aware that the path is relative\n\t * to the state that the link lives in, in other words the state that loaded the \n\t * template containing the link.\n\t *\n\t * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n\t * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n\t * and `reload`.\n\t *\n\t * @example\n\t * Here's an example of how you'd use ui-sref and how it would compile. If you have the \n\t * following template:\n\t * <pre>\n\t * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n\t * \n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t *     </li>\n\t * </ul>\n\t * </pre>\n\t * \n\t * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n\t * <pre>\n\t * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t * \n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t *     </li>\n\t * </ul>\n\t *\n\t * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t * </pre>\n\t *\n\t * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n\t */\n\t$StateRefDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDirective($state, $timeout) {\n\t  var allowedOptions = ['location', 'inherit', 'reload'];\n\t\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var ref = parseStateRef(attrs.uiSref, $state.current.name);\n\t      var params = null, url = null, base = stateContext(element) || $state.$current;\n\t      var isForm = element[0].nodeName === \"FORM\";\n\t      var attr = isForm ? \"action\" : \"href\", nav = true;\n\t\n\t      var options = { relative: base, inherit: true };\n\t      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};\n\t\n\t      angular.forEach(allowedOptions, function(option) {\n\t        if (option in optionsOverride) {\n\t          options[option] = optionsOverride[option];\n\t        }\n\t      });\n\t\n\t      var update = function(newVal) {\n\t        if (newVal) params = newVal;\n\t        if (!nav) return;\n\t\n\t        var newHref = $state.href(ref.state, params, options);\n\t\n\t        var activeDirective = uiSrefActive[1] || uiSrefActive[0];\n\t        if (activeDirective) {\n\t          activeDirective.$$setStateInfo(ref.state, params);\n\t        }\n\t        if (newHref === null) {\n\t          nav = false;\n\t          return false;\n\t        }\n\t        element[0][attr] = newHref;\n\t      };\n\t\n\t      if (ref.paramExpr) {\n\t        scope.$watch(ref.paramExpr, function(newVal, oldVal) {\n\t          if (newVal !== params) update(newVal);\n\t        }, true);\n\t        params = scope.$eval(ref.paramExpr);\n\t      }\n\t      update();\n\t\n\t      if (isForm) return;\n\t\n\t      element.bind(\"click\", function(e) {\n\t        var button = e.which || e.button;\n\t        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {\n\t          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t          var transition = $timeout(function() {\n\t            $state.go(ref.state, params, options);\n\t          });\n\t          e.preventDefault();\n\t\n\t          e.preventDefault = function() {\n\t            $timeout.cancel(transition);\n\t          };\n\t        }\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive working alongside ui-sref to add classes to an element when the\n\t * related ui-sref directive's state is active, and removing them when it is inactive.\n\t * The primary use-case is to simplify the special appearance of navigation menus\n\t * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n\t * distinguishing it from the inactive menu items.\n\t *\n\t * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n\t * ui-sref-active found at the same level or above the ui-sref will be used.\n\t *\n\t * Will activate when the ui-sref's target state or any child state is active. If you\n\t * need to activate only when the ui-sref target state is active and *not* any of\n\t * it's children, then you will use\n\t * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n\t *\n\t * @example\n\t * Given the following template:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t *\n\t * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t * the resulting HTML will appear as (note the 'active' class):\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * The class name is interpolated **once** during the directives link time (any further changes to the\n\t * interpolated value are ignored).\n\t *\n\t * Multiple classes may be specified in a space-separated format:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active='class1 class2 class3'>\n\t *     <a ui-sref=\"app.user\">link</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active-eq\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will will only activate\n\t * when the exact target state used in the `ui-sref` is active; no child states.\n\t *\n\t */\n\t$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\n\tfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n\t  return  {\n\t    restrict: \"A\",\n\t    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n\t      var state, params, activeClass;\n\t\n\t      // There probably isn't much point in $observing this\n\t      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t      // slight difference in logic routing\n\t      activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);\n\t\n\t      // Allow uiSref to communicate with uiSrefActive[Equals]\n\t      this.$$setStateInfo = function (newState, newParams) {\n\t        state = $state.get(newState, stateContext($element));\n\t        params = newParams;\n\t        update();\n\t      };\n\t\n\t      $scope.$on('$stateChangeSuccess', update);\n\t\n\t      // Update route state\n\t      function update() {\n\t        if (isMatch()) {\n\t          $element.addClass(activeClass);\n\t        } else {\n\t          $element.removeClass(activeClass);\n\t        }\n\t      }\n\t\n\t      function isMatch() {\n\t        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {\n\t          return $state.$current.self === state && matchesParams();\n\t        } else {\n\t          return $state.includes(state.name) && matchesParams();\n\t        }\n\t      }\n\t\n\t      function matchesParams() {\n\t        return !params || equalForKeys(params, $stateParams);\n\t      }\n\t    }]\n\t  };\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .directive('uiSref', $StateRefDirective)\n\t  .directive('uiSrefActive', $StateRefActiveDirective)\n\t  .directive('uiSrefActiveEq', $StateRefActiveDirective);\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:isState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n\t */\n\t$IsStateFilter.$inject = ['$state'];\n\tfunction $IsStateFilter($state) {\n\t  return function(state) {\n\t    return $state.is(state);\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:includedByState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n\t */\n\t$IncludedByStateFilter.$inject = ['$state'];\n\tfunction $IncludedByStateFilter($state) {\n\t  return function(state) {\n\t    return $state.includes(state);\n\t  };\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .filter('isState', $IsStateFilter)\n\t  .filter('includedByState', $IncludedByStateFilter);\n\t})(window, window.angular);\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  __webpack_require__(4);\n\t  __webpack_require__(15);\n\t  __webpack_require__(12);\n\t  __webpack_require__(1);\n\t  __webpack_require__(2);\n\t  angular.module(\"SirenBrowser\", [\"ui.bootstrap\", \"ui.router\", \"cgBusy\"]).config([\n\t    \"$stateProvider\", \"$urlRouterProvider\", function($stateProvider, $urlRouterProvider) {\n\t      $urlRouterProvider.otherwise('/siren-browser');\n\t      return $stateProvider.state(\"siren-browser\", {\n\t        url: \"/siren-browser?url?cached\",\n\t        controller: \"showCtrl as showCtrl\",\n\t        template: __webpack_require__(7),\n\t        resolve: {\n\t          sirenEntity: [\n\t            'entityResolver', '$rootScope', '$stateParams', function(entityResolver, $rootScope, $stateParams) {\n\t              return entityResolver.resolve($stateParams.url);\n\t            }\n\t          ]\n\t        }\n\t      });\n\t    }\n\t  ]);\n\t  __webpack_require__(8);\n\t  __webpack_require__(9);\n\t  __webpack_require__(10);\n\t  return __webpack_require__(11);\n\t})();\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\r\n\t\r\n\t/**\r\n\t * Merge two attribute objects giving precedence\r\n\t * to values in object `b`. Classes are special-cased\r\n\t * allowing for arrays and merging/joining appropriately\r\n\t * resulting in a string.\r\n\t *\r\n\t * @param {Object} a\r\n\t * @param {Object} b\r\n\t * @return {Object} a\r\n\t * @api private\r\n\t */\r\n\t\r\n\texports.merge = function merge(a, b) {\r\n\t  if (arguments.length === 1) {\r\n\t    var attrs = a[0];\r\n\t    for (var i = 1; i < a.length; i++) {\r\n\t      attrs = merge(attrs, a[i]);\r\n\t    }\r\n\t    return attrs;\r\n\t  }\r\n\t  var ac = a['class'];\r\n\t  var bc = b['class'];\r\n\t\r\n\t  if (ac || bc) {\r\n\t    ac = ac || [];\r\n\t    bc = bc || [];\r\n\t    if (!Array.isArray(ac)) ac = [ac];\r\n\t    if (!Array.isArray(bc)) bc = [bc];\r\n\t    a['class'] = ac.concat(bc).filter(nulls);\r\n\t  }\r\n\t\r\n\t  for (var key in b) {\r\n\t    if (key != 'class') {\r\n\t      a[key] = b[key];\r\n\t    }\r\n\t  }\r\n\t\r\n\t  return a;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Filter null `val`s.\r\n\t *\r\n\t * @param {*} val\r\n\t * @return {Boolean}\r\n\t * @api private\r\n\t */\r\n\t\r\n\tfunction nulls(val) {\r\n\t  return val != null && val !== '';\r\n\t}\r\n\t\r\n\t/**\r\n\t * join array as classes.\r\n\t *\r\n\t * @param {*} val\r\n\t * @return {String}\r\n\t */\r\n\texports.joinClasses = joinClasses;\r\n\tfunction joinClasses(val) {\r\n\t  return Array.isArray(val) ? val.map(joinClasses).filter(nulls).join(' ') : val;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Render the given classes.\r\n\t *\r\n\t * @param {Array} classes\r\n\t * @param {Array.<Boolean>} escaped\r\n\t * @return {String}\r\n\t */\r\n\texports.cls = function cls(classes, escaped) {\r\n\t  var buf = [];\r\n\t  for (var i = 0; i < classes.length; i++) {\r\n\t    if (escaped && escaped[i]) {\r\n\t      buf.push(exports.escape(joinClasses([classes[i]])));\r\n\t    } else {\r\n\t      buf.push(joinClasses(classes[i]));\r\n\t    }\r\n\t  }\r\n\t  var text = joinClasses(buf);\r\n\t  if (text.length) {\r\n\t    return ' class=\"' + text + '\"';\r\n\t  } else {\r\n\t    return '';\r\n\t  }\r\n\t};\r\n\t\r\n\t/**\r\n\t * Render the given attribute.\r\n\t *\r\n\t * @param {String} key\r\n\t * @param {String} val\r\n\t * @param {Boolean} escaped\r\n\t * @param {Boolean} terse\r\n\t * @return {String}\r\n\t */\r\n\texports.attr = function attr(key, val, escaped, terse) {\r\n\t  if ('boolean' == typeof val || null == val) {\r\n\t    if (val) {\r\n\t      return ' ' + (terse ? key : key + '=\"' + key + '\"');\r\n\t    } else {\r\n\t      return '';\r\n\t    }\r\n\t  } else if (0 == key.indexOf('data') && 'string' != typeof val) {\r\n\t    return ' ' + key + \"='\" + JSON.stringify(val).replace(/'/g, '&apos;') + \"'\";\r\n\t  } else if (escaped) {\r\n\t    return ' ' + key + '=\"' + exports.escape(val) + '\"';\r\n\t  } else {\r\n\t    return ' ' + key + '=\"' + val + '\"';\r\n\t  }\r\n\t};\r\n\t\r\n\t/**\r\n\t * Render the given attributes object.\r\n\t *\r\n\t * @param {Object} obj\r\n\t * @param {Object} escaped\r\n\t * @return {String}\r\n\t */\r\n\texports.attrs = function attrs(obj, terse){\r\n\t  var buf = [];\r\n\t\r\n\t  var keys = Object.keys(obj);\r\n\t\r\n\t  if (keys.length) {\r\n\t    for (var i = 0; i < keys.length; ++i) {\r\n\t      var key = keys[i]\r\n\t        , val = obj[key];\r\n\t\r\n\t      if ('class' == key) {\r\n\t        if (val = joinClasses(val)) {\r\n\t          buf.push(' ' + key + '=\"' + val + '\"');\r\n\t        }\r\n\t      } else {\r\n\t        buf.push(exports.attr(key, val, false, terse));\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  return buf.join('');\r\n\t};\r\n\t\r\n\t/**\r\n\t * Escape the given string of `html`.\r\n\t *\r\n\t * @param {String} html\r\n\t * @return {String}\r\n\t * @api private\r\n\t */\r\n\t\r\n\texports.escape = function escape(html){\r\n\t  var result = String(html)\r\n\t    .replace(/&/g, '&amp;')\r\n\t    .replace(/</g, '&lt;')\r\n\t    .replace(/>/g, '&gt;')\r\n\t    .replace(/\"/g, '&quot;');\r\n\t  if (result === '' + html) return html;\r\n\t  else return result;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Re-throw the given `err` in context to the\r\n\t * the jade in `filename` at the given `lineno`.\r\n\t *\r\n\t * @param {Error} err\r\n\t * @param {String} filename\r\n\t * @param {String} lineno\r\n\t * @api private\r\n\t */\r\n\t\r\n\texports.rethrow = function rethrow(err, filename, lineno, str){\r\n\t  if (!(err instanceof Error)) throw err;\r\n\t  if ((typeof window != 'undefined' || !filename) && !str) {\r\n\t    err.message += ' on line ' + lineno;\r\n\t    throw err;\r\n\t  }\r\n\t  try {\r\n\t    str = str || __webpack_require__(19).readFileSync(filename, 'utf8')\r\n\t  } catch (ex) {\r\n\t    rethrow(err, null, lineno)\r\n\t  }\r\n\t  var context = 3\r\n\t    , lines = str.split('\\n')\r\n\t    , start = Math.max(lineno - context, 0)\r\n\t    , end = Math.min(lines.length, lineno + context);\r\n\t\r\n\t  // Error context\r\n\t  var context = lines.slice(start, end).map(function(line, i){\r\n\t    var curr = i + start + 1;\r\n\t    return (curr == lineno ? '  > ' : '    ')\r\n\t      + curr\r\n\t      + '| '\r\n\t      + line;\r\n\t  }).join('\\n');\r\n\t\r\n\t  // Alter exception message\r\n\t  err.path = filename;\r\n\t  err.message = (filename || 'Jade') + ':' + lineno\r\n\t    + '\\n' + context + '\\n\\n' + err.message;\r\n\t  throw err;\r\n\t};\r\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar jade = __webpack_require__(6);\n\t\n\tmodule.exports = function template(locals) {\n\tvar buf = [];\n\tvar jade_mixins = {};\n\tvar jade_interp;\n\t\n\tbuf.push(\"<div class=\\\"row\\\"><div class=\\\"col-md-12\\\"><form class=\\\"form-horizontal\\\"><div class=\\\"form-group\\\"><label for=\\\"url\\\" class=\\\"col-sm-2 control-label\\\">Entity URI:</label><div class=\\\"col-sm-8\\\"><input id=\\\"url\\\" type=\\\"text\\\" ng-model=\\\"showCtrl.url\\\" class=\\\"form-control\\\"/></div><div class=\\\"col-sm-1\\\"><button ui-sref=\\\"siren-browser({url:showCtrl.url})\\\" class=\\\"form-control btn btn-primary\\\">Go</button></div></div></form></div></div><div class=\\\"row\\\"><div class=\\\"col-md-8 col-md-offset-2\\\"><alert ng-repeat=\\\"alert in alerts\\\" type=\\\"{{alert.type}}\\\" close=\\\"alerts.splice(index, 1)\\\">{{alert.msg}}</alert></div></div><div id=\\\"response\\\" class=\\\"row\\\"><div class=\\\"col-md-4\\\"><div id=\\\"class\\\" ng-show=\\\"showCtrl.class\\\"><h3>Class</h3><pre>{{showCtrl.class}}</pre></div><div id=\\\"properties\\\" ng-show=\\\"showCtrl.properties\\\"><h3>Properties</h3><pre>{{showCtrl.properties | prettify}}</pre></div><div id=\\\"links\\\" ng-show=\\\"showCtrl.links.length\\\"><h3>Links</h3><ul><li ng-repeat=\\\"link in showCtrl.links\\\"><a href=\\\"#/siren-browser?url={{ link.href | encodeURIComponent }}\\\">{{link.rel}}</a></li></ul></div></div><div class=\\\"col-md-6\\\"><div id=\\\"actions\\\" ng-show=\\\"showCtrl.actions.length\\\"><h3>Actions</h3><accordion close-others=\\\"true\\\"><accordion-group ng-repeat=\\\"action in showCtrl.actions\\\" is-open=\\\"$first\\\"><accordion-heading><span ng-show=\\\"action.title\\\">{{action.title}}</span><span ng-show=\\\"!action.title\\\">{{action.name}}</span></accordion-heading><tabset><tab heading=\\\"Form\\\"><action-form ng-model=\\\"action\\\"></action-form></tab><tab heading=\\\"Source\\\"><pre>| {{ action | prettify }}</pre></tab></tabset></accordion-group></accordion></div><div id=\\\"entities\\\" ng-show=\\\"showCtrl.entities.length\\\"><h3>Entities</h3><div><label class=\\\"checkbox\\\"><input id=\\\"oneAtATime\\\" type=\\\"checkbox\\\" ng-model=\\\"isOneAtATime\\\"/>Open only one at a time</label></div><br/><accordion close-others=\\\"isOneAtATime\\\"><accordion-group ng-repeat=\\\"entity in showCtrl.entities\\\" heading=\\\"class: {{entity.class}}\\\" is-open=\\\"$first\\\"><div ng-show=\\\"entity.properties\\\"><h4>Properties</h4><pre>{{entity.properties | prettify}}</pre></div><div ng-show=\\\"entity.links\\\"><h4>Links</h4><ul><li ng-repeat=\\\"link in entity.links\\\"><a ui-sref=\\\"siren-browser({url:link.href})\\\">{{link.rel}}</a></li></ul></div><div ng-show=\\\"entity.href\\\">href:<a ui-sref=\\\"siren-browser({url:entity.href})\\\">{{entity.href}}</a></div><div ng-show=\\\"entity.actions\\\"><h4>Actions</h4><div class=\\\"btn-group-vertical\\\"><button ng-repeat=\\\"action in entity.actions\\\" ng-click=\\\"showCtrl.openActionModal(action)\\\" class=\\\"btn btn-default\\\">Action {{action.name}}</button></div></div></accordion-group></accordion></div></div></div>\");;return buf.join(\"\");\n\t}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  var showCtrl;\n\t  __webpack_require__(5);\n\t  __webpack_require__(13);\n\t  showCtrl = function($scope, $stateParams, $rootScope, sirenEntity, $modal) {\n\t    $rootScope.alerts = [];\n\t    this.url = $stateParams.url;\n\t    this.actions = sirenEntity.data.actions;\n\t    this[\"class\"] = sirenEntity.data[\"class\"];\n\t    this.properties = sirenEntity.data.properties;\n\t    this.links = sirenEntity.data.links;\n\t    this.entities = sirenEntity.data.entities;\n\t    this.openActionModal = function(action) {\n\t      var modalInstance;\n\t      return modalInstance = $modal.open({\n\t        template: __webpack_require__(14),\n\t        controller: 'actionModalCtrl as actionModalCtrl',\n\t        resolve: {\n\t          action: function() {\n\t            return action;\n\t          }\n\t        },\n\t        size: 'lg'\n\t      });\n\t    };\n\t  };\n\t  return angular.module(\"SirenBrowser\").controller(\"showCtrl\", ['$scope', '$stateParams', '$rootScope', 'sirenEntity', '$modal', showCtrl]);\n\t})();\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  var actionForm;\n\t  actionForm = function() {\n\t    return {\n\t      restrict: 'E',\n\t      template: __webpack_require__(17),\n\t      require: \"ngModel\",\n\t      scope: {\n\t        action: '=ngModel'\n\t      },\n\t      controller: \"actionFromCtrl as actionFromCtrl\"\n\t    };\n\t  };\n\t  __webpack_require__(18);\n\t  return angular.module(\"SirenBrowser\").directive(\"actionForm\", actionForm);\n\t})();\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  var entityResolver;\n\t  __webpack_require__(5);\n\t  entityResolver = function($rootScope, sirenBrowserHttp) {\n\t    var EntityResolverClass;\n\t    EntityResolverClass = (function() {\n\t      function EntityResolverClass() {\n\t        this.cachedEntity = null;\n\t      }\n\t\n\t      EntityResolverClass.prototype.cacheEntity = function(entity) {\n\t        return this.cachedEntity = entity;\n\t      };\n\t\n\t      EntityResolverClass.prototype.resolve = function(url) {\n\t        var entity;\n\t        if ((entity = this.cachedEntity)) {\n\t          this.cachedEntity = null;\n\t          return entity;\n\t        } else {\n\t          if (url) {\n\t            return sirenBrowserHttp.request({\n\t              method: 'GET',\n\t              url: url\n\t            });\n\t          } else {\n\t            return {\n\t              data: {}\n\t            };\n\t          }\n\t        }\n\t      };\n\t\n\t      return EntityResolverClass;\n\t\n\t    })();\n\t    return new EntityResolverClass;\n\t  };\n\t  return angular.module('SirenBrowser').service(\"entityResolver\", ['$rootScope', 'sirenBrowserHttp', entityResolver]);\n\t})();\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  var sirenBrowserHttp;\n\t  __webpack_require__(5);\n\t  sirenBrowserHttp = function($rootScope, $http) {\n\t    var SirenBrowserHttpClass;\n\t    SirenBrowserHttpClass = (function() {\n\t      function SirenBrowserHttpClass() {}\n\t\n\t      SirenBrowserHttpClass.prototype.request = function(options) {\n\t        return $rootScope.myPromise = $http(options).error(function(data, status) {\n\t          var msg;\n\t          msg = 'HTTP Error ' + status + ': ' + JSON.stringify(data.properties);\n\t          $rootScope.alerts = [];\n\t          $rootScope.alerts.push({\n\t            type: 'danger',\n\t            msg: msg\n\t          });\n\t          console.log(\"error in get  status=\" + status, data.properties);\n\t        });\n\t      };\n\t\n\t      return SirenBrowserHttpClass;\n\t\n\t    })();\n\t    return new SirenBrowserHttpClass;\n\t  };\n\t  return angular.module('SirenBrowser').service(\"sirenBrowserHttp\", ['$rootScope', '$http', sirenBrowserHttp]);\n\t})();\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tangular.module(\"cgBusy\",[]),angular.module(\"cgBusy\").factory(\"_cgBusyTrackerFactory\",[\"$timeout\",\"$q\",function(a,b){return function(){var c={};c.promises=[],c.delayPromise=null,c.durationPromise=null,c.delayJustFinished=!1,c.reset=function(b){c.minDuration=b.minDuration,c.promises=[],angular.forEach(b.promises,function(a){a&&!a.$cgBusyFulfilled&&d(a)}),0!==c.promises.length&&(c.delayJustFinished=!1,b.delay&&(c.delayPromise=a(function(){c.delayPromise=null,c.delayJustFinished=!0},parseInt(b.delay,10))),b.minDuration&&(c.durationPromise=a(function(){c.durationPromise=null},parseInt(b.minDuration,10)+(b.delay?parseInt(b.delay,10):0))))},c.getThen=function(a){var c=a&&(a.then||a.$then||a.$promise&&a.$promise.then);return a.denodeify?b.when(a).then:c};var d=function(a){var b=c.getThen(a);if(!b)throw new Error(\"cgBusy expects a promise (or something that has a .promise or .$promise\");-1===c.promises.indexOf(a)&&(c.promises.push(a),b(function(){a.$cgBusyFulfilled=!0,-1!==c.promises.indexOf(a)&&c.promises.splice(c.promises.indexOf(a),1)},function(){a.$cgBusyFulfilled=!0,-1!==c.promises.indexOf(a)&&c.promises.splice(c.promises.indexOf(a),1)}))};return c.active=function(){return c.delayPromise?!1:c.delayJustFinished?(c.delayJustFinished=!1,c.promises.length>0):c.durationPromise?!0:c.promises.length>0},c}}]),angular.module(\"cgBusy\").value(\"cgBusyDefaults\",{}),angular.module(\"cgBusy\").directive(\"cgBusy\",[\"$compile\",\"$templateCache\",\"cgBusyDefaults\",\"$http\",\"_cgBusyTrackerFactory\",function(a,b,c,d,e){return{restrict:\"A\",link:function(f,g,h){var i=g.css(\"position\");(\"static\"===i||\"\"===i||\"undefined\"==typeof i)&&g.css(\"position\",\"relative\");var j,k,l,m,n,o=e(),p={templateUrl:\"angular-busy.html\",delay:0,minDuration:0,backdrop:!0,message:\"Please Wait...\"};angular.extend(p,c),f.$watchCollection(h.cgBusy,function(c){if(c||(c={promise:null}),angular.isString(c))throw new Error(\"Invalid value for cg-busy.  cgBusy no longer accepts string ids to represent promises/trackers.\");(angular.isArray(c)||o.getThen(c))&&(c={promise:c}),c=angular.extend(angular.copy(p),c),c.templateUrl||(c.templateUrl=p.templateUrl),angular.isArray(c.promise)||(c.promise=[c.promise]),m||(m=f.$new()),m.$message=c.message,angular.equals(o.promises,c.promise)||o.reset({promises:c.promise,delay:c.delay,minDuration:c.minDuration}),m.$cgBusyIsActive=function(){return o.active()},j&&l===c.templateUrl&&n===c.backdrop||(j&&j.remove(),k&&k.remove(),l=c.templateUrl,n=c.backdrop,d.get(l,{cache:b}).success(function(b){if(c.backdrop=\"undefined\"==typeof c.backdrop?!0:c.backdrop,c.backdrop){var d='<div class=\"cg-busy cg-busy-backdrop cg-busy-backdrop-animation ng-hide\" ng-show=\"$cgBusyIsActive()\"></div>';k=a(d)(m),g.append(k)}var e='<div class=\"cg-busy cg-busy-animation ng-hide\" ng-show=\"$cgBusyIsActive()\">'+b+\"</div>\";j=a(e)(m),angular.element(j.children()[0]).css(\"position\",\"absolute\").css(\"top\",0).css(\"left\",0).css(\"right\",0).css(\"bottom\",0),g.append(j)}).error(function(a){throw new Error(\"Template specified for cgBusy (\"+c.templateUrl+\") could not be loaded. \"+a)}))},!0)}}}]),angular.module(\"cgBusy\").run([\"$templateCache\",function(a){\"use strict\";a.put(\"angular-busy.html\",'<div class=\"cg-busy-default-wrapper\">\\n\\n   <div class=\"cg-busy-default-sign\">\\n\\n      <div class=\"cg-busy-default-spinner\">\\n         <div class=\"bar1\"></div>\\n         <div class=\"bar2\"></div>\\n         <div class=\"bar3\"></div>\\n         <div class=\"bar4\"></div>\\n         <div class=\"bar5\"></div>\\n         <div class=\"bar6\"></div>\\n         <div class=\"bar7\"></div>\\n         <div class=\"bar8\"></div>\\n         <div class=\"bar9\"></div>\\n         <div class=\"bar10\"></div>\\n         <div class=\"bar11\"></div>\\n         <div class=\"bar12\"></div>\\n      </div>\\n\\n      <div class=\"cg-busy-default-text\">{{$message}}</div>\\n\\n   </div>\\n\\n</div>')}]);\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  var actionModalCtrl;\n\t  __webpack_require__(5);\n\t  actionModalCtrl = function($scope, $modalInstance, action) {\n\t    this.action = action;\n\t    this.close = function() {\n\t      return $modalInstance.dismiss('cancel');\n\t    };\n\t  };\n\t  return angular.module(\"SirenBrowser\").controller(\"actionModalCtrl\", ['$scope', '$modalInstance', 'action', actionModalCtrl]);\n\t})();\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar jade = __webpack_require__(6);\n\t\n\tmodule.exports = function template(locals) {\n\tvar buf = [];\n\tvar jade_mixins = {};\n\tvar jade_interp;\n\t\n\tbuf.push(\"<div class=\\\"modal-header\\\"><h3 class=\\\"modal-title\\\">{{actionModalCtrl.action.name}}</h3></div><div class=\\\"modal-body\\\"><tabset><tab heading=\\\"Form\\\"><action-form ng-model=\\\"actionModalCtrl.action\\\"></action-form></tab><tab heading=\\\"Source\\\"><pre>| {{ actionModalCtrl.action | prettify }}</pre></tab></tabset></div>\");;return buf.join(\"\");\n\t}\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(16);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(20)(content);\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tmodule.hot.accept(\"!!/home/travis/build/applicaster/siren-browser/node_modules/css-loader/index.js!/home/travis/build/applicaster/siren-browser/bower_components/angular-busy/dist/angular-busy.min.css\", function() {\n\t\t\tvar newContent = require(\"!!/home/travis/build/applicaster/siren-browser/node_modules/css-loader/index.js!/home/travis/build/applicaster/siren-browser/bower_components/angular-busy/dist/angular-busy.min.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [module.id, newContent, ''];\n\t\t\tupdate(newContent);\n\t\t});\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(21)();\n\texports.push([module.id, \".cg-busy{position:absolute;top:0;left:0;right:0;bottom:0;z-index:1001}.cg-busy-animation.ng-hide-add,.cg-busy-animation.ng-hide-remove{-webkit-transition:all .3s ease;-moz-transition:all .3s ease;-o-transition:all .3s ease;transition:all .3s ease;display:block!important}.cg-busy-animation.ng-hide-remove{opacity:0;-webkit-transform:translate(0,-40px);-moz-transform:translate(0,-40px);-ms-transform:translate(0,-40px);-o-transform:translate(0,-40px);transform:translate(0,-40px)}.cg-busy-animation.ng-hide-add,.cg-busy-animation.ng-hide-remove.ng-hide-remove-active{opacity:1;-webkit-transform:translate(0,0);-moz-transform:translate(0,0);-ms-transform:translate(0,0);-o-transform:translate(0,0);transform:translate(0,0)}.cg-busy-animation.ng-hide-add.ng-hide-add-active{opacity:0;-webkit-transform:translate(0,-40px);-moz-transform:translate(0,-40px);-ms-transform:translate(0,-40px);-o-transform:translate(0,-40px);transform:translate(0,-40px)}.cg-busy-backdrop{background-color:#fff;opacity:.7}.cg-busy-backdrop-animation.ng-hide-add,.cg-busy-backdrop-animation.ng-hide-remove{-webkit-transition:opacity .3s ease;-moz-transition:opacity .3s ease;-o-transition:opacity .3s ease;transition:opacity .3s ease;display:block!important}.cg-busy-backdrop-animation.ng-hide{opacity:0}.cg-busy-default-wrapper{text-align:center}.cg-busy-default-sign{display:inline-block;position:relative;z-index:1002;padding-bottom:6px;color:#333;text-shadow:0 1px 1px rgba(255,255,255,.75);background-color:#e9eeee;border:1px solid #ddd;border-top-width:0;-webkit-border-radius:7px;-moz-border-radius:7px;border-radius:7px;border-top-left-radius:0;border-top-right-radius:0;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05);box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05)}.cg-busy-default-text{margin:13px 12px 6px 49px;font-size:16px;color:#555;text-align:left;max-width:400px}.cg-busy-default-spinner{position:absolute;width:25px;height:25px;display:inline-block;top:12px;left:14px}.cg-busy-default-spinner div{width:12%;height:26%;background:#000;position:absolute;left:44.5%;top:37%;opacity:0;-webkit-animation:cg-busy-spinner-anim 1s linear infinite;-moz-animation:cg-busy-spinner-anim 1s linear infinite;-ms-animation:cg-busy-spinner-anim 1s linear infinite;-o-animation:cg-busy-spinner-anim 1s linear infinite;animation:cg-busy-spinner-anim 1s linear infinite;-webkit-border-radius:50px;-moz-border-radius:50px;border-radius:50px;-webkit-box-shadow:0 0 3px rgba(0,0,0,.2);-moz-box-shadow:0 0 3px rgba(0,0,0,.2);box-shadow:0 0 3px rgba(0,0,0,.2)}.cg-busy-default-spinner div.bar1{-webkit-transform:rotate(0)translate(0,-142%);-moz-transform:rotate(0)translate(0,-142%);-ms-transform:rotate(0)translate(0,-142%);-o-transform:rotate(0)translate(0,-142%);transform:rotate(0)translate(0,-142%);-webkit-animation-delay:0;-moz-animation-delay:0;-ms-animation-delay:0;-o-animation-delay:0;animation-delay:0}.cg-busy-default-spinner div.bar2{-webkit-transform:rotate(30deg)translate(0,-142%);-moz-transform:rotate(30deg)translate(0,-142%);-ms-transform:rotate(30deg)translate(0,-142%);-o-transform:rotate(30deg)translate(0,-142%);transform:rotate(30deg)translate(0,-142%);-webkit-animation-delay:-.9167s;-moz-animation-delay:-.9167s;-ms-animation-delay:-.9167s;-o-animation-delay:-.9167s;animation-delay:-.9167s}.cg-busy-default-spinner div.bar3{-webkit-transform:rotate(60deg)translate(0,-142%);-moz-transform:rotate(60deg)translate(0,-142%);-ms-transform:rotate(60deg)translate(0,-142%);-o-transform:rotate(60deg)translate(0,-142%);transform:rotate(60deg)translate(0,-142%);-webkit-animation-delay:-.833s;-moz-animation-delay:-.833s;-ms-animation-delay:-.833s;-o-animation-delay:-.833s;animation-delay:-.833s}.cg-busy-default-spinner div.bar4{-webkit-transform:rotate(90deg)translate(0,-142%);-moz-transform:rotate(90deg)translate(0,-142%);-ms-transform:rotate(90deg)translate(0,-142%);-o-transform:rotate(90deg)translate(0,-142%);transform:rotate(90deg)translate(0,-142%);-webkit-animation-delay:-.75s;-moz-animation-delay:-.75s;-ms-animation-delay:-.75s;-o-animation-delay:-.75s;animation-delay:-.75s}.cg-busy-default-spinner div.bar5{-webkit-transform:rotate(120deg)translate(0,-142%);-moz-transform:rotate(120deg)translate(0,-142%);-ms-transform:rotate(120deg)translate(0,-142%);-o-transform:rotate(120deg)translate(0,-142%);transform:rotate(120deg)translate(0,-142%);-webkit-animation-delay:-.667s;-moz-animation-delay:-.667s;-ms-animation-delay:-.667s;-o-animation-delay:-.667s;animation-delay:-.667s}.cg-busy-default-spinner div.bar6{-webkit-transform:rotate(150deg)translate(0,-142%);-moz-transform:rotate(150deg)translate(0,-142%);-ms-transform:rotate(150deg)translate(0,-142%);-o-transform:rotate(150deg)translate(0,-142%);transform:rotate(150deg)translate(0,-142%);-webkit-animation-delay:-.5833s;-moz-animation-delay:-.5833s;-ms-animation-delay:-.5833s;-o-animation-delay:-.5833s;animation-delay:-.5833s}.cg-busy-default-spinner div.bar7{-webkit-transform:rotate(180deg)translate(0,-142%);-moz-transform:rotate(180deg)translate(0,-142%);-ms-transform:rotate(180deg)translate(0,-142%);-o-transform:rotate(180deg)translate(0,-142%);transform:rotate(180deg)translate(0,-142%);-webkit-animation-delay:-.5s;-moz-animation-delay:-.5s;-ms-animation-delay:-.5s;-o-animation-delay:-.5s;animation-delay:-.5s}.cg-busy-default-spinner div.bar8{-webkit-transform:rotate(210deg)translate(0,-142%);-moz-transform:rotate(210deg)translate(0,-142%);-ms-transform:rotate(210deg)translate(0,-142%);-o-transform:rotate(210deg)translate(0,-142%);transform:rotate(210deg)translate(0,-142%);-webkit-animation-delay:-.41667s;-moz-animation-delay:-.41667s;-ms-animation-delay:-.41667s;-o-animation-delay:-.41667s;animation-delay:-.41667s}.cg-busy-default-spinner div.bar9{-webkit-transform:rotate(240deg)translate(0,-142%);-moz-transform:rotate(240deg)translate(0,-142%);-ms-transform:rotate(240deg)translate(0,-142%);-o-transform:rotate(240deg)translate(0,-142%);transform:rotate(240deg)translate(0,-142%);-webkit-animation-delay:-.333s;-moz-animation-delay:-.333s;-ms-animation-delay:-.333s;-o-animation-delay:-.333s;animation-delay:-.333s}.cg-busy-default-spinner div.bar10{-webkit-transform:rotate(270deg)translate(0,-142%);-moz-transform:rotate(270deg)translate(0,-142%);-ms-transform:rotate(270deg)translate(0,-142%);-o-transform:rotate(270deg)translate(0,-142%);transform:rotate(270deg)translate(0,-142%);-webkit-animation-delay:-.25s;-moz-animation-delay:-.25s;-ms-animation-delay:-.25s;-o-animation-delay:-.25s;animation-delay:-.25s}.cg-busy-default-spinner div.bar11{-webkit-transform:rotate(300deg)translate(0,-142%);-moz-transform:rotate(300deg)translate(0,-142%);-ms-transform:rotate(300deg)translate(0,-142%);-o-transform:rotate(300deg)translate(0,-142%);transform:rotate(300deg)translate(0,-142%);-webkit-animation-delay:-.1667s;-moz-animation-delay:-.1667s;-ms-animation-delay:-.1667s;-o-animation-delay:-.1667s;animation-delay:-.1667s}.cg-busy-default-spinner div.bar12{-webkit-transform:rotate(330deg)translate(0,-142%);-moz-transform:rotate(330deg)translate(0,-142%);-ms-transform:rotate(330deg)translate(0,-142%);-o-transform:rotate(330deg)translate(0,-142%);transform:rotate(330deg)translate(0,-142%);-webkit-animation-delay:-.0833s;-moz-animation-delay:-.0833s;-ms-animation-delay:-.0833s;-o-animation-delay:-.0833s;animation-delay:-.0833s}@-webkit-keyframes cg-busy-spinner-anim{from{opacity:1}to{opacity:.25}}@-moz-keyframes cg-busy-spinner-anim{from{opacity:1}to{opacity:.25}}@keyframes cg-busy-spinner-anim{from{opacity:1}to{opacity:.25}}\", \"\"]);\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar jade = __webpack_require__(6);\n\t\n\tmodule.exports = function template(locals) {\n\tvar buf = [];\n\tvar jade_mixins = {};\n\tvar jade_interp;\n\t\n\tbuf.push(\"<form ng-submit=\\\"actionFromCtrl.submit(action); $parent.$close()\\\"><div ng-repeat=\\\"field in action.fields\\\"><div ng-if=\\\"field.type == 'checkbox' || field.type == 'radio'\\\" class=\\\"form-group\\\"><label>{{field.title}}</label><div ng-repeat=\\\"option in field.value\\\" class=\\\"checkbox radio\\\"><label><input type=\\\"{{field.type}}\\\" name=\\\"{{field.name}}\\\" value=\\\"{{option.value}}\\\" ng-checked=\\\"option.selected\\\"/>{{option.title}}</label></div></div><div ng-if=\\\"field.type != 'checkbox'  &amp;&amp; field.type != 'radio'\\\" class=\\\"form-group\\\"><label ng-if=\\\"field.type != 'hidden'\\\">{{field.title}}</label><input type=\\\"{{field.type}}\\\" name=\\\"{{field.name}}\\\" value=\\\"{{field.value}}\\\" class=\\\"form-control\\\"/></div></div><input type=\\\"submit\\\" class=\\\"btn btn-primary\\\"/></form>\");;return buf.join(\"\");\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  var actionFromCtrl;\n\t  __webpack_require__(22);\n\t  __webpack_require__(10);\n\t  actionFromCtrl = function($scope, $element, sirenBrowserHttp, $state, $rootScope, entityResolver, actionsUtils) {\n\t    this.submit = function(action) {\n\t      var formData, options;\n\t      formData = $element.find(\"form\").serialize();\n\t      options = actionsUtils.renderOptions(action, formData);\n\t      $rootScope.entityUrl = options.url;\n\t      return sirenBrowserHttp.request(options).success(function(data) {\n\t        var url;\n\t        entityResolver.cacheEntity({\n\t          data: data\n\t        });\n\t        url = $rootScope.entityUrl;\n\t        options = {\n\t          notify: true,\n\t          reload: true\n\t        };\n\t        return $state.go('siren-browser', {\n\t          url: url\n\t        }, options);\n\t      });\n\t    };\n\t  };\n\t  return angular.module(\"SirenBrowser\").controller(\"actionFromCtrl\", ['$scope', '$element', 'sirenBrowserHttp', '$state', '$rootScope', 'entityResolver', 'actionsUtils', actionFromCtrl]);\n\t})();\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tconsole.log(\"I'm `fs` modules\");\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {};\r\n\t\r\n\tmodule.exports = function(list) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles);\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j]));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j]));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\t// var sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media/*, sourceMap: sourceMap*/};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tvar head = document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\thead.appendChild(styleElement);\r\n\t\tapplyToTag(styleElement, obj);\r\n\t\treturn function(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media /*&& newObj.sourceMap === obj.sourceMap*/)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tapplyToTag(styleElement, obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\thead.removeChild(styleElement);\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\t// var sourceMap = obj.sourceMap;\r\n\t\r\n\t\t// No browser support\r\n\t\t// if(sourceMap && typeof btoa === \"function\") {\r\n\t\t\t// try {\r\n\t\t\t\t// css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(JSON.stringify(sourceMap)) + \" */\";\r\n\t\t\t// } catch(e) {}\r\n\t\t// }\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t\r\n\t}\r\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\treturn list;\r\n\t}\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  var actionsUtils;\n\t  __webpack_require__(5);\n\t  __webpack_require__(23);\n\t  actionsUtils = function() {\n\t    return {\n\t      resolveFormContentType: function(enctype) {\n\t        if (enctype == null) {\n\t          enctype = 'application/x-www-form-urlencoded';\n\t        }\n\t        return enctype;\n\t      },\n\t      _proecessUrlecoded: function(data) {\n\t        return data;\n\t      },\n\t      _processJson: function(data) {\n\t        return $.deparam(data, true);\n\t      },\n\t      formDataContentTypeConverter: function(data, enctype) {\n\t        var convertedData, processFormData;\n\t        processFormData = {\n\t          'application/x-www-form-urlencoded': this._proecessUrlecoded,\n\t          'application/json': this._processJson\n\t        };\n\t        if (processFormData[enctype]) {\n\t          convertedData = processFormData[enctype](data);\n\t        } else {\n\t          throw new Error(\"Form content type not suppoted.\");\n\t        }\n\t        return convertedData;\n\t      },\n\t      _urlBuilderGET: function(url, queryString) {\n\t        var separator;\n\t        separator = url.search(/\\?/) > 0 ? \"&\" : \"?\";\n\t        return url + separator + queryString;\n\t      },\n\t      renderOptions: function(action, formData) {\n\t        var data, options, resolveFormContentType;\n\t        resolveFormContentType = this.resolveFormContentType(action.type);\n\t        options = {\n\t          method: action.method,\n\t          url: action.href,\n\t          headers: {\n\t            'Content-Type': resolveFormContentType,\n\t            'Accept': 'application/vnd.siren+json, application/json, text/plain, */*'\n\t          }\n\t        };\n\t        data = this.formDataContentTypeConverter(formData, resolveFormContentType);\n\t        if (action.method === 'GET') {\n\t          options.url = this._urlBuilderGET(options.url, data);\n\t        } else {\n\t          options.data = data;\n\t        }\n\t        return options;\n\t      }\n\t    };\n\t  };\n\t  return angular.module('SirenBrowser').factory(\"actionsUtils\", [actionsUtils]);\n\t})();\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * jQuery BBQ: Back Button & Query Library - v1.3pre - 8/26/2010\n\t * http://benalman.com/projects/jquery-bbq-plugin/\n\t *\n\t * Copyright (c) 2010 \"Cowboy\" Ben Alman\n\t * Dual licensed under the MIT and GPL licenses.\n\t * http://benalman.com/about/license/\n\t */\n\t\n\t// Script: jQuery BBQ: Back Button & Query Library\n\t//\n\t// *Version: 1.3pre, Last updated: 8/26/2010*\n\t//\n\t// Project Home - http://benalman.com/projects/jquery-bbq-plugin/\n\t// GitHub       - http://github.com/cowboy/jquery-bbq/\n\t// Source       - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.js\n\t// (Minified)   - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.min.js (2.2kb gzipped)\n\t//\n\t// About: License\n\t//\n\t// Copyright (c) 2010 \"Cowboy\" Ben Alman,\n\t// Dual licensed under the MIT and GPL licenses.\n\t// http://benalman.com/about/license/\n\t//\n\t// About: Examples\n\t//\n\t// These working examples, complete with fully commented code, illustrate a few\n\t// ways in which this plugin can be used.\n\t//\n\t// Basic AJAX     - http://benalman.com/code/projects/jquery-bbq/examples/fragment-basic/\n\t// Advanced AJAX  - http://benalman.com/code/projects/jquery-bbq/examples/fragment-advanced/\n\t// jQuery UI Tabs - http://benalman.com/code/projects/jquery-bbq/examples/fragment-jquery-ui-tabs/\n\t// Deparam        - http://benalman.com/code/projects/jquery-bbq/examples/deparam/\n\t//\n\t// About: Support and Testing\n\t//\n\t// Information about what version or versions of jQuery this plugin has been\n\t// tested with, what browsers it has been tested in, and where the unit tests\n\t// reside (so you can test it yourself).\n\t//\n\t// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2\n\t// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,\n\t//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.\n\t// Unit Tests      - http://benalman.com/code/projects/jquery-bbq/unit/\n\t//\n\t// About: Release History\n\t//\n\t// 1.3pre - (8/26/2010) Integrated <jQuery hashchange event> v1.3, which adds\n\t//         document.title and document.domain support in IE6/7, BlackBerry\n\t//         support, better Iframe hiding for accessibility reasons, and the new\n\t//         <jQuery.fn.hashchange> \"shortcut\" method. Added the\n\t//         <jQuery.param.sorted> method which reduces the possibility of\n\t//         extraneous hashchange event triggering. Added the\n\t//         <jQuery.param.fragment.ajaxCrawlable> method which can be used to\n\t//         enable Google \"AJAX Crawlable mode.\"\n\t// 1.2.1 - (2/17/2010) Actually fixed the stale window.location Safari bug from\n\t//         <jQuery hashchange event> in BBQ, which was the main reason for the\n\t//         previous release!\n\t// 1.2   - (2/16/2010) Integrated <jQuery hashchange event> v1.2, which fixes a\n\t//         Safari bug, the event can now be bound before DOM ready, and IE6/7\n\t//         page should no longer scroll when the event is first bound. Also\n\t//         added the <jQuery.param.fragment.noEscape> method, and reworked the\n\t//         <hashchange event (BBQ)> internal \"add\" method to be compatible with\n\t//         changes made to the jQuery 1.4.2 special events API.\n\t// 1.1.1 - (1/22/2010) Integrated <jQuery hashchange event> v1.1, which fixes an\n\t//         obscure IE8 EmulateIE7 meta tag compatibility mode bug.\n\t// 1.1   - (1/9/2010) Broke out the jQuery BBQ event.special <hashchange event>\n\t//         functionality into a separate plugin for users who want just the\n\t//         basic event & back button support, without all the extra awesomeness\n\t//         that BBQ provides. This plugin will be included as part of jQuery BBQ,\n\t//         but also be available separately. See <jQuery hashchange event>\n\t//         plugin for more information. Also added the <jQuery.bbq.removeState>\n\t//         method and added additional <jQuery.deparam> examples.\n\t// 1.0.3 - (12/2/2009) Fixed an issue in IE 6 where location.search and\n\t//         location.hash would report incorrectly if the hash contained the ?\n\t//         character. Also <jQuery.param.querystring> and <jQuery.param.fragment>\n\t//         will no longer parse params out of a URL that doesn't contain ? or #,\n\t//         respectively.\n\t// 1.0.2 - (10/10/2009) Fixed an issue in IE 6/7 where the hidden IFRAME caused\n\t//         a \"This page contains both secure and nonsecure items.\" warning when\n\t//         used on an https:// page.\n\t// 1.0.1 - (10/7/2009) Fixed an issue in IE 8. Since both \"IE7\" and \"IE8\n\t//         Compatibility View\" modes erroneously report that the browser\n\t//         supports the native window.onhashchange event, a slightly more\n\t//         robust test needed to be added.\n\t// 1.0   - (10/2/2009) Initial release\n\t\n\t(function($,window){\n\t  '$:nomunge'; // Used by YUI compressor.\n\t\n\t  // Some convenient shortcuts.\n\t  var undefined,\n\t    aps = Array.prototype.slice,\n\t    decode = decodeURIComponent,\n\t\n\t    // Method / object references.\n\t    jq_param = $.param,\n\t    jq_param_sorted,\n\t    jq_param_fragment,\n\t    jq_deparam,\n\t    jq_deparam_fragment,\n\t    jq_bbq = $.bbq = $.bbq || {},\n\t    jq_bbq_pushState,\n\t    jq_bbq_getState,\n\t    jq_elemUrlAttr,\n\t    special = $.event.special,\n\t\n\t    // Reused strings.\n\t    str_hashchange = 'hashchange',\n\t    str_querystring = 'querystring',\n\t    str_fragment = 'fragment',\n\t    str_elemUrlAttr = 'elemUrlAttr',\n\t    str_href = 'href',\n\t    str_src = 'src',\n\t\n\t    // Reused RegExp.\n\t    re_params_querystring = /^.*\\?|#.*$/g,\n\t    re_params_fragment,\n\t    re_fragment,\n\t    re_no_escape,\n\t\n\t    ajax_crawlable,\n\t    fragment_prefix,\n\t\n\t    // Used by jQuery.elemUrlAttr.\n\t    elemUrlAttr_cache = {};\n\t\n\t  // A few commonly used bits, broken out to help reduce minified file size.\n\t\n\t  function is_string( arg ) {\n\t    return typeof arg === 'string';\n\t  };\n\t\n\t  // Why write the same function twice? Let's curry! Mmmm, curry..\n\t\n\t  function curry( func ) {\n\t    var args = aps.call( arguments, 1 );\n\t\n\t    return function() {\n\t      return func.apply( this, args.concat( aps.call( arguments ) ) );\n\t    };\n\t  };\n\t\n\t  // Get location.hash (or what you'd expect location.hash to be) sans any\n\t  // leading #. Thanks for making this necessary, Firefox!\n\t  function get_fragment( url ) {\n\t    return url.replace( re_fragment, '$2' );\n\t  };\n\t\n\t  // Get location.search (or what you'd expect location.search to be) sans any\n\t  // leading #. Thanks for making this necessary, IE6!\n\t  function get_querystring( url ) {\n\t    return url.replace( /(?:^[^?#]*\\?([^#]*).*$)?.*/, '$1' );\n\t  };\n\t\n\t  // Section: Param (to string)\n\t  //\n\t  // Method: jQuery.param.querystring\n\t  //\n\t  // Retrieve the query string from a URL or if no arguments are passed, the\n\t  // current window.location.href.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.param.querystring( [ url ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  url - (String) A URL containing query string params to be parsed. If url\n\t  //    is not passed, the current window.location.href is used.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (String) The parsed query string, with any leading \"?\" removed.\n\t  //\n\t\n\t  // Method: jQuery.param.querystring (build url)\n\t  //\n\t  // Merge a URL, with or without pre-existing query string params, plus any\n\t  // object, params string or URL containing query string params into a new URL.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.param.querystring( url, params [, merge_mode ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  url - (String) A valid URL for params to be merged into. This URL may\n\t  //    contain a query string and/or fragment (hash).\n\t  //  params - (String) A params string or URL containing query string params to\n\t  //    be merged into url.\n\t  //  params - (Object) A params object to be merged into url.\n\t  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not\n\t  //    specified, and is as-follows:\n\t  //\n\t  //    * 0: params in the params argument will override any query string\n\t  //         params in url.\n\t  //    * 1: any query string params in url will override params in the params\n\t  //         argument.\n\t  //    * 2: params argument will completely replace any query string in url.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (String) A URL with a urlencoded query string in the format '?a=b&c=d&e=f'.\n\t\n\t  // Method: jQuery.param.fragment\n\t  //\n\t  // Retrieve the fragment (hash) from a URL or if no arguments are passed, the\n\t  // current window.location.href.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.param.fragment( [ url ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  url - (String) A URL containing fragment (hash) params to be parsed. If\n\t  //    url is not passed, the current window.location.href is used.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (String) The parsed fragment (hash) string, with any leading \"#\" removed.\n\t\n\t  // Method: jQuery.param.fragment (build url)\n\t  //\n\t  // Merge a URL, with or without pre-existing fragment (hash) params, plus any\n\t  // object, params string or URL containing fragment (hash) params into a new\n\t  // URL.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.param.fragment( url, params [, merge_mode ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  url - (String) A valid URL for params to be merged into. This URL may\n\t  //    contain a query string and/or fragment (hash).\n\t  //  params - (String) A params string or URL containing fragment (hash) params\n\t  //    to be merged into url.\n\t  //  params - (Object) A params object to be merged into url.\n\t  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not\n\t  //    specified, and is as-follows:\n\t  //\n\t  //    * 0: params in the params argument will override any fragment (hash)\n\t  //         params in url.\n\t  //    * 1: any fragment (hash) params in url will override params in the\n\t  //         params argument.\n\t  //    * 2: params argument will completely replace any query string in url.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (String) A URL with a urlencoded fragment (hash) in the format '#a=b&c=d&e=f'.\n\t\n\t  function jq_param_sub( is_fragment, get_func, url, params, merge_mode ) {\n\t    var result,\n\t      qs,\n\t      matches,\n\t      url_params,\n\t      hash;\n\t\n\t    if ( params !== undefined ) {\n\t      // Build URL by merging params into url string.\n\t\n\t      // matches[1] = url part that precedes params, not including trailing ?/#\n\t      // matches[2] = params, not including leading ?/#\n\t      // matches[3] = if in 'querystring' mode, hash including leading #, otherwise ''\n\t      matches = url.match( is_fragment ? re_fragment : /^([^#?]*)\\??([^#]*)(#?.*)/ );\n\t\n\t      // Get the hash if in 'querystring' mode, and it exists.\n\t      hash = matches[3] || '';\n\t\n\t      if ( merge_mode === 2 && is_string( params ) ) {\n\t        // If merge_mode is 2 and params is a string, merge the fragment / query\n\t        // string into the URL wholesale, without converting it into an object.\n\t        qs = params.replace( is_fragment ? re_params_fragment : re_params_querystring, '' );\n\t\n\t      } else {\n\t        // Convert relevant params in url to object.\n\t        url_params = jq_deparam( matches[2] );\n\t\n\t        params = is_string( params )\n\t\n\t          // Convert passed params string into object.\n\t          ? jq_deparam[ is_fragment ? str_fragment : str_querystring ]( params )\n\t\n\t          // Passed params object.\n\t          : params;\n\t\n\t        qs = merge_mode === 2 ? params                              // passed params replace url params\n\t          : merge_mode === 1  ? $.extend( {}, params, url_params )  // url params override passed params\n\t          : $.extend( {}, url_params, params );                     // passed params override url params\n\t\n\t        // Convert params object into a sorted params string.\n\t        qs = jq_param_sorted( qs );\n\t\n\t        // Unescape characters specified via $.param.noEscape. Since only hash-\n\t        // history users have requested this feature, it's only enabled for\n\t        // fragment-related params strings.\n\t        if ( is_fragment ) {\n\t          qs = qs.replace( re_no_escape, decode );\n\t        }\n\t      }\n\t\n\t      // Build URL from the base url, querystring and hash. In 'querystring'\n\t      // mode, ? is only added if a query string exists. In 'fragment' mode, #\n\t      // is always added.\n\t      result = matches[1] + ( is_fragment ? fragment_prefix : qs || !matches[1] ? '?' : '' ) + qs + hash;\n\t\n\t    } else {\n\t      // If URL was passed in, parse params from URL string, otherwise parse\n\t      // params from window.location.href.\n\t      result = get_func( url !== undefined ? url : location.href );\n\t    }\n\t\n\t    return result;\n\t  };\n\t\n\t  jq_param[ str_querystring ]                  = curry( jq_param_sub, 0, get_querystring );\n\t  jq_param[ str_fragment ] = jq_param_fragment = curry( jq_param_sub, 1, get_fragment );\n\t\n\t  // Method: jQuery.param.sorted\n\t  //\n\t  // Returns a params string equivalent to that returned by the internal\n\t  // jQuery.param method, but sorted, which makes it suitable for use as a\n\t  // cache key.\n\t  //\n\t  // For example, in most browsers jQuery.param({z:1,a:2}) returns \"z=1&a=2\"\n\t  // and jQuery.param({a:2,z:1}) returns \"a=2&z=1\". Even though both the\n\t  // objects being serialized and the resulting params strings are equivalent,\n\t  // if these params strings were set into the location.hash fragment\n\t  // sequentially, the hashchange event would be triggered unnecessarily, since\n\t  // the strings are different (even though the data described by them is the\n\t  // same). By sorting the params string, unecessary hashchange event triggering\n\t  // can be avoided.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.param.sorted( obj [, traditional ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  obj - (Object) An object to be serialized.\n\t  //  traditional - (Boolean) Params deep/shallow serialization mode. See the\n\t  //    documentation at http://api.jquery.com/jQuery.param/ for more detail.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (String) A sorted params string.\n\t\n\t  jq_param.sorted = jq_param_sorted = function( a, traditional ) {\n\t    var arr = [],\n\t      obj = {};\n\t\n\t    $.each( jq_param( a, traditional ).split( '&' ), function(i,v){\n\t      var key = v.replace( /(?:%5B|=).*$/, '' ),\n\t        key_obj = obj[ key ];\n\t\n\t      if ( !key_obj ) {\n\t        key_obj = obj[ key ] = [];\n\t        arr.push( key );\n\t      }\n\t\n\t      key_obj.push( v );\n\t    });\n\t\n\t    return $.map( arr.sort(), function(v){\n\t      return obj[ v ];\n\t    }).join( '&' );\n\t  };\n\t\n\t  // Method: jQuery.param.fragment.noEscape\n\t  //\n\t  // Specify characters that will be left unescaped when fragments are created\n\t  // or merged using <jQuery.param.fragment>, or when the fragment is modified\n\t  // using <jQuery.bbq.pushState>. This option only applies to serialized data\n\t  // object fragments, and not set-as-string fragments. Does not affect the\n\t  // query string. Defaults to \",/\" (comma, forward slash).\n\t  //\n\t  // Note that this is considered a purely aesthetic option, and will help to\n\t  // create URLs that \"look pretty\" in the address bar or bookmarks, without\n\t  // affecting functionality in any way. That being said, be careful to not\n\t  // unescape characters that are used as delimiters or serve a special\n\t  // purpose, such as the \"#?&=+\" (octothorpe, question mark, ampersand,\n\t  // equals, plus) characters.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.param.fragment.noEscape( [ chars ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  chars - (String) The characters to not escape in the fragment. If\n\t  //    unspecified, defaults to empty string (escape all characters).\n\t  //\n\t  // Returns:\n\t  //\n\t  //  Nothing.\n\t\n\t  jq_param_fragment.noEscape = function( chars ) {\n\t    chars = chars || '';\n\t    var arr = $.map( chars.split(''), encodeURIComponent );\n\t    re_no_escape = new RegExp( arr.join('|'), 'g' );\n\t  };\n\t\n\t  // A sensible default. These are the characters people seem to complain about\n\t  // \"uglifying up the URL\" the most.\n\t  jq_param_fragment.noEscape( ',/' );\n\t\n\t  // Method: jQuery.param.fragment.ajaxCrawlable\n\t  //\n\t  // TODO: DESCRIBE\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.param.fragment.ajaxCrawlable( [ state ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  state - (Boolean) TODO: DESCRIBE\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (Boolean) The current ajaxCrawlable state.\n\t\n\t  jq_param_fragment.ajaxCrawlable = function( state ) {\n\t    if ( state !== undefined ) {\n\t      if ( state ) {\n\t        re_params_fragment = /^.*(?:#!|#)/;\n\t        re_fragment = /^([^#]*)(?:#!|#)?(.*)$/;\n\t        fragment_prefix = '#!';\n\t      } else {\n\t        re_params_fragment = /^.*#/;\n\t        re_fragment = /^([^#]*)#?(.*)$/;\n\t        fragment_prefix = '#';\n\t      }\n\t      ajax_crawlable = !!state;\n\t    }\n\t\n\t    return ajax_crawlable;\n\t  };\n\t\n\t  jq_param_fragment.ajaxCrawlable( 0 );\n\t\n\t  // Section: Deparam (from string)\n\t  //\n\t  // Method: jQuery.deparam\n\t  //\n\t  // Deserialize a params string into an object, optionally coercing numbers,\n\t  // booleans, null and undefined values; this method is the counterpart to the\n\t  // internal jQuery.param method.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.deparam( params [, coerce ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  params - (String) A params string to be parsed.\n\t  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and\n\t  //    undefined to their actual value. Defaults to false if omitted.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (Object) An object representing the deserialized params string.\n\t\n\t  $.deparam = jq_deparam = function( params, coerce ) {\n\t    var obj = {},\n\t      coerce_types = { 'true': !0, 'false': !1, 'null': null };\n\t\n\t    // Iterate over all name=value pairs.\n\t    $.each( params.replace( /\\+/g, ' ' ).split( '&' ), function(j,v){\n\t      var param = v.split( '=' ),\n\t        key = decode( param[0] ),\n\t        val,\n\t        cur = obj,\n\t        i = 0,\n\t\n\t        // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it\n\t        // into its component parts.\n\t        keys = key.split( '][' ),\n\t        keys_last = keys.length - 1;\n\t\n\t      // If the first keys part contains [ and the last ends with ], then []\n\t      // are correctly balanced.\n\t      if ( /\\[/.test( keys[0] ) && /\\]$/.test( keys[ keys_last ] ) ) {\n\t        // Remove the trailing ] from the last keys part.\n\t        keys[ keys_last ] = keys[ keys_last ].replace( /\\]$/, '' );\n\t\n\t        // Split first keys part into two parts on the [ and add them back onto\n\t        // the beginning of the keys array.\n\t        keys = keys.shift().split('[').concat( keys );\n\t\n\t        keys_last = keys.length - 1;\n\t      } else {\n\t        // Basic 'foo' style key.\n\t        keys_last = 0;\n\t      }\n\t\n\t      // Are we dealing with a name=value pair, or just a name?\n\t      if ( param.length === 2 ) {\n\t        val = decode( param[1] );\n\t\n\t        // Coerce values.\n\t        if ( coerce ) {\n\t          val = val && !isNaN(val)            ? +val              // number\n\t            : val === 'undefined'             ? undefined         // undefined\n\t            : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null\n\t            : val;                                                // string\n\t        }\n\t\n\t        if ( keys_last ) {\n\t          // Complex key, build deep object structure based on a few rules:\n\t          // * The 'cur' pointer starts at the object top-level.\n\t          // * [] = array push (n is set to array length), [n] = array if n is\n\t          //   numeric, otherwise object.\n\t          // * If at the last keys part, set the value.\n\t          // * For each keys part, if the current level is undefined create an\n\t          //   object or array based on the type of the next keys part.\n\t          // * Move the 'cur' pointer to the next level.\n\t          // * Rinse & repeat.\n\t          for ( ; i <= keys_last; i++ ) {\n\t            key = keys[i] === '' ? cur.length : keys[i];\n\t            cur = cur[key] = i < keys_last\n\t              ? cur[key] || ( keys[i+1] && isNaN( keys[i+1] ) ? {} : [] )\n\t              : val;\n\t          }\n\t\n\t        } else {\n\t          // Simple key, even simpler rules, since only scalars and shallow\n\t          // arrays are allowed.\n\t\n\t          if ( $.isArray( obj[key] ) ) {\n\t            // val is already an array, so push on the next value.\n\t            obj[key].push( val );\n\t\n\t          } else if ( obj[key] !== undefined ) {\n\t            // val isn't an array, but since a second value has been specified,\n\t            // convert val into an array.\n\t            obj[key] = [ obj[key], val ];\n\t\n\t          } else {\n\t            // val is a scalar.\n\t            obj[key] = val;\n\t          }\n\t        }\n\t\n\t      } else if ( key ) {\n\t        // No value was defined, so set something meaningful.\n\t        obj[key] = coerce\n\t          ? undefined\n\t          : '';\n\t      }\n\t    });\n\t\n\t    return obj;\n\t  };\n\t\n\t  // Method: jQuery.deparam.querystring\n\t  //\n\t  // Parse the query string from a URL or the current window.location.href,\n\t  // deserializing it into an object, optionally coercing numbers, booleans,\n\t  // null and undefined values.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.deparam.querystring( [ url ] [, coerce ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  url - (String) An optional params string or URL containing query string\n\t  //    params to be parsed. If url is omitted, the current\n\t  //    window.location.href is used.\n\t  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and\n\t  //    undefined to their actual value. Defaults to false if omitted.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (Object) An object representing the deserialized params string.\n\t\n\t  // Method: jQuery.deparam.fragment\n\t  //\n\t  // Parse the fragment (hash) from a URL or the current window.location.href,\n\t  // deserializing it into an object, optionally coercing numbers, booleans,\n\t  // null and undefined values.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.deparam.fragment( [ url ] [, coerce ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  url - (String) An optional params string or URL containing fragment (hash)\n\t  //    params to be parsed. If url is omitted, the current window.location.href\n\t  //    is used.\n\t  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and\n\t  //    undefined to their actual value. Defaults to false if omitted.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (Object) An object representing the deserialized params string.\n\t\n\t  function jq_deparam_sub( is_fragment, url_or_params, coerce ) {\n\t    if ( url_or_params === undefined || typeof url_or_params === 'boolean' ) {\n\t      // url_or_params not specified.\n\t      coerce = url_or_params;\n\t      url_or_params = jq_param[ is_fragment ? str_fragment : str_querystring ]();\n\t    } else {\n\t      url_or_params = is_string( url_or_params )\n\t        ? url_or_params.replace( is_fragment ? re_params_fragment : re_params_querystring, '' )\n\t        : url_or_params;\n\t    }\n\t\n\t    return jq_deparam( url_or_params, coerce );\n\t  };\n\t\n\t  jq_deparam[ str_querystring ]                    = curry( jq_deparam_sub, 0 );\n\t  jq_deparam[ str_fragment ] = jq_deparam_fragment = curry( jq_deparam_sub, 1 );\n\t\n\t  // Section: Element manipulation\n\t  //\n\t  // Method: jQuery.elemUrlAttr\n\t  //\n\t  // Get the internal \"Default URL attribute per tag\" list, or augment the list\n\t  // with additional tag-attribute pairs, in case the defaults are insufficient.\n\t  //\n\t  // In the <jQuery.fn.querystring> and <jQuery.fn.fragment> methods, this list\n\t  // is used to determine which attribute contains the URL to be modified, if\n\t  // an \"attr\" param is not specified.\n\t  //\n\t  // Default Tag-Attribute List:\n\t  //\n\t  //  a      - href\n\t  //  base   - href\n\t  //  iframe - src\n\t  //  img    - src\n\t  //  input  - src\n\t  //  form   - action\n\t  //  link   - href\n\t  //  script - src\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.elemUrlAttr( [ tag_attr ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  tag_attr - (Object) An object containing a list of tag names and their\n\t  //    associated default attribute names in the format { tag: 'attr', ... } to\n\t  //    be merged into the internal tag-attribute list.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (Object) An object containing all stored tag-attribute values.\n\t\n\t  // Only define function and set defaults if function doesn't already exist, as\n\t  // the urlInternal plugin will provide this method as well.\n\t  $[ str_elemUrlAttr ] || ($[ str_elemUrlAttr ] = function( obj ) {\n\t    return $.extend( elemUrlAttr_cache, obj );\n\t  })({\n\t    a: str_href,\n\t    base: str_href,\n\t    iframe: str_src,\n\t    img: str_src,\n\t    input: str_src,\n\t    form: 'action',\n\t    link: str_href,\n\t    script: str_src\n\t  });\n\t\n\t  jq_elemUrlAttr = $[ str_elemUrlAttr ];\n\t\n\t  // Method: jQuery.fn.querystring\n\t  //\n\t  // Update URL attribute in one or more elements, merging the current URL (with\n\t  // or without pre-existing query string params) plus any params object or\n\t  // string into a new URL, which is then set into that attribute. Like\n\t  // <jQuery.param.querystring (build url)>, but for all elements in a jQuery\n\t  // collection.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery('selector').querystring( [ attr, ] params [, merge_mode ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  attr - (String) Optional name of an attribute that will contain a URL to\n\t  //    merge params or url into. See <jQuery.elemUrlAttr> for a list of default\n\t  //    attributes.\n\t  //  params - (Object) A params object to be merged into the URL attribute.\n\t  //  params - (String) A URL containing query string params, or params string\n\t  //    to be merged into the URL attribute.\n\t  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not\n\t  //    specified, and is as-follows:\n\t  //\n\t  //    * 0: params in the params argument will override any params in attr URL.\n\t  //    * 1: any params in attr URL will override params in the params argument.\n\t  //    * 2: params argument will completely replace any query string in attr\n\t  //         URL.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (jQuery) The initial jQuery collection of elements, but with modified URL\n\t  //  attribute values.\n\t\n\t  // Method: jQuery.fn.fragment\n\t  //\n\t  // Update URL attribute in one or more elements, merging the current URL (with\n\t  // or without pre-existing fragment/hash params) plus any params object or\n\t  // string into a new URL, which is then set into that attribute. Like\n\t  // <jQuery.param.fragment (build url)>, but for all elements in a jQuery\n\t  // collection.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery('selector').fragment( [ attr, ] params [, merge_mode ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  attr - (String) Optional name of an attribute that will contain a URL to\n\t  //    merge params into. See <jQuery.elemUrlAttr> for a list of default\n\t  //    attributes.\n\t  //  params - (Object) A params object to be merged into the URL attribute.\n\t  //  params - (String) A URL containing fragment (hash) params, or params\n\t  //    string to be merged into the URL attribute.\n\t  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not\n\t  //    specified, and is as-follows:\n\t  //\n\t  //    * 0: params in the params argument will override any params in attr URL.\n\t  //    * 1: any params in attr URL will override params in the params argument.\n\t  //    * 2: params argument will completely replace any fragment (hash) in attr\n\t  //         URL.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (jQuery) The initial jQuery collection of elements, but with modified URL\n\t  //  attribute values.\n\t\n\t  function jq_fn_sub( mode, force_attr, params, merge_mode ) {\n\t    if ( !is_string( params ) && typeof params !== 'object' ) {\n\t      // force_attr not specified.\n\t      merge_mode = params;\n\t      params = force_attr;\n\t      force_attr = undefined;\n\t    }\n\t\n\t    return this.each(function(){\n\t      var that = $(this),\n\t\n\t        // Get attribute specified, or default specified via $.elemUrlAttr.\n\t        attr = force_attr || jq_elemUrlAttr()[ ( this.nodeName || '' ).toLowerCase() ] || '',\n\t\n\t        // Get URL value.\n\t        url = attr && that.attr( attr ) || '';\n\t\n\t      // Update attribute with new URL.\n\t      that.attr( attr, jq_param[ mode ]( url, params, merge_mode ) );\n\t    });\n\t\n\t  };\n\t\n\t  $.fn[ str_querystring ] = curry( jq_fn_sub, str_querystring );\n\t  $.fn[ str_fragment ]    = curry( jq_fn_sub, str_fragment );\n\t\n\t  // Section: History, hashchange event\n\t  //\n\t  // Method: jQuery.bbq.pushState\n\t  //\n\t  // Adds a 'state' into the browser history at the current position, setting\n\t  // location.hash and triggering any bound <hashchange event> callbacks\n\t  // (provided the new state is different than the previous state).\n\t  //\n\t  // If no arguments are passed, an empty state is created, which is just a\n\t  // shortcut for jQuery.bbq.pushState( {}, 2 ).\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.bbq.pushState( [ params [, merge_mode ] ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  params - (String) A serialized params string or a hash string beginning\n\t  //    with # to merge into location.hash.\n\t  //  params - (Object) A params object to merge into location.hash.\n\t  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not\n\t  //    specified (unless a hash string beginning with # is specified, in which\n\t  //    case merge behavior defaults to 2), and is as-follows:\n\t  //\n\t  //    * 0: params in the params argument will override any params in the\n\t  //         current state.\n\t  //    * 1: any params in the current state will override params in the params\n\t  //         argument.\n\t  //    * 2: params argument will completely replace current state.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  Nothing.\n\t  //\n\t  // Additional Notes:\n\t  //\n\t  //  * Setting an empty state may cause the browser to scroll.\n\t  //  * Unlike the fragment and querystring methods, if a hash string beginning\n\t  //    with # is specified as the params agrument, merge_mode defaults to 2.\n\t\n\t  jq_bbq.pushState = jq_bbq_pushState = function( params, merge_mode ) {\n\t    if ( is_string( params ) && /^#/.test( params ) && merge_mode === undefined ) {\n\t      // Params string begins with # and merge_mode not specified, so completely\n\t      // overwrite window.location.hash.\n\t      merge_mode = 2;\n\t    }\n\t\n\t    var has_args = params !== undefined,\n\t      // Merge params into window.location using $.param.fragment.\n\t      url = jq_param_fragment( location.href,\n\t        has_args ? params : {}, has_args ? merge_mode : 2 );\n\t\n\t    // Set new window.location.href. Note that Safari 3 & Chrome barf on\n\t    // location.hash = '#' so the entire URL is set.\n\t    location.href = url;\n\t  };\n\t\n\t  // Method: jQuery.bbq.getState\n\t  //\n\t  // Retrieves the current 'state' from the browser history, parsing\n\t  // location.hash for a specific key or returning an object containing the\n\t  // entire state, optionally coercing numbers, booleans, null and undefined\n\t  // values.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.bbq.getState( [ key ] [, coerce ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  key - (String) An optional state key for which to return a value.\n\t  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and\n\t  //    undefined to their actual value. Defaults to false.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (Anything) If key is passed, returns the value corresponding with that key\n\t  //    in the location.hash 'state', or undefined. If not, an object\n\t  //    representing the entire 'state' is returned.\n\t\n\t  jq_bbq.getState = jq_bbq_getState = function( key, coerce ) {\n\t    return key === undefined || typeof key === 'boolean'\n\t      ? jq_deparam_fragment( key ) // 'key' really means 'coerce' here\n\t      : jq_deparam_fragment( coerce )[ key ];\n\t  };\n\t\n\t  // Method: jQuery.bbq.removeState\n\t  //\n\t  // Remove one or more keys from the current browser history 'state', creating\n\t  // a new state, setting location.hash and triggering any bound\n\t  // <hashchange event> callbacks (provided the new state is different than\n\t  // the previous state).\n\t  //\n\t  // If no arguments are passed, an empty state is created, which is just a\n\t  // shortcut for jQuery.bbq.pushState( {}, 2 ).\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery.bbq.removeState( [ key [, key ... ] ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  key - (String) One or more key values to remove from the current state,\n\t  //    passed as individual arguments.\n\t  //  key - (Array) A single array argument that contains a list of key values\n\t  //    to remove from the current state.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  Nothing.\n\t  //\n\t  // Additional Notes:\n\t  //\n\t  //  * Setting an empty state may cause the browser to scroll.\n\t\n\t  jq_bbq.removeState = function( arr ) {\n\t    var state = {};\n\t\n\t    // If one or more arguments is passed..\n\t    if ( arr !== undefined ) {\n\t\n\t      // Get the current state.\n\t      state = jq_bbq_getState();\n\t\n\t      // For each passed key, delete the corresponding property from the current\n\t      // state.\n\t      $.each( $.isArray( arr ) ? arr : arguments, function(i,v){\n\t        delete state[ v ];\n\t      });\n\t    }\n\t\n\t    // Set the state, completely overriding any existing state.\n\t    jq_bbq_pushState( state, 2 );\n\t  };\n\t\n\t  // Event: hashchange event (BBQ)\n\t  //\n\t  // Usage in jQuery 1.4 and newer:\n\t  //\n\t  // In jQuery 1.4 and newer, the event object passed into any hashchange event\n\t  // callback is augmented with a copy of the location.hash fragment at the time\n\t  // the event was triggered as its event.fragment property. In addition, the\n\t  // event.getState method operates on this property (instead of location.hash)\n\t  // which allows this fragment-as-a-state to be referenced later, even after\n\t  // window.location may have changed.\n\t  //\n\t  // Note that event.fragment and event.getState are not defined according to\n\t  // W3C (or any other) specification, but will still be available whether or\n\t  // not the hashchange event exists natively in the browser, because of the\n\t  // utility they provide.\n\t  //\n\t  // The event.fragment property contains the output of <jQuery.param.fragment>\n\t  // and the event.getState method is equivalent to the <jQuery.bbq.getState>\n\t  // method.\n\t  //\n\t  // > $(window).bind( 'hashchange', function( event ) {\n\t  // >   var hash_str = event.fragment,\n\t  // >     param_obj = event.getState(),\n\t  // >     param_val = event.getState( 'param_name' ),\n\t  // >     param_val_coerced = event.getState( 'param_name', true );\n\t  // >   ...\n\t  // > });\n\t  //\n\t  // Usage in jQuery 1.3.2:\n\t  //\n\t  // In jQuery 1.3.2, the event object cannot to be augmented as in jQuery 1.4+,\n\t  // so the fragment state isn't bound to the event object and must instead be\n\t  // parsed using the <jQuery.param.fragment> and <jQuery.bbq.getState> methods.\n\t  //\n\t  // > $(window).bind( 'hashchange', function( event ) {\n\t  // >   var hash_str = $.param.fragment(),\n\t  // >     param_obj = $.bbq.getState(),\n\t  // >     param_val = $.bbq.getState( 'param_name' ),\n\t  // >     param_val_coerced = $.bbq.getState( 'param_name', true );\n\t  // >   ...\n\t  // > });\n\t  //\n\t  // Additional Notes:\n\t  //\n\t  // * Due to changes in the special events API, jQuery BBQ v1.2 or newer is\n\t  //   required to enable the augmented event object in jQuery 1.4.2 and newer.\n\t  // * See <jQuery hashchange event> for more detailed information.\n\t\n\t  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {\n\t\n\t    // Augmenting the event object with the .fragment property and .getState\n\t    // method requires jQuery 1.4 or newer. Note: with 1.3.2, everything will\n\t    // work, but the event won't be augmented)\n\t    add: function( handleObj ) {\n\t      var old_handler;\n\t\n\t      function new_handler(e) {\n\t        // e.fragment is set to the value of location.hash (with any leading #\n\t        // removed) at the time the event is triggered.\n\t        var hash = e[ str_fragment ] = jq_param_fragment();\n\t\n\t        // e.getState() works just like $.bbq.getState(), but uses the\n\t        // e.fragment property stored on the event object.\n\t        e.getState = function( key, coerce ) {\n\t          return key === undefined || typeof key === 'boolean'\n\t            ? jq_deparam( hash, key ) // 'key' really means 'coerce' here\n\t            : jq_deparam( hash, coerce )[ key ];\n\t        };\n\t\n\t        old_handler.apply( this, arguments );\n\t      };\n\t\n\t      // This may seem a little complicated, but it normalizes the special event\n\t      // .add method between jQuery 1.4/1.4.1 and 1.4.2+\n\t      if ( $.isFunction( handleObj ) ) {\n\t        // 1.4, 1.4.1\n\t        old_handler = handleObj;\n\t        return new_handler;\n\t      } else {\n\t        // 1.4.2+\n\t        old_handler = handleObj.handler;\n\t        handleObj.handler = new_handler;\n\t      }\n\t    }\n\t\n\t  });\n\t\n\t})(jQuery,this);\n\t\n\t/*!\n\t * jQuery hashchange event - v1.3 - 7/21/2010\n\t * http://benalman.com/projects/jquery-hashchange-plugin/\n\t *\n\t * Copyright (c) 2010 \"Cowboy\" Ben Alman\n\t * Dual licensed under the MIT and GPL licenses.\n\t * http://benalman.com/about/license/\n\t */\n\t\n\t// Script: jQuery hashchange event\n\t//\n\t// *Version: 1.3, Last updated: 7/21/2010*\n\t//\n\t// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/\n\t// GitHub       - http://github.com/cowboy/jquery-hashchange/\n\t// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js\n\t// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (0.8kb gzipped)\n\t//\n\t// About: License\n\t//\n\t// Copyright (c) 2010 \"Cowboy\" Ben Alman,\n\t// Dual licensed under the MIT and GPL licenses.\n\t// http://benalman.com/about/license/\n\t//\n\t// About: Examples\n\t//\n\t// These working examples, complete with fully commented code, illustrate a few\n\t// ways in which this plugin can be used.\n\t//\n\t// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/\n\t// document.domain - http://benalman.com/code/projects/jquery-hashchange/examples/document_domain/\n\t//\n\t// About: Support and Testing\n\t//\n\t// Information about what version or versions of jQuery this plugin has been\n\t// tested with, what browsers it has been tested in, and where the unit tests\n\t// reside (so you can test it yourself).\n\t//\n\t// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2\n\t// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,\n\t//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.\n\t// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/\n\t//\n\t// About: Known issues\n\t//\n\t// While this jQuery hashchange event implementation is quite stable and\n\t// robust, there are a few unfortunate browser bugs surrounding expected\n\t// hashchange event-based behaviors, independent of any JavaScript\n\t// window.onhashchange abstraction. See the following examples for more\n\t// information:\n\t//\n\t// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/\n\t// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/\n\t// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/\n\t// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/\n\t//\n\t// Also note that should a browser natively support the window.onhashchange\n\t// event, but not report that it does, the fallback polling loop will be used.\n\t//\n\t// About: Release History\n\t//\n\t// 1.3   - (7/21/2010) Reorganized IE6/7 Iframe code to make it more\n\t//         \"removable\" for mobile-only development. Added IE6/7 document.title\n\t//         support. Attempted to make Iframe as hidden as possible by using\n\t//         techniques from http://www.paciellogroup.com/blog/?p=604. Added\n\t//         support for the \"shortcut\" format $(window).hashchange( fn ) and\n\t//         $(window).hashchange() like jQuery provides for built-in events.\n\t//         Renamed jQuery.hashchangeDelay to <jQuery.fn.hashchange.delay> and\n\t//         lowered its default value to 50. Added <jQuery.fn.hashchange.domain>\n\t//         and <jQuery.fn.hashchange.src> properties plus document-domain.html\n\t//         file to address access denied issues when setting document.domain in\n\t//         IE6/7.\n\t// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin\n\t//         from a page on another domain would cause an error in Safari 4. Also,\n\t//         IE6/7 Iframe is now inserted after the body (this actually works),\n\t//         which prevents the page from scrolling when the event is first bound.\n\t//         Event can also now be bound before DOM ready, but it won't be usable\n\t//         before then in IE6/7.\n\t// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug\n\t//         where browser version is incorrectly reported as 8.0, despite\n\t//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.\n\t// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special\n\t//         window.onhashchange functionality into a separate plugin for users\n\t//         who want just the basic event & back button support, without all the\n\t//         extra awesomeness that BBQ provides. This plugin will be included as\n\t//         part of jQuery BBQ, but also be available separately.\n\t\n\t(function($,window,undefined){\n\t  '$:nomunge'; // Used by YUI compressor.\n\t\n\t  // Reused string.\n\t  var str_hashchange = 'hashchange',\n\t\n\t    // Method / object references.\n\t    doc = document,\n\t    fake_onhashchange,\n\t    special = $.event.special,\n\t\n\t    // Does the browser support window.onhashchange? Note that IE8 running in\n\t    // IE7 compatibility mode reports true for 'onhashchange' in window, even\n\t    // though the event isn't supported, so also test document.documentMode.\n\t    doc_mode = doc.documentMode,\n\t    supports_onhashchange = 'on' + str_hashchange in window && ( doc_mode === undefined || doc_mode > 7 );\n\t\n\t  // Get location.hash (or what you'd expect location.hash to be) sans any\n\t  // leading #. Thanks for making this necessary, Firefox!\n\t  function get_fragment( url ) {\n\t    url = url || location.href;\n\t    return '#' + url.replace( /^[^#]*#?(.*)$/, '$1' );\n\t  };\n\t\n\t  // Method: jQuery.fn.hashchange\n\t  //\n\t  // Bind a handler to the window.onhashchange event or trigger all bound\n\t  // window.onhashchange event handlers. This behavior is consistent with\n\t  // jQuery's built-in event handlers.\n\t  //\n\t  // Usage:\n\t  //\n\t  // > jQuery(window).hashchange( [ handler ] );\n\t  //\n\t  // Arguments:\n\t  //\n\t  //  handler - (Function) Optional handler to be bound to the hashchange\n\t  //    event. This is a \"shortcut\" for the more verbose form:\n\t  //    jQuery(window).bind( 'hashchange', handler ). If handler is omitted,\n\t  //    all bound window.onhashchange event handlers will be triggered. This\n\t  //    is a shortcut for the more verbose\n\t  //    jQuery(window).trigger( 'hashchange' ). These forms are described in\n\t  //    the <hashchange event> section.\n\t  //\n\t  // Returns:\n\t  //\n\t  //  (jQuery) The initial jQuery collection of elements.\n\t\n\t  // Allow the \"shortcut\" format $(elem).hashchange( fn ) for binding and\n\t  // $(elem).hashchange() for triggering, like jQuery does for built-in events.\n\t  $.fn[ str_hashchange ] = function( fn ) {\n\t    return fn ? this.bind( str_hashchange, fn ) : this.trigger( str_hashchange );\n\t  };\n\t\n\t  // Property: jQuery.fn.hashchange.delay\n\t  //\n\t  // The numeric interval (in milliseconds) at which the <hashchange event>\n\t  // polling loop executes. Defaults to 50.\n\t\n\t  // Property: jQuery.fn.hashchange.domain\n\t  //\n\t  // If you're setting document.domain in your JavaScript, and you want hash\n\t  // history to work in IE6/7, not only must this property be set, but you must\n\t  // also set document.domain BEFORE jQuery is loaded into the page. This\n\t  // property is only applicable if you are supporting IE6/7 (or IE8 operating\n\t  // in \"IE7 compatibility\" mode).\n\t  //\n\t  // In addition, the <jQuery.fn.hashchange.src> property must be set to the\n\t  // path of the included \"document-domain.html\" file, which can be renamed or\n\t  // modified if necessary (note that the document.domain specified must be the\n\t  // same in both your main JavaScript as well as in this file).\n\t  //\n\t  // Usage:\n\t  //\n\t  // jQuery.fn.hashchange.domain = document.domain;\n\t\n\t  // Property: jQuery.fn.hashchange.src\n\t  //\n\t  // If, for some reason, you need to specify an Iframe src file (for example,\n\t  // when setting document.domain as in <jQuery.fn.hashchange.domain>), you can\n\t  // do so using this property. Note that when using this property, history\n\t  // won't be recorded in IE6/7 until the Iframe src file loads. This property\n\t  // is only applicable if you are supporting IE6/7 (or IE8 operating in \"IE7\n\t  // compatibility\" mode).\n\t  //\n\t  // Usage:\n\t  //\n\t  // jQuery.fn.hashchange.src = 'path/to/file.html';\n\t\n\t  $.fn[ str_hashchange ].delay = 50;\n\t  /*\n\t  $.fn[ str_hashchange ].domain = null;\n\t  $.fn[ str_hashchange ].src = null;\n\t  */\n\t\n\t  // Event: hashchange event\n\t  //\n\t  // Fired when location.hash changes. In browsers that support it, the native\n\t  // HTML5 window.onhashchange event is used, otherwise a polling loop is\n\t  // initialized, running every <jQuery.fn.hashchange.delay> milliseconds to\n\t  // see if the hash has changed. In IE6/7 (and IE8 operating in \"IE7\n\t  // compatibility\" mode), a hidden Iframe is created to allow the back button\n\t  // and hash-based history to work.\n\t  //\n\t  // Usage as described in <jQuery.fn.hashchange>:\n\t  //\n\t  // > // Bind an event handler.\n\t  // > jQuery(window).hashchange( function(e) {\n\t  // >   var hash = location.hash;\n\t  // >   ...\n\t  // > });\n\t  // >\n\t  // > // Manually trigger the event handler.\n\t  // > jQuery(window).hashchange();\n\t  //\n\t  // A more verbose usage that allows for event namespacing:\n\t  //\n\t  // > // Bind an event handler.\n\t  // > jQuery(window).bind( 'hashchange', function(e) {\n\t  // >   var hash = location.hash;\n\t  // >   ...\n\t  // > });\n\t  // >\n\t  // > // Manually trigger the event handler.\n\t  // > jQuery(window).trigger( 'hashchange' );\n\t  //\n\t  // Additional Notes:\n\t  //\n\t  // * The polling loop and Iframe are not created until at least one handler\n\t  //   is actually bound to the 'hashchange' event.\n\t  // * If you need the bound handler(s) to execute immediately, in cases where\n\t  //   a location.hash exists on page load, via bookmark or page refresh for\n\t  //   example, use jQuery(window).hashchange() or the more verbose\n\t  //   jQuery(window).trigger( 'hashchange' ).\n\t  // * The event can be bound before DOM ready, but since it won't be usable\n\t  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is\n\t  //   to bind it inside a DOM ready handler.\n\t\n\t  // Override existing $.event.special.hashchange methods (allowing this plugin\n\t  // to be defined after jQuery BBQ in BBQ's source code).\n\t  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {\n\t\n\t    // Called only when the first 'hashchange' event is bound to window.\n\t    setup: function() {\n\t      // If window.onhashchange is supported natively, there's nothing to do..\n\t      if ( supports_onhashchange ) { return false; }\n\t\n\t      // Otherwise, we need to create our own. And we don't want to call this\n\t      // until the user binds to the event, just in case they never do, since it\n\t      // will create a polling loop and possibly even a hidden Iframe.\n\t      $( fake_onhashchange.start );\n\t    },\n\t\n\t    // Called only when the last 'hashchange' event is unbound from window.\n\t    teardown: function() {\n\t      // If window.onhashchange is supported natively, there's nothing to do..\n\t      if ( supports_onhashchange ) { return false; }\n\t\n\t      // Otherwise, we need to stop ours (if possible).\n\t      $( fake_onhashchange.stop );\n\t    }\n\t\n\t  });\n\t\n\t  // fake_onhashchange does all the work of triggering the window.onhashchange\n\t  // event for browsers that don't natively support it, including creating a\n\t  // polling loop to watch for hash changes and in IE 6/7 creating a hidden\n\t  // Iframe to enable back and forward.\n\t  fake_onhashchange = (function(){\n\t    var self = {},\n\t      timeout_id,\n\t\n\t      // Remember the initial hash so it doesn't get triggered immediately.\n\t      last_hash = get_fragment(),\n\t\n\t      fn_retval = function(val){ return val; },\n\t      history_set = fn_retval,\n\t      history_get = fn_retval;\n\t\n\t    // Start the polling loop.\n\t    self.start = function() {\n\t      timeout_id || poll();\n\t    };\n\t\n\t    // Stop the polling loop.\n\t    self.stop = function() {\n\t      timeout_id && clearTimeout( timeout_id );\n\t      timeout_id = undefined;\n\t    };\n\t\n\t    // This polling loop checks every $.fn.hashchange.delay milliseconds to see\n\t    // if location.hash has changed, and triggers the 'hashchange' event on\n\t    // window when necessary.\n\t    function poll() {\n\t      var hash = get_fragment(),\n\t        history_hash = history_get( last_hash );\n\t\n\t      if ( hash !== last_hash ) {\n\t        history_set( last_hash = hash, history_hash );\n\t\n\t        $(window).trigger( str_hashchange );\n\t\n\t      } else if ( history_hash !== last_hash ) {\n\t        location.href = location.href.replace( /#.*/, '' ) + history_hash;\n\t      }\n\t\n\t      timeout_id = setTimeout( poll, $.fn[ str_hashchange ].delay );\n\t    };\n\t\n\t    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\t    // vvvvvvvvvvvvvvvvvvv REMOVE IF NOT SUPPORTING IE6/7/8 vvvvvvvvvvvvvvvvvvv\n\t    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\t    var ua = navigator.userAgent.toLowerCase();\n\t    var browser = {\n\t       msie: /msie/.test(ua) && !/opera/.test(ua)\n\t    };\n\t    browser.msie && !supports_onhashchange && (function(){\n\t      // Not only do IE6/7 need the \"magical\" Iframe treatment, but so does IE8\n\t      // when running in \"IE7 compatibility\" mode.\n\t\n\t      var iframe,\n\t        iframe_src;\n\t\n\t      // When the event is bound and polling starts in IE 6/7, create a hidden\n\t      // Iframe for history handling.\n\t      self.start = function(){\n\t        if ( !iframe ) {\n\t          iframe_src = $.fn[ str_hashchange ].src;\n\t          iframe_src = iframe_src && iframe_src + get_fragment();\n\t\n\t          // Create hidden Iframe. Attempt to make Iframe as hidden as possible\n\t          // by using techniques from http://www.paciellogroup.com/blog/?p=604.\n\t          iframe = $('<iframe tabindex=\"-1\" title=\"empty\"/>').hide()\n\t\n\t            // When Iframe has completely loaded, initialize the history and\n\t            // start polling.\n\t            .one( 'load', function(){\n\t              iframe_src || history_set( get_fragment() );\n\t              poll();\n\t            })\n\t\n\t            // Load Iframe src if specified, otherwise nothing.\n\t            .attr( 'src', iframe_src || 'javascript:0' )\n\t\n\t            // Append Iframe after the end of the body to prevent unnecessary\n\t            // initial page scrolling (yes, this works).\n\t            .insertAfter( 'body' )[0].contentWindow;\n\t\n\t          // Whenever `document.title` changes, update the Iframe's title to\n\t          // prettify the back/next history menu entries. Since IE sometimes\n\t          // errors with \"Unspecified error\" the very first time this is set\n\t          // (yes, very useful) wrap this with a try/catch block.\n\t          doc.onpropertychange = function(){\n\t            try {\n\t              if ( event.propertyName === 'title' ) {\n\t                iframe.document.title = doc.title;\n\t              }\n\t            } catch(e) {}\n\t          };\n\t\n\t        }\n\t      };\n\t\n\t      // Override the \"stop\" method since an IE6/7 Iframe was created. Even\n\t      // if there are no longer any bound event handlers, the polling loop\n\t      // is still necessary for back/next to work at all!\n\t      self.stop = fn_retval;\n\t\n\t      // Get history by looking at the hidden Iframe's location.hash.\n\t      history_get = function() {\n\t        return get_fragment( iframe.location.href );\n\t      };\n\t\n\t      // Set a new history item by opening and then closing the Iframe\n\t      // document, *then* setting its location.hash. If document.domain has\n\t      // been set, update that as well.\n\t      history_set = function( hash, history_hash ) {\n\t        var iframe_doc = iframe.document,\n\t          domain = $.fn[ str_hashchange ].domain;\n\t\n\t        if ( hash !== history_hash ) {\n\t          // Update Iframe with any initial `document.title` that might be set.\n\t          iframe_doc.title = doc.title;\n\t\n\t          // Opening the Iframe's document after it has been closed is what\n\t          // actually adds a history entry.\n\t          iframe_doc.open();\n\t\n\t          // Set document.domain for the Iframe document as well, if necessary.\n\t          domain && iframe_doc.write( '<script>document.domain=\"' + domain + '\"</script>' );\n\t\n\t          iframe_doc.close();\n\t\n\t          // Update the Iframe's hash, for great justice.\n\t          iframe.location.hash = hash;\n\t        }\n\t      };\n\t\n\t    })();\n\t    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\t    // ^^^^^^^^^^^^^^^^^^^ REMOVE IF NOT SUPPORTING IE6/7/8 ^^^^^^^^^^^^^^^^^^^\n\t    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\t\n\t    return self;\n\t  })();\n\t\n\t})(jQuery,this);\n\n\n/***/ }\n/******/ ])\n\n\n/** WEBPACK FOOTER **\n ** bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 70fb36f0fcc818f75eea\n **/","'use strict';\nrequire(\"angular-ui-router\");\nrequire(\"angular-bootstrap/ui-bootstrap.js\");\nrequire(\"angular-bootstrap/ui-bootstrap-tpls.js\");\n// require(\"siren.coffee\");\nrequire(\"./modules/siren-browser/siren-browser.coffee\");\n\nvar body = require(\"./body.jade\");\n$(\"body\").html(body);\n\nangular.module('MyApp', ['ui.bootstrap','SirenBrowser'])\n  .filter('encodeURIComponent', function() {\n    return window.encodeURIComponent;\n  })\n  .filter('prettify', function() {\n    return function(obj) {\n      return JSON.stringify(obj, function(key, val) {\n        return (key === '$$hashKey') ? undefined : val;\n      }, 2);\n    };\n  });\n\n$(function() {\n  angular.bootstrap(document, ['MyApp']);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 0.11.2 - 2014-09-26\n * License: MIT\n */\nangular.module(\"ui.bootstrap\", [\"ui.bootstrap.transition\",\"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.bindHtml\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.modal\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\nangular.module('ui.bootstrap.transition', [])\n\n/**\n * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.\n * @param  {DOMElement} element  The DOMElement that will be animated.\n * @param  {string|object|function} trigger  The thing that will cause the transition to start:\n *   - As a string, it represents the css class to be added to the element.\n *   - As an object, it represents a hash of style attributes to be applied to the element.\n *   - As a function, it represents a function to be called that will cause the transition to occur.\n * @return {Promise}  A promise that is resolved when the transition finishes.\n */\n.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {\n\n  var $transition = function(element, trigger, options) {\n    options = options || {};\n    var deferred = $q.defer();\n    var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];\n\n    var transitionEndHandler = function(event) {\n      $rootScope.$apply(function() {\n        element.unbind(endEventName, transitionEndHandler);\n        deferred.resolve(element);\n      });\n    };\n\n    if (endEventName) {\n      element.bind(endEventName, transitionEndHandler);\n    }\n\n    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur\n    $timeout(function() {\n      if ( angular.isString(trigger) ) {\n        element.addClass(trigger);\n      } else if ( angular.isFunction(trigger) ) {\n        trigger(element);\n      } else if ( angular.isObject(trigger) ) {\n        element.css(trigger);\n      }\n      //If browser does not support transitions, instantly resolve\n      if ( !endEventName ) {\n        deferred.resolve(element);\n      }\n    });\n\n    // Add our custom cancel function to the promise that is returned\n    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,\n    // i.e. it will therefore never raise a transitionEnd event for that transition\n    deferred.promise.cancel = function() {\n      if ( endEventName ) {\n        element.unbind(endEventName, transitionEndHandler);\n      }\n      deferred.reject('Transition cancelled');\n    };\n\n    return deferred.promise;\n  };\n\n  // Work out the name of the transitionEnd event\n  var transElement = document.createElement('trans');\n  var transitionEndEventNames = {\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'transitionend',\n    'OTransition': 'oTransitionEnd',\n    'transition': 'transitionend'\n  };\n  var animationEndEventNames = {\n    'WebkitTransition': 'webkitAnimationEnd',\n    'MozTransition': 'animationend',\n    'OTransition': 'oAnimationEnd',\n    'transition': 'animationend'\n  };\n  function findEndEventName(endEventNames) {\n    for (var name in endEventNames){\n      if (transElement.style[name] !== undefined) {\n        return endEventNames[name];\n      }\n    }\n  }\n  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);\n  $transition.animationEndEventName = findEndEventName(animationEndEventNames);\n  return $transition;\n}]);\n\nangular.module('ui.bootstrap.collapse', ['ui.bootstrap.transition'])\n\n  .directive('collapse', ['$transition', function ($transition) {\n\n    return {\n      link: function (scope, element, attrs) {\n\n        var initialAnimSkip = true;\n        var currentTransition;\n\n        function doTransition(change) {\n          var newTransition = $transition(element, change);\n          if (currentTransition) {\n            currentTransition.cancel();\n          }\n          currentTransition = newTransition;\n          newTransition.then(newTransitionDone, newTransitionDone);\n          return newTransition;\n\n          function newTransitionDone() {\n            // Make sure it's this transition, otherwise, leave it alone.\n            if (currentTransition === newTransition) {\n              currentTransition = undefined;\n            }\n          }\n        }\n\n        function expand() {\n          if (initialAnimSkip) {\n            initialAnimSkip = false;\n            expandDone();\n          } else {\n            element.removeClass('collapse').addClass('collapsing');\n            doTransition({ height: element[0].scrollHeight + 'px' }).then(expandDone);\n          }\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing');\n          element.addClass('collapse in');\n          element.css({height: 'auto'});\n        }\n\n        function collapse() {\n          if (initialAnimSkip) {\n            initialAnimSkip = false;\n            collapseDone();\n            element.css({height: 0});\n          } else {\n            // CSS transitions don't work with height: auto, so we have to manually change the height to a specific value\n            element.css({ height: element[0].scrollHeight + 'px' });\n            //trigger reflow so a browser realizes that height was updated from auto to a specific value\n            var x = element[0].offsetWidth;\n\n            element.removeClass('collapse in').addClass('collapsing');\n\n            doTransition({ height: 0 }).then(collapseDone);\n          }\n        }\n\n        function collapseDone() {\n          element.removeClass('collapsing');\n          element.addClass('collapse');\n        }\n\n        scope.$watch(attrs.collapse, function (shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\n.constant('accordionConfig', {\n  closeOthers: true\n})\n\n.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {\n\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if ( closeOthers ) {\n      angular.forEach(this.groups, function (group) {\n        if ( group !== openGroup ) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n\n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on('$destroy', function (event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if ( index !== -1 ) {\n      this.groups.splice(index, 1);\n    }\n  };\n\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive('accordion', function () {\n  return {\n    restrict:'EA',\n    controller:'AccordionController',\n    transclude: true,\n    replace: false,\n    templateUrl: 'template/accordion/accordion.html'\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive('accordionGroup', function() {\n  return {\n    require:'^accordion',         // We need this directive to be inside an accordion\n    restrict:'EA',\n    transclude:true,              // It transcludes the contents of the directive into the template\n    replace: true,                // The element containing the directive will be replaced with the template\n    templateUrl:'template/accordion/accordion-group.html',\n    scope: {\n      heading: '@',               // Interpolate the heading attribute onto this scope\n      isOpen: '=?',\n      isDisabled: '=?'\n    },\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      accordionCtrl.addGroup(scope);\n\n      scope.$watch('isOpen', function(value) {\n        if ( value ) {\n          accordionCtrl.closeOthers(scope);\n        }\n      });\n\n      scope.toggleOpen = function() {\n        if ( !scope.isDisabled ) {\n          scope.isOpen = !scope.isOpen;\n        }\n      };\n    }\n  };\n})\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n// <accordion-group>\n//   <accordion-heading>Heading containing HTML - <img src=\"...\"></accordion-heading>\n// </accordion-group>\n.directive('accordionHeading', function() {\n  return {\n    restrict: 'EA',\n    transclude: true,   // Grab the contents to be used as the heading\n    template: '',       // In effect remove this element!\n    replace: true,\n    require: '^accordionGroup',\n    link: function(scope, element, attr, accordionGroupCtrl, transclude) {\n      // Pass the heading to the accordion-group controller\n      // so that it can be transcluded into the right place in the template\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n      accordionGroupCtrl.setHeading(transclude(scope, function() {}));\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n// <div class=\"accordion-group\">\n//   <div class=\"accordion-heading\" ><a ... accordion-transclude=\"heading\">...</a></div>\n//   ...\n// </div>\n.directive('accordionTransclude', function() {\n  return {\n    require: '^accordionGroup',\n    link: function(scope, element, attr, controller) {\n      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n        if ( heading ) {\n          element.html('');\n          element.append(heading);\n        }\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.alert', [])\n\n.controller('AlertController', ['$scope', '$attrs', function ($scope, $attrs) {\n  $scope.closeable = 'close' in $attrs;\n}])\n\n.directive('alert', function () {\n  return {\n    restrict:'EA',\n    controller:'AlertController',\n    templateUrl:'template/alert/alert.html',\n    transclude:true,\n    replace:true,\n    scope: {\n      type: '@',\n      close: '&'\n    }\n  };\n});\n\nangular.module('ui.bootstrap.bindHtml', [])\n\n  .directive('bindHtmlUnsafe', function () {\n    return function (scope, element, attr) {\n      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);\n      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {\n        element.html(value || '');\n      });\n    };\n  });\nangular.module('ui.bootstrap.buttons', [])\n\n.constant('buttonConfig', {\n  activeClass: 'active',\n  toggleEvent: 'click'\n})\n\n.controller('ButtonsController', ['buttonConfig', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass || 'active';\n  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n}])\n\n.directive('btnRadio', function () {\n  return {\n    require: ['btnRadio', 'ngModel'],\n    controller: 'ButtonsController',\n    link: function (scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      //model -> UI\n      ngModelCtrl.$render = function () {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n      };\n\n      //ui->model\n      element.bind(buttonsCtrl.toggleEvent, function () {\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n          scope.$apply(function () {\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n    }\n  };\n})\n\n.directive('btnCheckbox', function () {\n  return {\n    require: ['btnCheckbox', 'ngModel'],\n    controller: 'ButtonsController',\n    link: function (scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n\n      function getCheckboxValue(attributeValue, defaultValue) {\n        var val = scope.$eval(attributeValue);\n        return angular.isDefined(val) ? val : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function () {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.bind(buttonsCtrl.toggleEvent, function () {\n        scope.$apply(function () {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\n/**\n* @ngdoc overview\n* @name ui.bootstrap.carousel\n*\n* @description\n* AngularJS version of an image carousel.\n*\n*/\nangular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition'])\n.controller('CarouselController', ['$scope', '$timeout', '$transition', function ($scope, $timeout, $transition) {\n  var self = this,\n    slides = self.slides = $scope.slides = [],\n    currentIndex = -1,\n    currentTimeout, isPlaying;\n  self.currentSlide = null;\n\n  var destroyed = false;\n  /* direction: \"prev\" or \"next\" */\n  self.select = $scope.select = function(nextSlide, direction) {\n    var nextIndex = slides.indexOf(nextSlide);\n    //Decide direction if it's not given\n    if (direction === undefined) {\n      direction = nextIndex > currentIndex ? 'next' : 'prev';\n    }\n    if (nextSlide && nextSlide !== self.currentSlide) {\n      if ($scope.$currentTransition) {\n        $scope.$currentTransition.cancel();\n        //Timeout so ng-class in template has time to fix classes for finished slide\n        $timeout(goNext);\n      } else {\n        goNext();\n      }\n    }\n    function goNext() {\n      // Scope has been destroyed, stop here.\n      if (destroyed) { return; }\n      //If we have a slide to transition from and we have a transition type and we're allowed, go\n      if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {\n        //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime\n        nextSlide.$element.addClass(direction);\n        var reflow = nextSlide.$element[0].offsetWidth; //force reflow\n\n        //Set all other slides to stop doing their stuff for the new transition\n        angular.forEach(slides, function(slide) {\n          angular.extend(slide, {direction: '', entering: false, leaving: false, active: false});\n        });\n        angular.extend(nextSlide, {direction: direction, active: true, entering: true});\n        angular.extend(self.currentSlide||{}, {direction: direction, leaving: true});\n\n        $scope.$currentTransition = $transition(nextSlide.$element, {});\n        //We have to create new pointers inside a closure since next & current will change\n        (function(next,current) {\n          $scope.$currentTransition.then(\n            function(){ transitionDone(next, current); },\n            function(){ transitionDone(next, current); }\n          );\n        }(nextSlide, self.currentSlide));\n      } else {\n        transitionDone(nextSlide, self.currentSlide);\n      }\n      self.currentSlide = nextSlide;\n      currentIndex = nextIndex;\n      //every time you change slides, reset the timer\n      restartTimer();\n    }\n    function transitionDone(next, current) {\n      angular.extend(next, {direction: '', active: true, leaving: false, entering: false});\n      angular.extend(current||{}, {direction: '', active: false, leaving: false, entering: false});\n      $scope.$currentTransition = null;\n    }\n  };\n  $scope.$on('$destroy', function () {\n    destroyed = true;\n  });\n\n  /* Allow outside people to call indexOf on slides array */\n  self.indexOfSlide = function(slide) {\n    return slides.indexOf(slide);\n  };\n\n  $scope.next = function() {\n    var newIndex = (currentIndex + 1) % slides.length;\n\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (!$scope.$currentTransition) {\n      return self.select(slides[newIndex], 'next');\n    }\n  };\n\n  $scope.prev = function() {\n    var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;\n\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (!$scope.$currentTransition) {\n      return self.select(slides[newIndex], 'prev');\n    }\n  };\n\n  $scope.isActive = function(slide) {\n     return self.currentSlide === slide;\n  };\n\n  $scope.$watch('interval', restartTimer);\n  $scope.$on('$destroy', resetTimer);\n\n  function restartTimer() {\n    resetTimer();\n    var interval = +$scope.interval;\n    if (!isNaN(interval) && interval>=0) {\n      currentTimeout = $timeout(timerFn, interval);\n    }\n  }\n\n  function resetTimer() {\n    if (currentTimeout) {\n      $timeout.cancel(currentTimeout);\n      currentTimeout = null;\n    }\n  }\n\n  function timerFn() {\n    if (isPlaying) {\n      $scope.next();\n      restartTimer();\n    } else {\n      $scope.pause();\n    }\n  }\n\n  $scope.play = function() {\n    if (!isPlaying) {\n      isPlaying = true;\n      restartTimer();\n    }\n  };\n  $scope.pause = function() {\n    if (!$scope.noPause) {\n      isPlaying = false;\n      resetTimer();\n    }\n  };\n\n  self.addSlide = function(slide, element) {\n    slide.$element = element;\n    slides.push(slide);\n    //if this is the first slide or the slide is set to active, select it\n    if(slides.length === 1 || slide.active) {\n      self.select(slides[slides.length-1]);\n      if (slides.length == 1) {\n        $scope.play();\n      }\n    } else {\n      slide.active = false;\n    }\n  };\n\n  self.removeSlide = function(slide) {\n    //get the index of the slide inside the carousel\n    var index = slides.indexOf(slide);\n    slides.splice(index, 1);\n    if (slides.length > 0 && slide.active) {\n      if (index >= slides.length) {\n        self.select(slides[index-1]);\n      } else {\n        self.select(slides[index]);\n      }\n    } else if (currentIndex > index) {\n      currentIndex--;\n    }\n  };\n\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:carousel\n * @restrict EA\n *\n * @description\n * Carousel is the outer container for a set of image 'slides' to showcase.\n *\n * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\n * @param {boolean=} noTransition Whether to disable transitions on the carousel.\n * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <carousel>\n      <slide>\n        <img src=\"http://placekitten.com/150/150\" style=\"margin:auto;\">\n        <div class=\"carousel-caption\">\n          <p>Beautiful!</p>\n        </div>\n      </slide>\n      <slide>\n        <img src=\"http://placekitten.com/100/150\" style=\"margin:auto;\">\n        <div class=\"carousel-caption\">\n          <p>D'aww!</p>\n        </div>\n      </slide>\n    </carousel>\n  </file>\n  <file name=\"demo.css\">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n */\n.directive('carousel', [function() {\n  return {\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    controller: 'CarouselController',\n    require: 'carousel',\n    templateUrl: 'template/carousel/carousel.html',\n    scope: {\n      interval: '=',\n      noTransition: '=',\n      noPause: '='\n    }\n  };\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:slide\n * @restrict EA\n *\n * @description\n * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\n *\n * @param {boolean=} active Model binding, whether or not this slide is currently active.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n<div ng-controller=\"CarouselDemoCtrl\">\n  <carousel>\n    <slide ng-repeat=\"slide in slides\" active=\"slide.active\">\n      <img ng-src=\"{{slide.image}}\" style=\"margin:auto;\">\n      <div class=\"carousel-caption\">\n        <h4>Slide {{$index}}</h4>\n        <p>{{slide.text}}</p>\n      </div>\n    </slide>\n  </carousel>\n  Interval, in milliseconds: <input type=\"number\" ng-model=\"myInterval\">\n  <br />Enter a negative number to stop the interval.\n</div>\n  </file>\n  <file name=\"script.js\">\nfunction CarouselDemoCtrl($scope) {\n  $scope.myInterval = 5000;\n}\n  </file>\n  <file name=\"demo.css\">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n*/\n\n.directive('slide', function() {\n  return {\n    require: '^carousel',\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    templateUrl: 'template/carousel/slide.html',\n    scope: {\n      active: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch('active', function(active) {\n        if (active) {\n          carouselCtrl.select(scope);\n        }\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.dateparser', [])\n\n.service('dateParser', ['$locale', 'orderByFilter', function($locale, orderByFilter) {\n\n  this.parsers = {};\n\n  var formatCodeToRegex = {\n    'yyyy': {\n      regex: '\\\\d{4}',\n      apply: function(value) { this.year = +value; }\n    },\n    'yy': {\n      regex: '\\\\d{2}',\n      apply: function(value) { this.year = +value + 2000; }\n    },\n    'y': {\n      regex: '\\\\d{1,4}',\n      apply: function(value) { this.year = +value; }\n    },\n    'MMMM': {\n      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }\n    },\n    'MMM': {\n      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }\n    },\n    'MM': {\n      regex: '0[1-9]|1[0-2]',\n      apply: function(value) { this.month = value - 1; }\n    },\n    'M': {\n      regex: '[1-9]|1[0-2]',\n      apply: function(value) { this.month = value - 1; }\n    },\n    'dd': {\n      regex: '[0-2][0-9]{1}|3[0-1]{1}',\n      apply: function(value) { this.date = +value; }\n    },\n    'd': {\n      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n      apply: function(value) { this.date = +value; }\n    },\n    'EEEE': {\n      regex: $locale.DATETIME_FORMATS.DAY.join('|')\n    },\n    'EEE': {\n      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')\n    }\n  };\n\n  function createParser(format) {\n    var map = [], regex = format.split('');\n\n    angular.forEach(formatCodeToRegex, function(data, code) {\n      var index = format.indexOf(code);\n\n      if (index > -1) {\n        format = format.split('');\n\n        regex[index] = '(' + data.regex + ')';\n        format[index] = '$'; // Custom symbol to define consumed part of format\n        for (var i = index + 1, n = index + code.length; i < n; i++) {\n          regex[i] = '';\n          format[i] = '$';\n        }\n        format = format.join('');\n\n        map.push({ index: index, apply: data.apply });\n      }\n    });\n\n    return {\n      regex: new RegExp('^' + regex.join('') + '$'),\n      map: orderByFilter(map, 'index')\n    };\n  }\n\n  this.parse = function(input, format) {\n    if ( !angular.isString(input) || !format ) {\n      return input;\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n\n    if ( !this.parsers[format] ) {\n      this.parsers[format] = createParser(format);\n    }\n\n    var parser = this.parsers[format],\n        regex = parser.regex,\n        map = parser.map,\n        results = input.match(regex);\n\n    if ( results && results.length ) {\n      var fields = { year: 1900, month: 0, date: 1, hours: 0 }, dt;\n\n      for( var i = 1, n = results.length; i < n; i++ ) {\n        var mapper = map[i-1];\n        if ( mapper.apply ) {\n          mapper.apply.call(fields, results[i]);\n        }\n      }\n\n      if ( isValid(fields.year, fields.month, fields.date) ) {\n        dt = new Date( fields.year, fields.month, fields.date, fields.hours);\n      }\n\n      return dt;\n    }\n  };\n\n  // Check if date is valid for specific month (and year for February).\n  // Month: 0 = Jan, 1 = Feb, etc\n  function isValid(year, month, date) {\n    if ( month === 1 && date > 28) {\n        return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n    }\n\n    if ( month === 3 || month === 5 || month === 8 || month === 10) {\n        return date < 31;\n    }\n\n    return true;\n  }\n}]);\n\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods that can be use to retrieve position of DOM elements.\n * It is meant to be used where we need to absolute-position DOM elements in\n * relation to other, existing elements (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$position', ['$document', '$window', function ($document, $window) {\n\n    function getStyle(el, cssprop) {\n      if (el.currentStyle) { //IE\n        return el.currentStyle[cssprop];\n      } else if ($window.getComputedStyle) {\n        return $window.getComputedStyle(el)[cssprop];\n      }\n      // finally try and get inline style\n      return el.style[cssprop];\n    }\n\n    /**\n     * Checks if a given element is statically positioned\n     * @param element - raw DOM element\n     */\n    function isStaticPositioned(element) {\n      return (getStyle(element, 'position') || 'static' ) === 'static';\n    }\n\n    /**\n     * returns the closest, non-statically positioned parentOffset of a given element\n     * @param element\n     */\n    var parentOffsetEl = function (element) {\n      var docDomEl = $document[0];\n      var offsetParent = element.offsetParent || docDomEl;\n      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docDomEl;\n    };\n\n    return {\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/\n       */\n      position: function (element) {\n        var elBCR = this.offset(element);\n        var offsetParentBCR = { top: 0, left: 0 };\n        var offsetParentEl = parentOffsetEl(element[0]);\n        if (offsetParentEl != $document[0]) {\n          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n        }\n\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: elBCR.top - offsetParentBCR.top,\n          left: elBCR.left - offsetParentBCR.left\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/\n       */\n      offset: function (element) {\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n        };\n      },\n\n      /**\n       * Provides coordinates for the targetEl in relation to hostEl\n       */\n      positionElements: function (hostEl, targetEl, positionStr, appendToBody) {\n\n        var positionStrParts = positionStr.split('-');\n        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\n        var hostElPos,\n          targetElWidth,\n          targetElHeight,\n          targetElPos;\n\n        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\n        targetElWidth = targetEl.prop('offsetWidth');\n        targetElHeight = targetEl.prop('offsetHeight');\n\n        var shiftWidth = {\n          center: function () {\n            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n          },\n          left: function () {\n            return hostElPos.left;\n          },\n          right: function () {\n            return hostElPos.left + hostElPos.width;\n          }\n        };\n\n        var shiftHeight = {\n          center: function () {\n            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n          },\n          top: function () {\n            return hostElPos.top;\n          },\n          bottom: function () {\n            return hostElPos.top + hostElPos.height;\n          }\n        };\n\n        switch (pos0) {\n          case 'right':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: shiftWidth[pos0]()\n            };\n            break;\n          case 'left':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: hostElPos.left - targetElWidth\n            };\n            break;\n          case 'bottom':\n            targetElPos = {\n              top: shiftHeight[pos0](),\n              left: shiftWidth[pos1]()\n            };\n            break;\n          default:\n            targetElPos = {\n              top: hostElPos.top - targetElHeight,\n              left: shiftWidth[pos1]()\n            };\n            break;\n        }\n\n        return targetElPos;\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])\n\n.constant('datepickerConfig', {\n  formatDay: 'dd',\n  formatMonth: 'MMMM',\n  formatYear: 'yyyy',\n  formatDayHeader: 'EEE',\n  formatDayTitle: 'MMMM yyyy',\n  formatMonthTitle: 'yyyy',\n  datepickerMode: 'day',\n  minMode: 'day',\n  maxMode: 'year',\n  showWeeks: true,\n  startingDay: 0,\n  yearRange: 20,\n  minDate: null,\n  maxDate: null\n})\n\n.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$timeout', '$log', 'dateFilter', 'datepickerConfig', function($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\n  // Modes chain\n  this.modes = ['day', 'month', 'year'];\n\n  // Configuration attributes\n  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n                   'minMode', 'maxMode', 'showWeeks', 'startingDay', 'yearRange'], function( key, index ) {\n    self[key] = angular.isDefined($attrs[key]) ? (index < 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n  });\n\n  // Watchable date attributes\n  angular.forEach(['minDate', 'maxDate'], function( key ) {\n    if ( $attrs[key] ) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = value ? new Date(value) : null;\n        self.refreshView();\n      });\n    } else {\n      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n    }\n  });\n\n  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n  this.activeDate = angular.isDefined($attrs.initDate) ? $scope.$parent.$eval($attrs.initDate) : new Date();\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function( ngModelCtrl_ ) {\n    ngModelCtrl = ngModelCtrl_;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if ( ngModelCtrl.$modelValue ) {\n      var date = new Date( ngModelCtrl.$modelValue ),\n          isValid = !isNaN(date);\n\n      if ( isValid ) {\n        this.activeDate = date;\n      } else {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n      }\n      ngModelCtrl.$setValidity('date', isValid);\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if ( this.element ) {\n      this._refreshView();\n\n      var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;\n      ngModelCtrl.$setValidity('date-disabled', !date || (this.element && !this.isDisabled(date)));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;\n    return {\n      date: date,\n      label: dateFilter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0\n    };\n  };\n\n  this.isDisabled = function( date ) {\n    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  $scope.select = function( date ) {\n    if ( $scope.datepickerMode === self.minMode ) {\n      var dt = ngModelCtrl.$modelValue ? new Date( ngModelCtrl.$modelValue ) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );\n      ngModelCtrl.$setViewValue( dt );\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) - 1 ];\n    }\n  };\n\n  $scope.move = function( direction ) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function( direction ) {\n    direction = direction || 1;\n\n    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n      return;\n    }\n\n    $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) + direction ];\n  };\n\n  // Key event mapper\n  $scope.keys = { 13:'enter', 32:'space', 33:'pageup', 34:'pagedown', 35:'end', 36:'home', 37:'left', 38:'up', 39:'right', 40:'down' };\n\n  var focusElement = function() {\n    $timeout(function() {\n      self.element[0].focus();\n    }, 0 , false);\n  };\n\n  // Listen for focus requests from popup directive\n  $scope.$on('datepicker.focus', focusElement);\n\n  $scope.keydown = function( evt ) {\n    var key = $scope.keys[evt.which];\n\n    if ( !key || evt.shiftKey || evt.altKey ) {\n      return;\n    }\n\n    evt.preventDefault();\n    evt.stopPropagation();\n\n    if (key === 'enter' || key === 'space') {\n      if ( self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n      focusElement();\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n      focusElement();\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n}])\n\n.directive( 'datepicker', function () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/datepicker/datepicker.html',\n    scope: {\n      datepickerMode: '=?',\n      dateDisabled: '&'\n    },\n    require: ['datepicker', '?^ngModel'],\n    controller: 'DatepickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if ( ngModelCtrl ) {\n        datepickerCtrl.init( ngModelCtrl );\n      }\n    }\n  };\n})\n\n.directive('daypicker', ['dateFilter', function (dateFilter) {\n  return {\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/datepicker/day.html',\n    require: '^datepicker',\n    link: function(scope, element, attrs, ctrl) {\n      scope.showWeeks = ctrl.showWeeks;\n\n      ctrl.step = { months: 1 };\n      ctrl.element = element;\n\n      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n      function getDaysInMonth( year, month ) {\n        return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];\n      }\n\n      function getDates(startDate, n) {\n        var dates = new Array(n), current = new Date(startDate), i = 0;\n        current.setHours(12); // Prevent repeated dates because of timezone bug\n        while ( i < n ) {\n          dates[i++] = new Date(current);\n          current.setDate( current.getDate() + 1 );\n        }\n        return dates;\n      }\n\n      ctrl._refreshView = function() {\n        var year = ctrl.activeDate.getFullYear(),\n          month = ctrl.activeDate.getMonth(),\n          firstDayOfMonth = new Date(year, month, 1),\n          difference = ctrl.startingDay - firstDayOfMonth.getDay(),\n          numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n          firstDate = new Date(firstDayOfMonth);\n\n        if ( numDisplayedFromPreviousMonth > 0 ) {\n          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );\n        }\n\n        // 42 is the number of days on a six-month calendar\n        var days = getDates(firstDate, 42);\n        for (var i = 0; i < 42; i ++) {\n          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {\n            secondary: days[i].getMonth() !== month,\n            uid: scope.uniqueId + '-' + i\n          });\n        }\n\n        scope.labels = new Array(7);\n        for (var j = 0; j < 7; j++) {\n          scope.labels[j] = {\n            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),\n            full: dateFilter(days[j].date, 'EEEE')\n          };\n        }\n\n        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);\n        scope.rows = ctrl.split(days, 7);\n\n        if ( scope.showWeeks ) {\n          scope.weekNumbers = [];\n          var weekNumber = getISO8601WeekNumber( scope.rows[0][0].date ),\n              numWeeks = scope.rows.length;\n          while( scope.weekNumbers.push(weekNumber++) < numWeeks ) {}\n        }\n      };\n\n      ctrl.compare = function(date1, date2) {\n        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );\n      };\n\n      function getISO8601WeekNumber(date) {\n        var checkDate = new Date(date);\n        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n        var time = checkDate.getTime();\n        checkDate.setMonth(0); // Compare with Jan 1\n        checkDate.setDate(1);\n        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n      }\n\n      ctrl.handleKeyDown = function( key, evt ) {\n        var date = ctrl.activeDate.getDate();\n\n        if (key === 'left') {\n          date = date - 1;   // up\n        } else if (key === 'up') {\n          date = date - 7;   // down\n        } else if (key === 'right') {\n          date = date + 1;   // down\n        } else if (key === 'down') {\n          date = date + 7;\n        } else if (key === 'pageup' || key === 'pagedown') {\n          var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n          ctrl.activeDate.setMonth(month, 1);\n          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);\n        } else if (key === 'home') {\n          date = 1;\n        } else if (key === 'end') {\n          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());\n        }\n        ctrl.activeDate.setDate(date);\n      };\n\n      ctrl.refreshView();\n    }\n  };\n}])\n\n.directive('monthpicker', ['dateFilter', function (dateFilter) {\n  return {\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/datepicker/month.html',\n    require: '^datepicker',\n    link: function(scope, element, attrs, ctrl) {\n      ctrl.step = { years: 1 };\n      ctrl.element = element;\n\n      ctrl._refreshView = function() {\n        var months = new Array(12),\n            year = ctrl.activeDate.getFullYear();\n\n        for ( var i = 0; i < 12; i++ ) {\n          months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {\n            uid: scope.uniqueId + '-' + i\n          });\n        }\n\n        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);\n        scope.rows = ctrl.split(months, 3);\n      };\n\n      ctrl.compare = function(date1, date2) {\n        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );\n      };\n\n      ctrl.handleKeyDown = function( key, evt ) {\n        var date = ctrl.activeDate.getMonth();\n\n        if (key === 'left') {\n          date = date - 1;   // up\n        } else if (key === 'up') {\n          date = date - 3;   // down\n        } else if (key === 'right') {\n          date = date + 1;   // down\n        } else if (key === 'down') {\n          date = date + 3;\n        } else if (key === 'pageup' || key === 'pagedown') {\n          var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n          ctrl.activeDate.setFullYear(year);\n        } else if (key === 'home') {\n          date = 0;\n        } else if (key === 'end') {\n          date = 11;\n        }\n        ctrl.activeDate.setMonth(date);\n      };\n\n      ctrl.refreshView();\n    }\n  };\n}])\n\n.directive('yearpicker', ['dateFilter', function (dateFilter) {\n  return {\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/datepicker/year.html',\n    require: '^datepicker',\n    link: function(scope, element, attrs, ctrl) {\n      var range = ctrl.yearRange;\n\n      ctrl.step = { years: range };\n      ctrl.element = element;\n\n      function getStartingYear( year ) {\n        return parseInt((year - 1) / range, 10) * range + 1;\n      }\n\n      ctrl._refreshView = function() {\n        var years = new Array(range);\n\n        for ( var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++ ) {\n          years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {\n            uid: scope.uniqueId + '-' + i\n          });\n        }\n\n        scope.title = [years[0].label, years[range - 1].label].join(' - ');\n        scope.rows = ctrl.split(years, 5);\n      };\n\n      ctrl.compare = function(date1, date2) {\n        return date1.getFullYear() - date2.getFullYear();\n      };\n\n      ctrl.handleKeyDown = function( key, evt ) {\n        var date = ctrl.activeDate.getFullYear();\n\n        if (key === 'left') {\n          date = date - 1;   // up\n        } else if (key === 'up') {\n          date = date - 5;   // down\n        } else if (key === 'right') {\n          date = date + 1;   // down\n        } else if (key === 'down') {\n          date = date + 5;\n        } else if (key === 'pageup' || key === 'pagedown') {\n          date += (key === 'pageup' ? - 1 : 1) * ctrl.step.years;\n        } else if (key === 'home') {\n          date = getStartingYear( ctrl.activeDate.getFullYear() );\n        } else if (key === 'end') {\n          date = getStartingYear( ctrl.activeDate.getFullYear() ) + range - 1;\n        }\n        ctrl.activeDate.setFullYear(date);\n      };\n\n      ctrl.refreshView();\n    }\n  };\n}])\n\n.constant('datepickerPopupConfig', {\n  datepickerPopup: 'yyyy-MM-dd',\n  currentText: 'Today',\n  clearText: 'Clear',\n  closeText: 'Done',\n  closeOnDateSelection: true,\n  appendToBody: false,\n  showButtonBar: true\n})\n\n.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig',\nfunction ($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {\n  return {\n    restrict: 'EA',\n    require: 'ngModel',\n    scope: {\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@',\n      dateDisabled: '&'\n    },\n    link: function(scope, element, attrs, ngModel) {\n      var dateFormat,\n          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,\n          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n\n      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\n      scope.getText = function( key ) {\n        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n      };\n\n      attrs.$observe('datepickerPopup', function(value) {\n          dateFormat = value || datepickerPopupConfig.datepickerPopup;\n          ngModel.$render();\n      });\n\n      // popup element used to display calendar\n      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');\n      popupEl.attr({\n        'ng-model': 'date',\n        'ng-change': 'dateSelection()'\n      });\n\n      function cameltoDash( string ){\n        return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n      }\n\n      // datepicker element\n      var datepickerEl = angular.element(popupEl.children()[0]);\n      if ( attrs.datepickerOptions ) {\n        angular.forEach(scope.$parent.$eval(attrs.datepickerOptions), function( value, option ) {\n          datepickerEl.attr( cameltoDash(option), value );\n        });\n      }\n\n      scope.watchData = {};\n      angular.forEach(['minDate', 'maxDate', 'datepickerMode'], function( key ) {\n        if ( attrs[key] ) {\n          var getAttribute = $parse(attrs[key]);\n          scope.$parent.$watch(getAttribute, function(value){\n            scope.watchData[key] = value;\n          });\n          datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\n          // Propagate changes from datepicker to outside\n          if ( key === 'datepickerMode' ) {\n            var setAttribute = getAttribute.assign;\n            scope.$watch('watchData.' + key, function(value, oldvalue) {\n              if ( value !== oldvalue ) {\n                setAttribute(scope.$parent, value);\n              }\n            });\n          }\n        }\n      });\n      if (attrs.dateDisabled) {\n        datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n      }\n\n      function parseDate(viewValue) {\n        if (!viewValue) {\n          ngModel.$setValidity('date', true);\n          return null;\n        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n          ngModel.$setValidity('date', true);\n          return viewValue;\n        } else if (angular.isString(viewValue)) {\n          var date = dateParser.parse(viewValue, dateFormat) || new Date(viewValue);\n          if (isNaN(date)) {\n            ngModel.$setValidity('date', false);\n            return undefined;\n          } else {\n            ngModel.$setValidity('date', true);\n            return date;\n          }\n        } else {\n          ngModel.$setValidity('date', false);\n          return undefined;\n        }\n      }\n      ngModel.$parsers.unshift(parseDate);\n\n      // Inner change\n      scope.dateSelection = function(dt) {\n        if (angular.isDefined(dt)) {\n          scope.date = dt;\n        }\n        ngModel.$setViewValue(scope.date);\n        ngModel.$render();\n\n        if ( closeOnDateSelection ) {\n          scope.isOpen = false;\n          element[0].focus();\n        }\n      };\n\n      element.bind('input change keyup', function() {\n        scope.$apply(function() {\n          scope.date = ngModel.$modelValue;\n        });\n      });\n\n      // Outter change\n      ngModel.$render = function() {\n        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';\n        element.val(date);\n        scope.date = parseDate( ngModel.$modelValue );\n      };\n\n      var documentClickBind = function(event) {\n        if (scope.isOpen && event.target !== element[0]) {\n          scope.$apply(function() {\n            scope.isOpen = false;\n          });\n        }\n      };\n\n      var keydown = function(evt, noApply) {\n        scope.keydown(evt);\n      };\n      element.bind('keydown', keydown);\n\n      scope.keydown = function(evt) {\n        if (evt.which === 27) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          scope.close();\n        } else if (evt.which === 40 && !scope.isOpen) {\n          scope.isOpen = true;\n        }\n      };\n\n      scope.$watch('isOpen', function(value) {\n        if (value) {\n          scope.$broadcast('datepicker.focus');\n          scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n          scope.position.top = scope.position.top + element.prop('offsetHeight');\n\n          $document.bind('click', documentClickBind);\n        } else {\n          $document.unbind('click', documentClickBind);\n        }\n      });\n\n      scope.select = function( date ) {\n        if (date === 'today') {\n          var today = new Date();\n          if (angular.isDate(ngModel.$modelValue)) {\n            date = new Date(ngModel.$modelValue);\n            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n          } else {\n            date = new Date(today.setHours(0, 0, 0, 0));\n          }\n        }\n        scope.dateSelection( date );\n      };\n\n      scope.close = function() {\n        scope.isOpen = false;\n        element[0].focus();\n      };\n\n      var $popup = $compile(popupEl)(scope);\n      // Prevent jQuery cache memory leak (template is now redundant after linking)\n      popupEl.remove();\n\n      if ( appendToBody ) {\n        $document.find('body').append($popup);\n      } else {\n        element.after($popup);\n      }\n\n      scope.$on('$destroy', function() {\n        $popup.remove();\n        element.unbind('keydown', keydown);\n        $document.unbind('click', documentClickBind);\n      });\n    }\n  };\n}])\n\n.directive('datepickerPopupWrap', function() {\n  return {\n    restrict:'EA',\n    replace: true,\n    transclude: true,\n    templateUrl: 'template/datepicker/popup.html',\n    link:function (scope, element, attrs) {\n      element.bind('click', function(event) {\n        event.preventDefault();\n        event.stopPropagation();\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.dropdown', [])\n\n.constant('dropdownConfig', {\n  openClass: 'open'\n})\n\n.service('dropdownService', ['$document', function($document) {\n  var openScope = null;\n\n  this.open = function( dropdownScope ) {\n    if ( !openScope ) {\n      $document.bind('click', closeDropdown);\n      $document.bind('keydown', escapeKeyBind);\n    }\n\n    if ( openScope && openScope !== dropdownScope ) {\n        openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n  };\n\n  this.close = function( dropdownScope ) {\n    if ( openScope === dropdownScope ) {\n      openScope = null;\n      $document.unbind('click', closeDropdown);\n      $document.unbind('keydown', escapeKeyBind);\n    }\n  };\n\n  var closeDropdown = function( evt ) {\n    var toggleElement = openScope.getToggleElement();\n    if ( evt && toggleElement && toggleElement[0].contains(evt.target) ) {\n        return;\n    }\n\n    openScope.$apply(function() {\n      openScope.isOpen = false;\n    });\n  };\n\n  var escapeKeyBind = function( evt ) {\n    if ( evt.which === 27 ) {\n      openScope.focusToggleElement();\n      closeDropdown();\n    }\n  };\n}])\n\n.controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {\n  var self = this,\n      scope = $scope.$new(), // create a child scope so we are not polluting original one\n      openClass = dropdownConfig.openClass,\n      getIsOpen,\n      setIsOpen = angular.noop,\n      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop;\n\n  this.init = function( element ) {\n    self.$element = element;\n\n    if ( $attrs.isOpen ) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n  };\n\n  this.toggle = function( open ) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.focusToggleElement = function() {\n    if ( self.toggleElement ) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function( isOpen, wasOpen ) {\n    $animate[isOpen ? 'addClass' : 'removeClass'](self.$element, openClass);\n\n    if ( isOpen ) {\n      scope.focusToggleElement();\n      dropdownService.open( scope );\n    } else {\n      dropdownService.close( scope );\n    }\n\n    setIsOpen($scope, isOpen);\n    if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n      toggleInvoker($scope, { open: !!isOpen });\n    }\n  });\n\n  $scope.$on('$locationChangeSuccess', function() {\n    scope.isOpen = false;\n  });\n\n  $scope.$on('$destroy', function() {\n    scope.$destroy();\n  });\n}])\n\n.directive('dropdown', function() {\n  return {\n    restrict: 'CA',\n    controller: 'DropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init( element );\n    }\n  };\n})\n\n.directive('dropdownToggle', function() {\n  return {\n    restrict: 'CA',\n    require: '?^dropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if ( !dropdownCtrl ) {\n        return;\n      }\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if ( !element.hasClass('disabled') && !attrs.disabled ) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function( isOpen ) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.transition'])\n\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory('$$stackedMap', function () {\n    return {\n      createNew: function () {\n        var stack = [];\n\n        return {\n          add: function (key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function (key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function () {\n            return stack[stack.length - 1];\n          },\n          remove: function (key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function () {\n            return stack.splice(stack.length - 1, 1)[0];\n          },\n          length: function () {\n            return stack.length;\n          }\n        };\n      }\n    };\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive('modalBackdrop', ['$timeout', function ($timeout) {\n    return {\n      restrict: 'EA',\n      replace: true,\n      templateUrl: 'template/modal/backdrop.html',\n      link: function (scope, element, attrs) {\n        scope.backdropClass = attrs.backdropClass || '';\n\n        scope.animate = false;\n\n        //trigger CSS transitions\n        $timeout(function () {\n          scope.animate = true;\n        });\n      }\n    };\n  }])\n\n  .directive('modalWindow', ['$modalStack', '$timeout', function ($modalStack, $timeout) {\n    return {\n      restrict: 'EA',\n      scope: {\n        index: '@',\n        animate: '='\n      },\n      replace: true,\n      transclude: true,\n      templateUrl: function(tElement, tAttrs) {\n        return tAttrs.templateUrl || 'template/modal/window.html';\n      },\n      link: function (scope, element, attrs) {\n        element.addClass(attrs.windowClass || '');\n        scope.size = attrs.size;\n\n        $timeout(function () {\n          // trigger CSS transitions\n          scope.animate = true;\n\n          /**\n           * Auto-focusing of a freshly-opened modal element causes any child elements\n           * with the autofocus attribute to loose focus. This is an issue on touch\n           * based devices which will show and then hide the onscreen keyboard.\n           * Attempts to refocus the autofocus element via JavaScript will not reopen\n           * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n           * the modal element if the modal does not contain an autofocus element.\n           */\n          if (!element[0].querySelectorAll('[autofocus]').length) {\n            element[0].focus();\n          }\n        });\n\n        scope.close = function (evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && (evt.target === evt.currentTarget)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, 'backdrop click');\n          }\n        };\n      }\n    };\n  }])\n\n  .directive('modalTransclude', function () {\n    return {\n      link: function($scope, $element, $attrs, controller, $transclude) {\n        $transclude($scope.$parent, function(clone) {\n          $element.empty();\n          $element.append(clone);\n        });\n      }\n    };\n  })\n\n  .factory('$modalStack', ['$transition', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap',\n    function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {\n\n      var OPENED_MODAL_CLASS = 'modal-open';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var $modalStack = {};\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex){\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance) {\n\n        var body = $document.find('body').eq(0);\n        var modalWindow = openedWindows.get(modalInstance).value;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n\n        //remove window DOM element\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {\n          modalWindow.modalScope.$destroy();\n          body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);\n          checkRemoveBackdrop();\n        });\n      }\n\n      function checkRemoveBackdrop() {\n          //remove backdrop if no longer needed\n          if (backdropDomEl && backdropIndex() == -1) {\n            var backdropScopeRef = backdropScope;\n            removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {\n              backdropScopeRef.$destroy();\n              backdropScopeRef = null;\n            });\n            backdropDomEl = undefined;\n            backdropScope = undefined;\n          }\n      }\n\n      function removeAfterAnimate(domEl, scope, emulateTime, done) {\n        // Closing animation\n        scope.animate = false;\n\n        var transitionEndEventName = $transition.transitionEndEventName;\n        if (transitionEndEventName) {\n          // transition out\n          var timeout = $timeout(afterAnimating, emulateTime);\n\n          domEl.bind(transitionEndEventName, function () {\n            $timeout.cancel(timeout);\n            afterAnimating();\n            scope.$apply();\n          });\n        } else {\n          // Ensure this call is async\n          $timeout(afterAnimating);\n        }\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          domEl.remove();\n          if (done) {\n            done();\n          }\n        }\n      }\n\n      $document.bind('keydown', function (evt) {\n        var modal;\n\n        if (evt.which === 27) {\n          modal = openedWindows.top();\n          if (modal && modal.value.keyboard) {\n            evt.preventDefault();\n            $rootScope.$apply(function () {\n              $modalStack.dismiss(modal.key, 'escape key press');\n            });\n          }\n        }\n      });\n\n      $modalStack.open = function (modalInstance, modal) {\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard\n        });\n\n        var body = $document.find('body').eq(0),\n            currBackdropIndex = backdropIndex();\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.index = currBackdropIndex;\n          var angularBackgroundDomEl = angular.element('<div modal-backdrop></div>');\n          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);\n          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n          body.append(backdropDomEl);\n        }\n\n        var angularDomEl = angular.element('<div modal-window></div>');\n        angularDomEl.attr({\n          'template-url': modal.windowTemplateUrl,\n          'window-class': modal.windowClass,\n          'size': modal.size,\n          'index': openedWindows.length() - 1,\n          'animate': 'animate'\n        }).html(modal.content);\n\n        var modalDomEl = $compile(angularDomEl)(modal.scope);\n        openedWindows.top().value.modalDomEl = modalDomEl;\n        body.append(modalDomEl);\n        body.addClass(OPENED_MODAL_CLASS);\n      };\n\n      $modalStack.close = function (modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.deferred.resolve(result);\n          removeModalWindow(modalInstance);\n        }\n      };\n\n      $modalStack.dismiss = function (modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.deferred.reject(reason);\n          removeModalWindow(modalInstance);\n        }\n      };\n\n      $modalStack.dismissAll = function (reason) {\n        var topModal = this.getTop();\n        while (topModal) {\n          this.dismiss(topModal.key, reason);\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function () {\n        return openedWindows.top();\n      };\n\n      return $modalStack;\n    }])\n\n  .provider('$modal', function () {\n\n    var $modalProvider = {\n      options: {\n        backdrop: true, //can be also false or 'static'\n        keyboard: true\n      },\n      $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack',\n        function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {\n\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $http.get(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl,\n                {cache: $templateCache}).then(function (result) {\n                  return result.data;\n              });\n          }\n\n          function getResolvePromises(resolves) {\n            var promisesArr = [];\n            angular.forEach(resolves, function (value) {\n              if (angular.isFunction(value) || angular.isArray(value)) {\n                promisesArr.push($q.when($injector.invoke(value)));\n              }\n            });\n            return promisesArr;\n          }\n\n          $modal.open = function (modalOptions) {\n\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              close: function (result) {\n                $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n\n            //verify options\n            if (!modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error('One of template or templateUrl options is required.');\n            }\n\n            var templateAndResolvePromise =\n              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\n\n            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {\n\n              var modalScope = (modalOptions.scope || $rootScope).$new();\n              modalScope.$close = modalInstance.close;\n              modalScope.$dismiss = modalInstance.dismiss;\n\n              var ctrlInstance, ctrlLocals = {};\n              var resolveIter = 1;\n\n              //controllers\n              if (modalOptions.controller) {\n                ctrlLocals.$scope = modalScope;\n                ctrlLocals.$modalInstance = modalInstance;\n                angular.forEach(modalOptions.resolve, function (value, key) {\n                  ctrlLocals[key] = tplAndVars[resolveIter++];\n                });\n\n                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n                if (modalOptions.controllerAs) {\n                  modalScope[modalOptions.controllerAs] = ctrlInstance;\n                }\n              }\n\n              $modalStack.open(modalInstance, {\n                scope: modalScope,\n                deferred: modalResultDeferred,\n                content: tplAndVars[0],\n                backdrop: modalOptions.backdrop,\n                keyboard: modalOptions.keyboard,\n                backdropClass: modalOptions.backdropClass,\n                windowClass: modalOptions.windowClass,\n                windowTemplateUrl: modalOptions.windowTemplateUrl,\n                size: modalOptions.size\n              });\n\n            }, function resolveError(reason) {\n              modalResultDeferred.reject(reason);\n            });\n\n            templateAndResolvePromise.then(function () {\n              modalOpenedDeferred.resolve(true);\n            }, function () {\n              modalOpenedDeferred.reject(false);\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }]\n    };\n\n    return $modalProvider;\n  });\n\nangular.module('ui.bootstrap.pagination', [])\n\n.controller('PaginationController', ['$scope', '$attrs', '$parse', function ($scope, $attrs, $parse) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n  this.init = function(ngModelCtrl_, config) {\n    ngModelCtrl = ngModelCtrl_;\n    this.config = config;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = config.itemsPerPage;\n    }\n  };\n\n  this.calculateTotalPages = function() {\n    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  };\n\n  this.render = function() {\n    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n  };\n\n  $scope.selectPage = function(page) {\n    if ( $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n      ngModelCtrl.$setViewValue(page);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.getText = function( key ) {\n    return $scope[key + 'Text'] || self.config[key + 'Text'];\n  };\n  $scope.noPrevious = function() {\n    return $scope.page === 1;\n  };\n  $scope.noNext = function() {\n    return $scope.page === $scope.totalPages;\n  };\n\n  $scope.$watch('totalItems', function() {\n    $scope.totalPages = self.calculateTotalPages();\n  });\n\n  $scope.$watch('totalPages', function(value) {\n    setNumPages($scope.$parent, value); // Readonly variable\n\n    if ( $scope.page > value ) {\n      $scope.selectPage(value);\n    } else {\n      ngModelCtrl.$render();\n    }\n  });\n}])\n\n.constant('paginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true\n})\n\n.directive('pagination', ['$parse', 'paginationConfig', function($parse, paginationConfig) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@'\n    },\n    require: ['pagination', '?ngModel'],\n    controller: 'PaginationController',\n    templateUrl: 'template/pagination/pagination.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      // Setup configuration parameters\n      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\n      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      }\n\n      function getPages(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );\n\n        // recompute if maxSize\n        if ( isMaxSized ) {\n          if ( rotate ) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, number === currentPage);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if ( isMaxSized && ! rotate ) {\n          if ( startPage > 1 ) {\n            var previousPageSet = makePage(startPage - 1, '...', false);\n            pages.unshift(previousPageSet);\n          }\n\n          if ( endPage < totalPages ) {\n            var nextPageSet = makePage(endPage + 1, '...', false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        return pages;\n      }\n\n      var originalRender = paginationCtrl.render;\n      paginationCtrl.render = function() {\n        originalRender();\n        if (scope.page > 0 && scope.page <= scope.totalPages) {\n          scope.pages = getPages(scope.page, scope.totalPages);\n        }\n      };\n    }\n  };\n}])\n\n.constant('pagerConfig', {\n  itemsPerPage: 10,\n  previousText: ' Previous',\n  nextText: 'Next ',\n  align: true\n})\n\n.directive('pager', ['pagerConfig', function(pagerConfig) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@'\n    },\n    require: ['pager', '?ngModel'],\n    controller: 'PaginationController',\n    templateUrl: 'template/pagination/pager.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n      paginationCtrl.init(ngModelCtrl, pagerConfig);\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module( 'ui.bootstrap.tooltip', [ 'ui.bootstrap.position', 'ui.bootstrap.bindHtml' ] )\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider( '$tooltip', function () {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: 'top',\n    animation: true,\n    popupDelay: 0\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    'mouseenter': 'mouseleave',\n    'click': 'click',\n    'focus': 'blur'\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n\n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: 'left' } );\n   *   });\n   */\n\tthis.options = function( value ) {\n\t\tangular.extend( globalOptions, value );\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n   */\n  this.setTriggers = function setTriggers ( triggers ) {\n    angular.extend( triggerMap, triggers );\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake-case.\n   */\n  function snake_case(name){\n    var regexp = /[A-Z]/g;\n    var separator = '-';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : '') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = [ '$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ( $window, $compile, $timeout, $parse, $document, $position, $interpolate ) {\n    return function $tooltip ( type, prefix, defaultTriggerShow ) {\n      var options = angular.extend( {}, defaultOptions, globalOptions );\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers ( trigger ) {\n        var show = trigger || options.trigger || defaultTriggerShow;\n        var hide = triggerMap[show] || show;\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case( type );\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template =\n        '<div '+ directiveName +'-popup '+\n          'title=\"'+startSym+'tt_title'+endSym+'\" '+\n          'content=\"'+startSym+'tt_content'+endSym+'\" '+\n          'placement=\"'+startSym+'tt_placement'+endSym+'\" '+\n          'animation=\"tt_animation\" '+\n          'is-open=\"tt_isOpen\"'+\n          '>'+\n        '</div>';\n\n      return {\n        restrict: 'EA',\n        scope: true,\n        compile: function (tElem, tAttrs) {\n          var tooltipLinker = $compile( template );\n\n          return function link ( scope, element, attrs ) {\n            var tooltip;\n            var transitionTimeout;\n            var popupTimeout;\n            var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;\n            var triggers = getTriggers( undefined );\n            var hasEnableExp = angular.isDefined(attrs[prefix+'Enable']);\n\n            var positionTooltip = function () {\n\n              var ttPosition = $position.positionElements(element, tooltip, scope.tt_placement, appendToBody);\n              ttPosition.top += 'px';\n              ttPosition.left += 'px';\n\n              // Now set the calculated positioning.\n              tooltip.css( ttPosition );\n            };\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            scope.tt_isOpen = false;\n\n            function toggleTooltipBind () {\n              if ( ! scope.tt_isOpen ) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if(hasEnableExp && !scope.$eval(attrs[prefix+'Enable'])) {\n                return;\n              }\n              if ( scope.tt_popupDelay ) {\n                // Do nothing if the tooltip was already scheduled to pop-up.\n                // This happens if show is triggered multiple times before any hide is triggered.\n                if (!popupTimeout) {\n                  popupTimeout = $timeout( show, scope.tt_popupDelay, false );\n                  popupTimeout.then(function(reposition){reposition();});\n                }\n              } else {\n                show()();\n              }\n            }\n\n            function hideTooltipBind () {\n              scope.$apply(function () {\n                hide();\n              });\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n\n              popupTimeout = null;\n\n              // If there is a pending remove transition, we must cancel it, lest the\n              // tooltip be mysteriously removed.\n              if ( transitionTimeout ) {\n                $timeout.cancel( transitionTimeout );\n                transitionTimeout = null;\n              }\n\n              // Don't show empty tooltips.\n              if ( ! scope.tt_content ) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // Set the initial positioning.\n              tooltip.css({ top: 0, left: 0, display: 'block' });\n\n              // Now we add it to the DOM because need some info about it. But it's not \n              // visible yet anyway.\n              if ( appendToBody ) {\n                  $document.find( 'body' ).append( tooltip );\n              } else {\n                element.after( tooltip );\n              }\n\n              positionTooltip();\n\n              // And show the tooltip.\n              scope.tt_isOpen = true;\n              scope.$digest(); // digest required as $apply is not called\n\n              // Return positioning function as promise callback for correct\n              // positioning after draw.\n              return positionTooltip;\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              // First things first: we don't show it anymore.\n              scope.tt_isOpen = false;\n\n              //if tooltip is going to be shown after delay, we must cancel this\n              $timeout.cancel( popupTimeout );\n              popupTimeout = null;\n\n              // And now we remove it from the DOM. However, if we have animation, we \n              // need to wait for it to expire beforehand.\n              // FIXME: this is a placeholder for a port of the transitions library.\n              if ( scope.tt_animation ) {\n                if (!transitionTimeout) {\n                  transitionTimeout = $timeout(removeTooltip, 500);\n                }\n              } else {\n                removeTooltip();\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                removeTooltip();\n              }\n              tooltip = tooltipLinker(scope, function () {});\n\n              // Get contents rendered into the tooltip\n              scope.$digest();\n            }\n\n            function removeTooltip() {\n              transitionTimeout = null;\n              if (tooltip) {\n                tooltip.remove();\n                tooltip = null;\n              }\n            }\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe( type, function ( val ) {\n              scope.tt_content = val;\n\n              if (!val && scope.tt_isOpen ) {\n                hide();\n              }\n            });\n\n            attrs.$observe( prefix+'Title', function ( val ) {\n              scope.tt_title = val;\n            });\n\n            attrs.$observe( prefix+'Placement', function ( val ) {\n              scope.tt_placement = angular.isDefined( val ) ? val : options.placement;\n            });\n\n            attrs.$observe( prefix+'PopupDelay', function ( val ) {\n              var delay = parseInt( val, 10 );\n              scope.tt_popupDelay = ! isNaN(delay) ? delay : options.popupDelay;\n            });\n\n            var unregisterTriggers = function () {\n              element.unbind(triggers.show, showTooltipBind);\n              element.unbind(triggers.hide, hideTooltipBind);\n            };\n\n            attrs.$observe( prefix+'Trigger', function ( val ) {\n              unregisterTriggers();\n\n              triggers = getTriggers( val );\n\n              if ( triggers.show === triggers.hide ) {\n                element.bind( triggers.show, toggleTooltipBind );\n              } else {\n                element.bind( triggers.show, showTooltipBind );\n                element.bind( triggers.hide, hideTooltipBind );\n              }\n            });\n\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\n            scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            attrs.$observe( prefix+'AppendToBody', function ( val ) {\n              appendToBody = angular.isDefined( val ) ? $parse( val )( scope ) : appendToBody;\n            });\n\n            // if a tooltip is attached to <body> we need to remove it on\n            // location change as its parent scope will probably not be destroyed\n            // by the change.\n            if ( appendToBody ) {\n              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {\n              if ( scope.tt_isOpen ) {\n                hide();\n              }\n            });\n            }\n\n            // Make sure tooltip is destroyed and removed.\n            scope.$on('$destroy', function onDestroyTooltip() {\n              $timeout.cancel( transitionTimeout );\n              $timeout.cancel( popupTimeout );\n              unregisterTriggers();\n              removeTooltip();\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n.directive( 'tooltipPopup', function () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-popup.html'\n  };\n})\n\n.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {\n  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );\n}])\n\n.directive( 'tooltipHtmlUnsafePopup', function () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'\n  };\n})\n\n.directive( 'tooltipHtmlUnsafe', [ '$tooltip', function ( $tooltip ) {\n  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html popovers, and selector delegatation.\n */\nangular.module( 'ui.bootstrap.popover', [ 'ui.bootstrap.tooltip' ] )\n\n.directive( 'popoverPopup', function () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover.html'\n  };\n})\n\n.directive( 'popover', [ '$tooltip', function ( $tooltip ) {\n  return $tooltip( 'popover', 'popover', 'click' );\n}]);\n\nangular.module('ui.bootstrap.progressbar', [])\n\n.constant('progressConfig', {\n  animate: true,\n  max: 100\n})\n\n.controller('ProgressController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {\n    var self = this,\n        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n    this.bars = [];\n    $scope.max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max;\n\n    this.addBar = function(bar, element) {\n        if ( !animate ) {\n            element.css({'transition': 'none'});\n        }\n\n        this.bars.push(bar);\n\n        bar.$watch('value', function( value ) {\n            bar.percent = +(100 * value / $scope.max).toFixed(2);\n        });\n\n        bar.$on('$destroy', function() {\n            element = null;\n            self.removeBar(bar);\n        });\n    };\n\n    this.removeBar = function(bar) {\n        this.bars.splice(this.bars.indexOf(bar), 1);\n    };\n}])\n\n.directive('progress', function() {\n    return {\n        restrict: 'EA',\n        replace: true,\n        transclude: true,\n        controller: 'ProgressController',\n        require: 'progress',\n        scope: {},\n        templateUrl: 'template/progressbar/progress.html'\n    };\n})\n\n.directive('bar', function() {\n    return {\n        restrict: 'EA',\n        replace: true,\n        transclude: true,\n        require: '^progress',\n        scope: {\n            value: '=',\n            type: '@'\n        },\n        templateUrl: 'template/progressbar/bar.html',\n        link: function(scope, element, attrs, progressCtrl) {\n            progressCtrl.addBar(scope, element);\n        }\n    };\n})\n\n.directive('progressbar', function() {\n    return {\n        restrict: 'EA',\n        replace: true,\n        transclude: true,\n        controller: 'ProgressController',\n        scope: {\n            value: '=',\n            type: '@'\n        },\n        templateUrl: 'template/progressbar/progressbar.html',\n        link: function(scope, element, attrs, progressCtrl) {\n            progressCtrl.addBar(scope, angular.element(element.children()[0]));\n        }\n    };\n});\nangular.module('ui.bootstrap.rating', [])\n\n.constant('ratingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null\n})\n\n.controller('RatingController', ['$scope', '$attrs', 'ratingConfig', function($scope, $attrs, ratingConfig) {\n  var ngModelCtrl  = { $setViewValue: angular.noop };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\n    var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) :\n                        new Array( angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max );\n    $scope.range = this.buildTemplateObjects(ratingStates);\n  };\n\n  this.buildTemplateObjects = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff }, states[i]);\n    }\n    return states;\n  };\n\n  $scope.rate = function(value) {\n    if ( !$scope.readonly && value >= 0 && value <= $scope.range.length ) {\n      ngModelCtrl.$setViewValue(value);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.enter = function(value) {\n    if ( !$scope.readonly ) {\n      $scope.value = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.onLeave();\n  };\n\n  $scope.onKeydown = function(evt) {\n    if (/(37|38|39|40)/.test(evt.which)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.rate( $scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1) );\n    }\n  };\n\n  this.render = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n  };\n}])\n\n.directive('rating', function() {\n  return {\n    restrict: 'EA',\n    require: ['rating', 'ngModel'],\n    scope: {\n      readonly: '=?',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'RatingController',\n    templateUrl: 'template/rating/rating.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if ( ngModelCtrl ) {\n        ratingCtrl.init( ngModelCtrl );\n      }\n    }\n  };\n});\n\n/**\n * @ngdoc overview\n * @name ui.bootstrap.tabs\n *\n * @description\n * AngularJS version of the tabs directive.\n */\n\nangular.module('ui.bootstrap.tabs', [])\n\n.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {\n  var ctrl = this,\n      tabs = ctrl.tabs = $scope.tabs = [];\n\n  ctrl.select = function(selectedTab) {\n    angular.forEach(tabs, function(tab) {\n      if (tab.active && tab !== selectedTab) {\n        tab.active = false;\n        tab.onDeselect();\n      }\n    });\n    selectedTab.active = true;\n    selectedTab.onSelect();\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    tabs.push(tab);\n    // we can't run the select function on the first tab\n    // since that would select it twice\n    if (tabs.length === 1) {\n      tab.active = true;\n    } else if (tab.active) {\n      ctrl.select(tab);\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index = tabs.indexOf(tab);\n    //Select a new tab if the tab to be removed is selected\n    if (tab.active && tabs.length > 1) {\n      //If this is the last tab, select the previous tab. else, the next tab.\n      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n      ctrl.select(tabs[newActiveIndex]);\n    }\n    tabs.splice(index, 1);\n  };\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabset\n * @restrict EA\n *\n * @description\n * Tabset is the outer container for the tabs directive\n *\n * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <tabset>\n      <tab heading=\"Tab 1\"><b>First</b> Content!</tab>\n      <tab heading=\"Tab 2\"><i>Second</i> Content!</tab>\n    </tabset>\n    <hr />\n    <tabset vertical=\"true\">\n      <tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</tab>\n      <tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</tab>\n    </tabset>\n    <tabset justified=\"true\">\n      <tab heading=\"Justified Tab 1\"><b>First</b> Justified Content!</tab>\n      <tab heading=\"Justified Tab 2\"><i>Second</i> Justified Content!</tab>\n    </tabset>\n  </file>\n</example>\n */\n.directive('tabset', function() {\n  return {\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@'\n    },\n    controller: 'TabsetController',\n    templateUrl: 'template/tabs/tabset.html',\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n    }\n  };\n})\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tab\n * @restrict EA\n *\n * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\n * @param {string=} select An expression to evaluate when the tab is selected.\n * @param {boolean=} active A binding, telling whether or not this tab is selected.\n * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n *\n * @description\n * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <div ng-controller=\"TabsDemoCtrl\">\n      <button class=\"btn btn-small\" ng-click=\"items[0].active = true\">\n        Select item 1, using active binding\n      </button>\n      <button class=\"btn btn-small\" ng-click=\"items[1].disabled = !items[1].disabled\">\n        Enable/disable item 2, using disabled binding\n      </button>\n      <br />\n      <tabset>\n        <tab heading=\"Tab 1\">First Tab</tab>\n        <tab select=\"alertMe()\">\n          <tab-heading><i class=\"icon-bell\"></i> Alert me!</tab-heading>\n          Second Tab, with alert callback and html heading!\n        </tab>\n        <tab ng-repeat=\"item in items\"\n          heading=\"{{item.title}}\"\n          disabled=\"item.disabled\"\n          active=\"item.active\">\n          {{item.content}}\n        </tab>\n      </tabset>\n    </div>\n  </file>\n  <file name=\"script.js\">\n    function TabsDemoCtrl($scope) {\n      $scope.items = [\n        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\n        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\n      ];\n\n      $scope.alertMe = function() {\n        setTimeout(function() {\n          alert(\"You've selected the alert tab!\");\n        });\n      };\n    };\n  </file>\n</example>\n */\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabHeading\n * @restrict EA\n *\n * @description\n * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <tabset>\n      <tab>\n        <tab-heading><b>HTML</b> in my titles?!</tab-heading>\n        And some content, too!\n      </tab>\n      <tab>\n        <tab-heading><i class=\"icon-heart\"></i> Icon heading?!?</tab-heading>\n        That's right.\n      </tab>\n    </tabset>\n  </file>\n</example>\n */\n.directive('tab', ['$parse', function($parse) {\n  return {\n    require: '^tabset',\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/tabs/tab.html',\n    transclude: true,\n    scope: {\n      active: '=?',\n      heading: '@',\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab's content into the dom\n      onDeselect: '&deselect'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being 'under' a tab\n    },\n    compile: function(elm, attrs, transclude) {\n      return function postLink(scope, elm, attrs, tabsetCtrl) {\n        scope.$watch('active', function(active) {\n          if (active) {\n            tabsetCtrl.select(scope);\n          }\n        });\n\n        scope.disabled = false;\n        if ( attrs.disabled ) {\n          scope.$parent.$watch($parse(attrs.disabled), function(value) {\n            scope.disabled = !! value;\n          });\n        }\n\n        scope.select = function() {\n          if ( !scope.disabled ) {\n            scope.active = true;\n          }\n        };\n\n        tabsetCtrl.addTab(scope);\n        scope.$on('$destroy', function() {\n          tabsetCtrl.removeTab(scope);\n        });\n\n        //We need to transclude later, once the content container is ready.\n        //when this link happens, we're inside a tab heading.\n        scope.$transcludeFn = transclude;\n      };\n    }\n  };\n}])\n\n.directive('tabHeadingTransclude', [function() {\n  return {\n    restrict: 'A',\n    require: '^tab',\n    link: function(scope, elm, attrs, tabCtrl) {\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html('');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n}])\n\n.directive('tabContentTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^tabset',\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.tabContentTransclude);\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude 'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n  function isTabHeading(node) {\n    return node.tagName &&  (\n      node.hasAttribute('tab-heading') ||\n      node.hasAttribute('data-tab-heading') ||\n      node.tagName.toLowerCase() === 'tab-heading' ||\n      node.tagName.toLowerCase() === 'data-tab-heading'\n    );\n  }\n})\n\n;\n\nangular.module('ui.bootstrap.timepicker', [])\n\n.constant('timepickerConfig', {\n  hourStep: 1,\n  minuteStep: 1,\n  showMeridian: true,\n  meridians: null,\n  readonlyInput: false,\n  mousewheel: true\n})\n\n.controller('TimepickerController', ['$scope', '$attrs', '$parse', '$log', '$locale', 'timepickerConfig', function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {\n  var selected = new Date(),\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\n  this.init = function( ngModelCtrl_, inputs ) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    var hoursInputEl = inputs.eq(0),\n        minutesInputEl = inputs.eq(1);\n\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n    if ( mousewheel ) {\n      this.setupMousewheelEvents( hoursInputEl, minutesInputEl );\n    }\n\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n    this.setupInputEvents( hoursInputEl, minutesInputEl );\n  };\n\n  var hourStep = timepickerConfig.hourStep;\n  if ($attrs.hourStep) {\n    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n      hourStep = parseInt(value, 10);\n    });\n  }\n\n  var minuteStep = timepickerConfig.minuteStep;\n  if ($attrs.minuteStep) {\n    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n      minuteStep = parseInt(value, 10);\n    });\n  }\n\n  // 12H / 24H mode\n  $scope.showMeridian = timepickerConfig.showMeridian;\n  if ($attrs.showMeridian) {\n    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n      $scope.showMeridian = !!value;\n\n      if ( ngModelCtrl.$error.time ) {\n        // Evaluate from template\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n        if (angular.isDefined( hours ) && angular.isDefined( minutes )) {\n          selected.setHours( hours );\n          refresh();\n        }\n      } else {\n        updateTemplate();\n      }\n    });\n  }\n\n  // Get $scope.hours in 24H mode if valid\n  function getHoursFromTemplate ( ) {\n    var hours = parseInt( $scope.hours, 10 );\n    var valid = ( $scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n    if ( !valid ) {\n      return undefined;\n    }\n\n    if ( $scope.showMeridian ) {\n      if ( hours === 12 ) {\n        hours = 0;\n      }\n      if ( $scope.meridian === meridians[1] ) {\n        hours = hours + 12;\n      }\n    }\n    return hours;\n  }\n\n  function getMinutesFromTemplate() {\n    var minutes = parseInt($scope.minutes, 10);\n    return ( minutes >= 0 && minutes < 60 ) ? minutes : undefined;\n  }\n\n  function pad( value ) {\n    return ( angular.isDefined(value) && value.toString().length < 2 ) ? '0' + value : value;\n  }\n\n  // Respond on mousewheel spin\n  this.setupMousewheelEvents = function( hoursInputEl, minutesInputEl ) {\n    var isScrollingUp = function(e) {\n      if (e.originalEvent) {\n        e = e.originalEvent;\n      }\n      //pick correct delta variable depending on event\n      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n      return (e.detail || delta > 0);\n    };\n\n    hoursInputEl.bind('mousewheel wheel', function(e) {\n      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementHours() : $scope.decrementHours() );\n      e.preventDefault();\n    });\n\n    minutesInputEl.bind('mousewheel wheel', function(e) {\n      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementMinutes() : $scope.decrementMinutes() );\n      e.preventDefault();\n    });\n\n  };\n\n  this.setupInputEvents = function( hoursInputEl, minutesInputEl ) {\n    if ( $scope.readonlyInput ) {\n      $scope.updateHours = angular.noop;\n      $scope.updateMinutes = angular.noop;\n      return;\n    }\n\n    var invalidate = function(invalidHours, invalidMinutes) {\n      ngModelCtrl.$setViewValue( null );\n      ngModelCtrl.$setValidity('time', false);\n      if (angular.isDefined(invalidHours)) {\n        $scope.invalidHours = invalidHours;\n      }\n      if (angular.isDefined(invalidMinutes)) {\n        $scope.invalidMinutes = invalidMinutes;\n      }\n    };\n\n    $scope.updateHours = function() {\n      var hours = getHoursFromTemplate();\n\n      if ( angular.isDefined(hours) ) {\n        selected.setHours( hours );\n        refresh( 'h' );\n      } else {\n        invalidate(true);\n      }\n    };\n\n    hoursInputEl.bind('blur', function(e) {\n      if ( !$scope.invalidHours && $scope.hours < 10) {\n        $scope.$apply( function() {\n          $scope.hours = pad( $scope.hours );\n        });\n      }\n    });\n\n    $scope.updateMinutes = function() {\n      var minutes = getMinutesFromTemplate();\n\n      if ( angular.isDefined(minutes) ) {\n        selected.setMinutes( minutes );\n        refresh( 'm' );\n      } else {\n        invalidate(undefined, true);\n      }\n    };\n\n    minutesInputEl.bind('blur', function(e) {\n      if ( !$scope.invalidMinutes && $scope.minutes < 10 ) {\n        $scope.$apply( function() {\n          $scope.minutes = pad( $scope.minutes );\n        });\n      }\n    });\n\n  };\n\n  this.render = function() {\n    var date = ngModelCtrl.$modelValue ? new Date( ngModelCtrl.$modelValue ) : null;\n\n    if ( isNaN(date) ) {\n      ngModelCtrl.$setValidity('time', false);\n      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n    } else {\n      if ( date ) {\n        selected = date;\n      }\n      makeValid();\n      updateTemplate();\n    }\n  };\n\n  // Call internally when we know that model is valid.\n  function refresh( keyboardChange ) {\n    makeValid();\n    ngModelCtrl.$setViewValue( new Date(selected) );\n    updateTemplate( keyboardChange );\n  }\n\n  function makeValid() {\n    ngModelCtrl.$setValidity('time', true);\n    $scope.invalidHours = false;\n    $scope.invalidMinutes = false;\n  }\n\n  function updateTemplate( keyboardChange ) {\n    var hours = selected.getHours(), minutes = selected.getMinutes();\n\n    if ( $scope.showMeridian ) {\n      hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system\n    }\n\n    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n    $scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);\n    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n  }\n\n  function addMinutes( minutes ) {\n    var dt = new Date( selected.getTime() + minutes * 60000 );\n    selected.setHours( dt.getHours(), dt.getMinutes() );\n    refresh();\n  }\n\n  $scope.incrementHours = function() {\n    addMinutes( hourStep * 60 );\n  };\n  $scope.decrementHours = function() {\n    addMinutes( - hourStep * 60 );\n  };\n  $scope.incrementMinutes = function() {\n    addMinutes( minuteStep );\n  };\n  $scope.decrementMinutes = function() {\n    addMinutes( - minuteStep );\n  };\n  $scope.toggleMeridian = function() {\n    addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );\n  };\n}])\n\n.directive('timepicker', function () {\n  return {\n    restrict: 'EA',\n    require: ['timepicker', '?^ngModel'],\n    controller:'TimepickerController',\n    replace: true,\n    scope: {},\n    templateUrl: 'template/timepicker/timepicker.html',\n    link: function(scope, element, attrs, ctrls) {\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if ( ngModelCtrl ) {\n        timepickerCtrl.init( ngModelCtrl, element.find('input') );\n      }\n    }\n  };\n});\n\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('typeaheadParser', ['$parse', function ($parse) {\n\n  //                      00000111000000000000022200000000000000003333333333333330000000000044000\n  var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n\n  return {\n    parse:function (input) {\n\n      var match = input.match(TYPEAHEAD_REGEXP);\n      if (!match) {\n        throw new Error(\n          'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n            ' but got \"' + input + '\".');\n      }\n\n      return {\n        itemName:match[3],\n        source:$parse(match[4]),\n        viewMapper:$parse(match[2] || match[1]),\n        modelMapper:$parse(match[1])\n      };\n    }\n  };\n}])\n\n  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',\n    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {\n\n  var HOT_KEYS = [9, 13, 27, 38, 40];\n\n  return {\n    require:'ngModel',\n    link:function (originalScope, element, attrs, modelCtrl) {\n\n      //SUPPORTED ATTRIBUTES (OPTIONS)\n\n      //minimal no of characters that needs to be entered before typeahead kicks-in\n      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;\n\n      //minimal wait time after last character typed before typehead kicks-in\n      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n      //should it restrict model values to the ones selected from the popup only?\n      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n      //binding to a variable that indicates if matches are being retrieved asynchronously\n      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n      //a callback executed when a match is selected\n      var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n      var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n      //INTERNAL VARIABLES\n\n      //model setter executed upon match selection\n      var $setModelValue = $parse(attrs.ngModel).assign;\n\n      //expressions used by typeahead\n      var parserResult = typeaheadParser.parse(attrs.typeahead);\n\n      var hasFocus;\n\n      //create a child scope for the typeahead directive so we are not polluting original scope\n      //with typeahead-specific data (matches, query etc.)\n      var scope = originalScope.$new();\n      originalScope.$on('$destroy', function(){\n        scope.$destroy();\n      });\n\n      // WAI-ARIA\n      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n      element.attr({\n        'aria-autocomplete': 'list',\n        'aria-expanded': false,\n        'aria-owns': popupId\n      });\n\n      //pop-up element used to display matches\n      var popUpEl = angular.element('<div typeahead-popup></div>');\n      popUpEl.attr({\n        id: popupId,\n        matches: 'matches',\n        active: 'activeIdx',\n        select: 'select(activeIdx)',\n        query: 'query',\n        position: 'position'\n      });\n      //custom item template\n      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n      }\n\n      var resetMatches = function() {\n        scope.matches = [];\n        scope.activeIdx = -1;\n        element.attr('aria-expanded', false);\n      };\n\n      var getMatchId = function(index) {\n        return popupId + '-option-' + index;\n      };\n\n      // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n      // This attribute is added or removed automatically when the `activeIdx` changes.\n      scope.$watch('activeIdx', function(index) {\n        if (index < 0) {\n          element.removeAttr('aria-activedescendant');\n        } else {\n          element.attr('aria-activedescendant', getMatchId(index));\n        }\n      });\n\n      var getMatchesAsync = function(inputValue) {\n\n        var locals = {$viewValue: inputValue};\n        isLoadingSetter(originalScope, true);\n        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\n          //it might happen that several async queries were in progress if a user were typing fast\n          //but we are interested only in responses that correspond to the current view value\n          var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n          if (onCurrentRequest && hasFocus) {\n            if (matches.length > 0) {\n\n              scope.activeIdx = 0;\n              scope.matches.length = 0;\n\n              //transform labels\n              for(var i=0; i<matches.length; i++) {\n                locals[parserResult.itemName] = matches[i];\n                scope.matches.push({\n                  id: getMatchId(i),\n                  label: parserResult.viewMapper(scope, locals),\n                  model: matches[i]\n                });\n              }\n\n              scope.query = inputValue;\n              //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n              //due to other elements being rendered\n              scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n              scope.position.top = scope.position.top + element.prop('offsetHeight');\n\n              element.attr('aria-expanded', true);\n            } else {\n              resetMatches();\n            }\n          }\n          if (onCurrentRequest) {\n            isLoadingSetter(originalScope, false);\n          }\n        }, function(){\n          resetMatches();\n          isLoadingSetter(originalScope, false);\n        });\n      };\n\n      resetMatches();\n\n      //we need to propagate user's query so we can higlight matches\n      scope.query = undefined;\n\n      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later \n      var timeoutPromise;\n\n      var scheduleSearchWithTimeout = function(inputValue) {\n        timeoutPromise = $timeout(function () {\n          getMatchesAsync(inputValue);\n        }, waitTime);\n      };\n\n      var cancelPreviousTimeout = function() {\n        if (timeoutPromise) {\n          $timeout.cancel(timeoutPromise);\n        }\n      };\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function (inputValue) {\n\n        hasFocus = true;\n\n        if (inputValue && inputValue.length >= minSearch) {\n          if (waitTime > 0) {\n            cancelPreviousTimeout();\n            scheduleSearchWithTimeout(inputValue);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          cancelPreviousTimeout();\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        } else {\n          if (!inputValue) {\n            // Reset in case user had typed something previously.\n            modelCtrl.$setValidity('editable', true);\n            return inputValue;\n          } else {\n            modelCtrl.$setValidity('editable', false);\n            return undefined;\n          }\n        }\n      });\n\n      modelCtrl.$formatters.push(function (modelValue) {\n\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        if (inputFormatter) {\n\n          locals['$model'] = modelValue;\n          return inputFormatter(originalScope, locals);\n\n        } else {\n\n          //it might happen that we don't have enough info to properly render input value\n          //we need to check for this situation and simply return model value if we can't apply custom formatting\n          locals[parserResult.itemName] = modelValue;\n          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n          locals[parserResult.itemName] = undefined;\n          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;\n        }\n      });\n\n      scope.select = function (activeIdx) {\n        //called from within the $digest() cycle\n        var locals = {};\n        var model, item;\n\n        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n        model = parserResult.modelMapper(originalScope, locals);\n        $setModelValue(originalScope, model);\n        modelCtrl.$setValidity('editable', true);\n\n        onSelectCallback(originalScope, {\n          $item: item,\n          $model: model,\n          $label: parserResult.viewMapper(originalScope, locals)\n        });\n\n        resetMatches();\n\n        //return focus to the input element if a match was selected via a mouse click event\n        // use timeout to avoid $rootScope:inprog error\n        $timeout(function() { element[0].focus(); }, 0, false);\n      };\n\n      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n      element.bind('keydown', function (evt) {\n\n        //typeahead is open and an \"interesting\" key was pressed\n        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n          return;\n        }\n\n        evt.preventDefault();\n\n        if (evt.which === 40) {\n          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n          scope.$digest();\n\n        } else if (evt.which === 38) {\n          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;\n          scope.$digest();\n\n        } else if (evt.which === 13 || evt.which === 9) {\n          scope.$apply(function () {\n            scope.select(scope.activeIdx);\n          });\n\n        } else if (evt.which === 27) {\n          evt.stopPropagation();\n\n          resetMatches();\n          scope.$digest();\n        }\n      });\n\n      element.bind('blur', function (evt) {\n        hasFocus = false;\n      });\n\n      // Keep reference to click handler to unbind it.\n      var dismissClickHandler = function (evt) {\n        if (element[0] !== evt.target) {\n          resetMatches();\n          scope.$digest();\n        }\n      };\n\n      $document.bind('click', dismissClickHandler);\n\n      originalScope.$on('$destroy', function(){\n        $document.unbind('click', dismissClickHandler);\n      });\n\n      var $popup = $compile(popUpEl)(scope);\n      if ( appendToBody ) {\n        $document.find('body').append($popup);\n      } else {\n        element.after($popup);\n      }\n    }\n  };\n\n}])\n\n  .directive('typeaheadPopup', function () {\n    return {\n      restrict:'EA',\n      scope:{\n        matches:'=',\n        query:'=',\n        active:'=',\n        position:'=',\n        select:'&'\n      },\n      replace:true,\n      templateUrl:'template/typeahead/typeahead-popup.html',\n      link:function (scope, element, attrs) {\n\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function () {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function (matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function (matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function (activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  })\n\n  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {\n    return {\n      restrict:'EA',\n      scope:{\n        index:'=',\n        match:'=',\n        query:'='\n      },\n      link:function (scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n        $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent){\n           element.replaceWith($compile(tplContent.trim())(scope));\n        });\n      }\n    };\n  }])\n\n  .filter('typeaheadHighlight', function() {\n\n    function escapeRegexp(queryToEscape) {\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    return function(matchItem, query) {\n      return query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;\n    };\n  });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/angular-bootstrap/ui-bootstrap.js\n ** module id = 1\n ** module chunks = 0\n **/","/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 0.11.2 - 2014-09-26\n * License: MIT\n */\nangular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.transition\",\"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.bindHtml\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.modal\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\nangular.module(\"ui.bootstrap.tpls\", [\"template/accordion/accordion-group.html\",\"template/accordion/accordion.html\",\"template/alert/alert.html\",\"template/carousel/carousel.html\",\"template/carousel/slide.html\",\"template/datepicker/datepicker.html\",\"template/datepicker/day.html\",\"template/datepicker/month.html\",\"template/datepicker/popup.html\",\"template/datepicker/year.html\",\"template/modal/backdrop.html\",\"template/modal/window.html\",\"template/pagination/pager.html\",\"template/pagination/pagination.html\",\"template/tooltip/tooltip-html-unsafe-popup.html\",\"template/tooltip/tooltip-popup.html\",\"template/popover/popover.html\",\"template/progressbar/bar.html\",\"template/progressbar/progress.html\",\"template/progressbar/progressbar.html\",\"template/rating/rating.html\",\"template/tabs/tab.html\",\"template/tabs/tabset.html\",\"template/timepicker/timepicker.html\",\"template/typeahead/typeahead-match.html\",\"template/typeahead/typeahead-popup.html\"]);\nangular.module('ui.bootstrap.transition', [])\n\n/**\n * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.\n * @param  {DOMElement} element  The DOMElement that will be animated.\n * @param  {string|object|function} trigger  The thing that will cause the transition to start:\n *   - As a string, it represents the css class to be added to the element.\n *   - As an object, it represents a hash of style attributes to be applied to the element.\n *   - As a function, it represents a function to be called that will cause the transition to occur.\n * @return {Promise}  A promise that is resolved when the transition finishes.\n */\n.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {\n\n  var $transition = function(element, trigger, options) {\n    options = options || {};\n    var deferred = $q.defer();\n    var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];\n\n    var transitionEndHandler = function(event) {\n      $rootScope.$apply(function() {\n        element.unbind(endEventName, transitionEndHandler);\n        deferred.resolve(element);\n      });\n    };\n\n    if (endEventName) {\n      element.bind(endEventName, transitionEndHandler);\n    }\n\n    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur\n    $timeout(function() {\n      if ( angular.isString(trigger) ) {\n        element.addClass(trigger);\n      } else if ( angular.isFunction(trigger) ) {\n        trigger(element);\n      } else if ( angular.isObject(trigger) ) {\n        element.css(trigger);\n      }\n      //If browser does not support transitions, instantly resolve\n      if ( !endEventName ) {\n        deferred.resolve(element);\n      }\n    });\n\n    // Add our custom cancel function to the promise that is returned\n    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,\n    // i.e. it will therefore never raise a transitionEnd event for that transition\n    deferred.promise.cancel = function() {\n      if ( endEventName ) {\n        element.unbind(endEventName, transitionEndHandler);\n      }\n      deferred.reject('Transition cancelled');\n    };\n\n    return deferred.promise;\n  };\n\n  // Work out the name of the transitionEnd event\n  var transElement = document.createElement('trans');\n  var transitionEndEventNames = {\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'transitionend',\n    'OTransition': 'oTransitionEnd',\n    'transition': 'transitionend'\n  };\n  var animationEndEventNames = {\n    'WebkitTransition': 'webkitAnimationEnd',\n    'MozTransition': 'animationend',\n    'OTransition': 'oAnimationEnd',\n    'transition': 'animationend'\n  };\n  function findEndEventName(endEventNames) {\n    for (var name in endEventNames){\n      if (transElement.style[name] !== undefined) {\n        return endEventNames[name];\n      }\n    }\n  }\n  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);\n  $transition.animationEndEventName = findEndEventName(animationEndEventNames);\n  return $transition;\n}]);\n\nangular.module('ui.bootstrap.collapse', ['ui.bootstrap.transition'])\n\n  .directive('collapse', ['$transition', function ($transition) {\n\n    return {\n      link: function (scope, element, attrs) {\n\n        var initialAnimSkip = true;\n        var currentTransition;\n\n        function doTransition(change) {\n          var newTransition = $transition(element, change);\n          if (currentTransition) {\n            currentTransition.cancel();\n          }\n          currentTransition = newTransition;\n          newTransition.then(newTransitionDone, newTransitionDone);\n          return newTransition;\n\n          function newTransitionDone() {\n            // Make sure it's this transition, otherwise, leave it alone.\n            if (currentTransition === newTransition) {\n              currentTransition = undefined;\n            }\n          }\n        }\n\n        function expand() {\n          if (initialAnimSkip) {\n            initialAnimSkip = false;\n            expandDone();\n          } else {\n            element.removeClass('collapse').addClass('collapsing');\n            doTransition({ height: element[0].scrollHeight + 'px' }).then(expandDone);\n          }\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing');\n          element.addClass('collapse in');\n          element.css({height: 'auto'});\n        }\n\n        function collapse() {\n          if (initialAnimSkip) {\n            initialAnimSkip = false;\n            collapseDone();\n            element.css({height: 0});\n          } else {\n            // CSS transitions don't work with height: auto, so we have to manually change the height to a specific value\n            element.css({ height: element[0].scrollHeight + 'px' });\n            //trigger reflow so a browser realizes that height was updated from auto to a specific value\n            var x = element[0].offsetWidth;\n\n            element.removeClass('collapse in').addClass('collapsing');\n\n            doTransition({ height: 0 }).then(collapseDone);\n          }\n        }\n\n        function collapseDone() {\n          element.removeClass('collapsing');\n          element.addClass('collapse');\n        }\n\n        scope.$watch(attrs.collapse, function (shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\n.constant('accordionConfig', {\n  closeOthers: true\n})\n\n.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {\n\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if ( closeOthers ) {\n      angular.forEach(this.groups, function (group) {\n        if ( group !== openGroup ) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n\n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on('$destroy', function (event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if ( index !== -1 ) {\n      this.groups.splice(index, 1);\n    }\n  };\n\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive('accordion', function () {\n  return {\n    restrict:'EA',\n    controller:'AccordionController',\n    transclude: true,\n    replace: false,\n    templateUrl: 'template/accordion/accordion.html'\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive('accordionGroup', function() {\n  return {\n    require:'^accordion',         // We need this directive to be inside an accordion\n    restrict:'EA',\n    transclude:true,              // It transcludes the contents of the directive into the template\n    replace: true,                // The element containing the directive will be replaced with the template\n    templateUrl:'template/accordion/accordion-group.html',\n    scope: {\n      heading: '@',               // Interpolate the heading attribute onto this scope\n      isOpen: '=?',\n      isDisabled: '=?'\n    },\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      accordionCtrl.addGroup(scope);\n\n      scope.$watch('isOpen', function(value) {\n        if ( value ) {\n          accordionCtrl.closeOthers(scope);\n        }\n      });\n\n      scope.toggleOpen = function() {\n        if ( !scope.isDisabled ) {\n          scope.isOpen = !scope.isOpen;\n        }\n      };\n    }\n  };\n})\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n// <accordion-group>\n//   <accordion-heading>Heading containing HTML - <img src=\"...\"></accordion-heading>\n// </accordion-group>\n.directive('accordionHeading', function() {\n  return {\n    restrict: 'EA',\n    transclude: true,   // Grab the contents to be used as the heading\n    template: '',       // In effect remove this element!\n    replace: true,\n    require: '^accordionGroup',\n    link: function(scope, element, attr, accordionGroupCtrl, transclude) {\n      // Pass the heading to the accordion-group controller\n      // so that it can be transcluded into the right place in the template\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n      accordionGroupCtrl.setHeading(transclude(scope, function() {}));\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n// <div class=\"accordion-group\">\n//   <div class=\"accordion-heading\" ><a ... accordion-transclude=\"heading\">...</a></div>\n//   ...\n// </div>\n.directive('accordionTransclude', function() {\n  return {\n    require: '^accordionGroup',\n    link: function(scope, element, attr, controller) {\n      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n        if ( heading ) {\n          element.html('');\n          element.append(heading);\n        }\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.alert', [])\n\n.controller('AlertController', ['$scope', '$attrs', function ($scope, $attrs) {\n  $scope.closeable = 'close' in $attrs;\n}])\n\n.directive('alert', function () {\n  return {\n    restrict:'EA',\n    controller:'AlertController',\n    templateUrl:'template/alert/alert.html',\n    transclude:true,\n    replace:true,\n    scope: {\n      type: '@',\n      close: '&'\n    }\n  };\n});\n\nangular.module('ui.bootstrap.bindHtml', [])\n\n  .directive('bindHtmlUnsafe', function () {\n    return function (scope, element, attr) {\n      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);\n      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {\n        element.html(value || '');\n      });\n    };\n  });\nangular.module('ui.bootstrap.buttons', [])\n\n.constant('buttonConfig', {\n  activeClass: 'active',\n  toggleEvent: 'click'\n})\n\n.controller('ButtonsController', ['buttonConfig', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass || 'active';\n  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n}])\n\n.directive('btnRadio', function () {\n  return {\n    require: ['btnRadio', 'ngModel'],\n    controller: 'ButtonsController',\n    link: function (scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      //model -> UI\n      ngModelCtrl.$render = function () {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n      };\n\n      //ui->model\n      element.bind(buttonsCtrl.toggleEvent, function () {\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n          scope.$apply(function () {\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n    }\n  };\n})\n\n.directive('btnCheckbox', function () {\n  return {\n    require: ['btnCheckbox', 'ngModel'],\n    controller: 'ButtonsController',\n    link: function (scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n\n      function getCheckboxValue(attributeValue, defaultValue) {\n        var val = scope.$eval(attributeValue);\n        return angular.isDefined(val) ? val : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function () {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.bind(buttonsCtrl.toggleEvent, function () {\n        scope.$apply(function () {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\n/**\n* @ngdoc overview\n* @name ui.bootstrap.carousel\n*\n* @description\n* AngularJS version of an image carousel.\n*\n*/\nangular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition'])\n.controller('CarouselController', ['$scope', '$timeout', '$transition', function ($scope, $timeout, $transition) {\n  var self = this,\n    slides = self.slides = $scope.slides = [],\n    currentIndex = -1,\n    currentTimeout, isPlaying;\n  self.currentSlide = null;\n\n  var destroyed = false;\n  /* direction: \"prev\" or \"next\" */\n  self.select = $scope.select = function(nextSlide, direction) {\n    var nextIndex = slides.indexOf(nextSlide);\n    //Decide direction if it's not given\n    if (direction === undefined) {\n      direction = nextIndex > currentIndex ? 'next' : 'prev';\n    }\n    if (nextSlide && nextSlide !== self.currentSlide) {\n      if ($scope.$currentTransition) {\n        $scope.$currentTransition.cancel();\n        //Timeout so ng-class in template has time to fix classes for finished slide\n        $timeout(goNext);\n      } else {\n        goNext();\n      }\n    }\n    function goNext() {\n      // Scope has been destroyed, stop here.\n      if (destroyed) { return; }\n      //If we have a slide to transition from and we have a transition type and we're allowed, go\n      if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {\n        //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime\n        nextSlide.$element.addClass(direction);\n        var reflow = nextSlide.$element[0].offsetWidth; //force reflow\n\n        //Set all other slides to stop doing their stuff for the new transition\n        angular.forEach(slides, function(slide) {\n          angular.extend(slide, {direction: '', entering: false, leaving: false, active: false});\n        });\n        angular.extend(nextSlide, {direction: direction, active: true, entering: true});\n        angular.extend(self.currentSlide||{}, {direction: direction, leaving: true});\n\n        $scope.$currentTransition = $transition(nextSlide.$element, {});\n        //We have to create new pointers inside a closure since next & current will change\n        (function(next,current) {\n          $scope.$currentTransition.then(\n            function(){ transitionDone(next, current); },\n            function(){ transitionDone(next, current); }\n          );\n        }(nextSlide, self.currentSlide));\n      } else {\n        transitionDone(nextSlide, self.currentSlide);\n      }\n      self.currentSlide = nextSlide;\n      currentIndex = nextIndex;\n      //every time you change slides, reset the timer\n      restartTimer();\n    }\n    function transitionDone(next, current) {\n      angular.extend(next, {direction: '', active: true, leaving: false, entering: false});\n      angular.extend(current||{}, {direction: '', active: false, leaving: false, entering: false});\n      $scope.$currentTransition = null;\n    }\n  };\n  $scope.$on('$destroy', function () {\n    destroyed = true;\n  });\n\n  /* Allow outside people to call indexOf on slides array */\n  self.indexOfSlide = function(slide) {\n    return slides.indexOf(slide);\n  };\n\n  $scope.next = function() {\n    var newIndex = (currentIndex + 1) % slides.length;\n\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (!$scope.$currentTransition) {\n      return self.select(slides[newIndex], 'next');\n    }\n  };\n\n  $scope.prev = function() {\n    var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;\n\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (!$scope.$currentTransition) {\n      return self.select(slides[newIndex], 'prev');\n    }\n  };\n\n  $scope.isActive = function(slide) {\n     return self.currentSlide === slide;\n  };\n\n  $scope.$watch('interval', restartTimer);\n  $scope.$on('$destroy', resetTimer);\n\n  function restartTimer() {\n    resetTimer();\n    var interval = +$scope.interval;\n    if (!isNaN(interval) && interval>=0) {\n      currentTimeout = $timeout(timerFn, interval);\n    }\n  }\n\n  function resetTimer() {\n    if (currentTimeout) {\n      $timeout.cancel(currentTimeout);\n      currentTimeout = null;\n    }\n  }\n\n  function timerFn() {\n    if (isPlaying) {\n      $scope.next();\n      restartTimer();\n    } else {\n      $scope.pause();\n    }\n  }\n\n  $scope.play = function() {\n    if (!isPlaying) {\n      isPlaying = true;\n      restartTimer();\n    }\n  };\n  $scope.pause = function() {\n    if (!$scope.noPause) {\n      isPlaying = false;\n      resetTimer();\n    }\n  };\n\n  self.addSlide = function(slide, element) {\n    slide.$element = element;\n    slides.push(slide);\n    //if this is the first slide or the slide is set to active, select it\n    if(slides.length === 1 || slide.active) {\n      self.select(slides[slides.length-1]);\n      if (slides.length == 1) {\n        $scope.play();\n      }\n    } else {\n      slide.active = false;\n    }\n  };\n\n  self.removeSlide = function(slide) {\n    //get the index of the slide inside the carousel\n    var index = slides.indexOf(slide);\n    slides.splice(index, 1);\n    if (slides.length > 0 && slide.active) {\n      if (index >= slides.length) {\n        self.select(slides[index-1]);\n      } else {\n        self.select(slides[index]);\n      }\n    } else if (currentIndex > index) {\n      currentIndex--;\n    }\n  };\n\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:carousel\n * @restrict EA\n *\n * @description\n * Carousel is the outer container for a set of image 'slides' to showcase.\n *\n * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\n * @param {boolean=} noTransition Whether to disable transitions on the carousel.\n * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <carousel>\n      <slide>\n        <img src=\"http://placekitten.com/150/150\" style=\"margin:auto;\">\n        <div class=\"carousel-caption\">\n          <p>Beautiful!</p>\n        </div>\n      </slide>\n      <slide>\n        <img src=\"http://placekitten.com/100/150\" style=\"margin:auto;\">\n        <div class=\"carousel-caption\">\n          <p>D'aww!</p>\n        </div>\n      </slide>\n    </carousel>\n  </file>\n  <file name=\"demo.css\">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n */\n.directive('carousel', [function() {\n  return {\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    controller: 'CarouselController',\n    require: 'carousel',\n    templateUrl: 'template/carousel/carousel.html',\n    scope: {\n      interval: '=',\n      noTransition: '=',\n      noPause: '='\n    }\n  };\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:slide\n * @restrict EA\n *\n * @description\n * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\n *\n * @param {boolean=} active Model binding, whether or not this slide is currently active.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n<div ng-controller=\"CarouselDemoCtrl\">\n  <carousel>\n    <slide ng-repeat=\"slide in slides\" active=\"slide.active\">\n      <img ng-src=\"{{slide.image}}\" style=\"margin:auto;\">\n      <div class=\"carousel-caption\">\n        <h4>Slide {{$index}}</h4>\n        <p>{{slide.text}}</p>\n      </div>\n    </slide>\n  </carousel>\n  Interval, in milliseconds: <input type=\"number\" ng-model=\"myInterval\">\n  <br />Enter a negative number to stop the interval.\n</div>\n  </file>\n  <file name=\"script.js\">\nfunction CarouselDemoCtrl($scope) {\n  $scope.myInterval = 5000;\n}\n  </file>\n  <file name=\"demo.css\">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n*/\n\n.directive('slide', function() {\n  return {\n    require: '^carousel',\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    templateUrl: 'template/carousel/slide.html',\n    scope: {\n      active: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch('active', function(active) {\n        if (active) {\n          carouselCtrl.select(scope);\n        }\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.dateparser', [])\n\n.service('dateParser', ['$locale', 'orderByFilter', function($locale, orderByFilter) {\n\n  this.parsers = {};\n\n  var formatCodeToRegex = {\n    'yyyy': {\n      regex: '\\\\d{4}',\n      apply: function(value) { this.year = +value; }\n    },\n    'yy': {\n      regex: '\\\\d{2}',\n      apply: function(value) { this.year = +value + 2000; }\n    },\n    'y': {\n      regex: '\\\\d{1,4}',\n      apply: function(value) { this.year = +value; }\n    },\n    'MMMM': {\n      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }\n    },\n    'MMM': {\n      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }\n    },\n    'MM': {\n      regex: '0[1-9]|1[0-2]',\n      apply: function(value) { this.month = value - 1; }\n    },\n    'M': {\n      regex: '[1-9]|1[0-2]',\n      apply: function(value) { this.month = value - 1; }\n    },\n    'dd': {\n      regex: '[0-2][0-9]{1}|3[0-1]{1}',\n      apply: function(value) { this.date = +value; }\n    },\n    'd': {\n      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n      apply: function(value) { this.date = +value; }\n    },\n    'EEEE': {\n      regex: $locale.DATETIME_FORMATS.DAY.join('|')\n    },\n    'EEE': {\n      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')\n    }\n  };\n\n  function createParser(format) {\n    var map = [], regex = format.split('');\n\n    angular.forEach(formatCodeToRegex, function(data, code) {\n      var index = format.indexOf(code);\n\n      if (index > -1) {\n        format = format.split('');\n\n        regex[index] = '(' + data.regex + ')';\n        format[index] = '$'; // Custom symbol to define consumed part of format\n        for (var i = index + 1, n = index + code.length; i < n; i++) {\n          regex[i] = '';\n          format[i] = '$';\n        }\n        format = format.join('');\n\n        map.push({ index: index, apply: data.apply });\n      }\n    });\n\n    return {\n      regex: new RegExp('^' + regex.join('') + '$'),\n      map: orderByFilter(map, 'index')\n    };\n  }\n\n  this.parse = function(input, format) {\n    if ( !angular.isString(input) || !format ) {\n      return input;\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n\n    if ( !this.parsers[format] ) {\n      this.parsers[format] = createParser(format);\n    }\n\n    var parser = this.parsers[format],\n        regex = parser.regex,\n        map = parser.map,\n        results = input.match(regex);\n\n    if ( results && results.length ) {\n      var fields = { year: 1900, month: 0, date: 1, hours: 0 }, dt;\n\n      for( var i = 1, n = results.length; i < n; i++ ) {\n        var mapper = map[i-1];\n        if ( mapper.apply ) {\n          mapper.apply.call(fields, results[i]);\n        }\n      }\n\n      if ( isValid(fields.year, fields.month, fields.date) ) {\n        dt = new Date( fields.year, fields.month, fields.date, fields.hours);\n      }\n\n      return dt;\n    }\n  };\n\n  // Check if date is valid for specific month (and year for February).\n  // Month: 0 = Jan, 1 = Feb, etc\n  function isValid(year, month, date) {\n    if ( month === 1 && date > 28) {\n        return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n    }\n\n    if ( month === 3 || month === 5 || month === 8 || month === 10) {\n        return date < 31;\n    }\n\n    return true;\n  }\n}]);\n\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods that can be use to retrieve position of DOM elements.\n * It is meant to be used where we need to absolute-position DOM elements in\n * relation to other, existing elements (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$position', ['$document', '$window', function ($document, $window) {\n\n    function getStyle(el, cssprop) {\n      if (el.currentStyle) { //IE\n        return el.currentStyle[cssprop];\n      } else if ($window.getComputedStyle) {\n        return $window.getComputedStyle(el)[cssprop];\n      }\n      // finally try and get inline style\n      return el.style[cssprop];\n    }\n\n    /**\n     * Checks if a given element is statically positioned\n     * @param element - raw DOM element\n     */\n    function isStaticPositioned(element) {\n      return (getStyle(element, 'position') || 'static' ) === 'static';\n    }\n\n    /**\n     * returns the closest, non-statically positioned parentOffset of a given element\n     * @param element\n     */\n    var parentOffsetEl = function (element) {\n      var docDomEl = $document[0];\n      var offsetParent = element.offsetParent || docDomEl;\n      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docDomEl;\n    };\n\n    return {\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/\n       */\n      position: function (element) {\n        var elBCR = this.offset(element);\n        var offsetParentBCR = { top: 0, left: 0 };\n        var offsetParentEl = parentOffsetEl(element[0]);\n        if (offsetParentEl != $document[0]) {\n          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n        }\n\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: elBCR.top - offsetParentBCR.top,\n          left: elBCR.left - offsetParentBCR.left\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/\n       */\n      offset: function (element) {\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n        };\n      },\n\n      /**\n       * Provides coordinates for the targetEl in relation to hostEl\n       */\n      positionElements: function (hostEl, targetEl, positionStr, appendToBody) {\n\n        var positionStrParts = positionStr.split('-');\n        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\n        var hostElPos,\n          targetElWidth,\n          targetElHeight,\n          targetElPos;\n\n        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\n        targetElWidth = targetEl.prop('offsetWidth');\n        targetElHeight = targetEl.prop('offsetHeight');\n\n        var shiftWidth = {\n          center: function () {\n            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n          },\n          left: function () {\n            return hostElPos.left;\n          },\n          right: function () {\n            return hostElPos.left + hostElPos.width;\n          }\n        };\n\n        var shiftHeight = {\n          center: function () {\n            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n          },\n          top: function () {\n            return hostElPos.top;\n          },\n          bottom: function () {\n            return hostElPos.top + hostElPos.height;\n          }\n        };\n\n        switch (pos0) {\n          case 'right':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: shiftWidth[pos0]()\n            };\n            break;\n          case 'left':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: hostElPos.left - targetElWidth\n            };\n            break;\n          case 'bottom':\n            targetElPos = {\n              top: shiftHeight[pos0](),\n              left: shiftWidth[pos1]()\n            };\n            break;\n          default:\n            targetElPos = {\n              top: hostElPos.top - targetElHeight,\n              left: shiftWidth[pos1]()\n            };\n            break;\n        }\n\n        return targetElPos;\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])\n\n.constant('datepickerConfig', {\n  formatDay: 'dd',\n  formatMonth: 'MMMM',\n  formatYear: 'yyyy',\n  formatDayHeader: 'EEE',\n  formatDayTitle: 'MMMM yyyy',\n  formatMonthTitle: 'yyyy',\n  datepickerMode: 'day',\n  minMode: 'day',\n  maxMode: 'year',\n  showWeeks: true,\n  startingDay: 0,\n  yearRange: 20,\n  minDate: null,\n  maxDate: null\n})\n\n.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$timeout', '$log', 'dateFilter', 'datepickerConfig', function($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\n  // Modes chain\n  this.modes = ['day', 'month', 'year'];\n\n  // Configuration attributes\n  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n                   'minMode', 'maxMode', 'showWeeks', 'startingDay', 'yearRange'], function( key, index ) {\n    self[key] = angular.isDefined($attrs[key]) ? (index < 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n  });\n\n  // Watchable date attributes\n  angular.forEach(['minDate', 'maxDate'], function( key ) {\n    if ( $attrs[key] ) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = value ? new Date(value) : null;\n        self.refreshView();\n      });\n    } else {\n      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n    }\n  });\n\n  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n  this.activeDate = angular.isDefined($attrs.initDate) ? $scope.$parent.$eval($attrs.initDate) : new Date();\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function( ngModelCtrl_ ) {\n    ngModelCtrl = ngModelCtrl_;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if ( ngModelCtrl.$modelValue ) {\n      var date = new Date( ngModelCtrl.$modelValue ),\n          isValid = !isNaN(date);\n\n      if ( isValid ) {\n        this.activeDate = date;\n      } else {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n      }\n      ngModelCtrl.$setValidity('date', isValid);\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if ( this.element ) {\n      this._refreshView();\n\n      var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;\n      ngModelCtrl.$setValidity('date-disabled', !date || (this.element && !this.isDisabled(date)));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;\n    return {\n      date: date,\n      label: dateFilter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0\n    };\n  };\n\n  this.isDisabled = function( date ) {\n    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  $scope.select = function( date ) {\n    if ( $scope.datepickerMode === self.minMode ) {\n      var dt = ngModelCtrl.$modelValue ? new Date( ngModelCtrl.$modelValue ) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );\n      ngModelCtrl.$setViewValue( dt );\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) - 1 ];\n    }\n  };\n\n  $scope.move = function( direction ) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function( direction ) {\n    direction = direction || 1;\n\n    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n      return;\n    }\n\n    $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) + direction ];\n  };\n\n  // Key event mapper\n  $scope.keys = { 13:'enter', 32:'space', 33:'pageup', 34:'pagedown', 35:'end', 36:'home', 37:'left', 38:'up', 39:'right', 40:'down' };\n\n  var focusElement = function() {\n    $timeout(function() {\n      self.element[0].focus();\n    }, 0 , false);\n  };\n\n  // Listen for focus requests from popup directive\n  $scope.$on('datepicker.focus', focusElement);\n\n  $scope.keydown = function( evt ) {\n    var key = $scope.keys[evt.which];\n\n    if ( !key || evt.shiftKey || evt.altKey ) {\n      return;\n    }\n\n    evt.preventDefault();\n    evt.stopPropagation();\n\n    if (key === 'enter' || key === 'space') {\n      if ( self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n      focusElement();\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n      focusElement();\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n}])\n\n.directive( 'datepicker', function () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/datepicker/datepicker.html',\n    scope: {\n      datepickerMode: '=?',\n      dateDisabled: '&'\n    },\n    require: ['datepicker', '?^ngModel'],\n    controller: 'DatepickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if ( ngModelCtrl ) {\n        datepickerCtrl.init( ngModelCtrl );\n      }\n    }\n  };\n})\n\n.directive('daypicker', ['dateFilter', function (dateFilter) {\n  return {\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/datepicker/day.html',\n    require: '^datepicker',\n    link: function(scope, element, attrs, ctrl) {\n      scope.showWeeks = ctrl.showWeeks;\n\n      ctrl.step = { months: 1 };\n      ctrl.element = element;\n\n      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n      function getDaysInMonth( year, month ) {\n        return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];\n      }\n\n      function getDates(startDate, n) {\n        var dates = new Array(n), current = new Date(startDate), i = 0;\n        current.setHours(12); // Prevent repeated dates because of timezone bug\n        while ( i < n ) {\n          dates[i++] = new Date(current);\n          current.setDate( current.getDate() + 1 );\n        }\n        return dates;\n      }\n\n      ctrl._refreshView = function() {\n        var year = ctrl.activeDate.getFullYear(),\n          month = ctrl.activeDate.getMonth(),\n          firstDayOfMonth = new Date(year, month, 1),\n          difference = ctrl.startingDay - firstDayOfMonth.getDay(),\n          numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n          firstDate = new Date(firstDayOfMonth);\n\n        if ( numDisplayedFromPreviousMonth > 0 ) {\n          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );\n        }\n\n        // 42 is the number of days on a six-month calendar\n        var days = getDates(firstDate, 42);\n        for (var i = 0; i < 42; i ++) {\n          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {\n            secondary: days[i].getMonth() !== month,\n            uid: scope.uniqueId + '-' + i\n          });\n        }\n\n        scope.labels = new Array(7);\n        for (var j = 0; j < 7; j++) {\n          scope.labels[j] = {\n            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),\n            full: dateFilter(days[j].date, 'EEEE')\n          };\n        }\n\n        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);\n        scope.rows = ctrl.split(days, 7);\n\n        if ( scope.showWeeks ) {\n          scope.weekNumbers = [];\n          var weekNumber = getISO8601WeekNumber( scope.rows[0][0].date ),\n              numWeeks = scope.rows.length;\n          while( scope.weekNumbers.push(weekNumber++) < numWeeks ) {}\n        }\n      };\n\n      ctrl.compare = function(date1, date2) {\n        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );\n      };\n\n      function getISO8601WeekNumber(date) {\n        var checkDate = new Date(date);\n        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n        var time = checkDate.getTime();\n        checkDate.setMonth(0); // Compare with Jan 1\n        checkDate.setDate(1);\n        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n      }\n\n      ctrl.handleKeyDown = function( key, evt ) {\n        var date = ctrl.activeDate.getDate();\n\n        if (key === 'left') {\n          date = date - 1;   // up\n        } else if (key === 'up') {\n          date = date - 7;   // down\n        } else if (key === 'right') {\n          date = date + 1;   // down\n        } else if (key === 'down') {\n          date = date + 7;\n        } else if (key === 'pageup' || key === 'pagedown') {\n          var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n          ctrl.activeDate.setMonth(month, 1);\n          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);\n        } else if (key === 'home') {\n          date = 1;\n        } else if (key === 'end') {\n          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());\n        }\n        ctrl.activeDate.setDate(date);\n      };\n\n      ctrl.refreshView();\n    }\n  };\n}])\n\n.directive('monthpicker', ['dateFilter', function (dateFilter) {\n  return {\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/datepicker/month.html',\n    require: '^datepicker',\n    link: function(scope, element, attrs, ctrl) {\n      ctrl.step = { years: 1 };\n      ctrl.element = element;\n\n      ctrl._refreshView = function() {\n        var months = new Array(12),\n            year = ctrl.activeDate.getFullYear();\n\n        for ( var i = 0; i < 12; i++ ) {\n          months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {\n            uid: scope.uniqueId + '-' + i\n          });\n        }\n\n        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);\n        scope.rows = ctrl.split(months, 3);\n      };\n\n      ctrl.compare = function(date1, date2) {\n        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );\n      };\n\n      ctrl.handleKeyDown = function( key, evt ) {\n        var date = ctrl.activeDate.getMonth();\n\n        if (key === 'left') {\n          date = date - 1;   // up\n        } else if (key === 'up') {\n          date = date - 3;   // down\n        } else if (key === 'right') {\n          date = date + 1;   // down\n        } else if (key === 'down') {\n          date = date + 3;\n        } else if (key === 'pageup' || key === 'pagedown') {\n          var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n          ctrl.activeDate.setFullYear(year);\n        } else if (key === 'home') {\n          date = 0;\n        } else if (key === 'end') {\n          date = 11;\n        }\n        ctrl.activeDate.setMonth(date);\n      };\n\n      ctrl.refreshView();\n    }\n  };\n}])\n\n.directive('yearpicker', ['dateFilter', function (dateFilter) {\n  return {\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/datepicker/year.html',\n    require: '^datepicker',\n    link: function(scope, element, attrs, ctrl) {\n      var range = ctrl.yearRange;\n\n      ctrl.step = { years: range };\n      ctrl.element = element;\n\n      function getStartingYear( year ) {\n        return parseInt((year - 1) / range, 10) * range + 1;\n      }\n\n      ctrl._refreshView = function() {\n        var years = new Array(range);\n\n        for ( var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++ ) {\n          years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {\n            uid: scope.uniqueId + '-' + i\n          });\n        }\n\n        scope.title = [years[0].label, years[range - 1].label].join(' - ');\n        scope.rows = ctrl.split(years, 5);\n      };\n\n      ctrl.compare = function(date1, date2) {\n        return date1.getFullYear() - date2.getFullYear();\n      };\n\n      ctrl.handleKeyDown = function( key, evt ) {\n        var date = ctrl.activeDate.getFullYear();\n\n        if (key === 'left') {\n          date = date - 1;   // up\n        } else if (key === 'up') {\n          date = date - 5;   // down\n        } else if (key === 'right') {\n          date = date + 1;   // down\n        } else if (key === 'down') {\n          date = date + 5;\n        } else if (key === 'pageup' || key === 'pagedown') {\n          date += (key === 'pageup' ? - 1 : 1) * ctrl.step.years;\n        } else if (key === 'home') {\n          date = getStartingYear( ctrl.activeDate.getFullYear() );\n        } else if (key === 'end') {\n          date = getStartingYear( ctrl.activeDate.getFullYear() ) + range - 1;\n        }\n        ctrl.activeDate.setFullYear(date);\n      };\n\n      ctrl.refreshView();\n    }\n  };\n}])\n\n.constant('datepickerPopupConfig', {\n  datepickerPopup: 'yyyy-MM-dd',\n  currentText: 'Today',\n  clearText: 'Clear',\n  closeText: 'Done',\n  closeOnDateSelection: true,\n  appendToBody: false,\n  showButtonBar: true\n})\n\n.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig',\nfunction ($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {\n  return {\n    restrict: 'EA',\n    require: 'ngModel',\n    scope: {\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@',\n      dateDisabled: '&'\n    },\n    link: function(scope, element, attrs, ngModel) {\n      var dateFormat,\n          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,\n          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n\n      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\n      scope.getText = function( key ) {\n        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n      };\n\n      attrs.$observe('datepickerPopup', function(value) {\n          dateFormat = value || datepickerPopupConfig.datepickerPopup;\n          ngModel.$render();\n      });\n\n      // popup element used to display calendar\n      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');\n      popupEl.attr({\n        'ng-model': 'date',\n        'ng-change': 'dateSelection()'\n      });\n\n      function cameltoDash( string ){\n        return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n      }\n\n      // datepicker element\n      var datepickerEl = angular.element(popupEl.children()[0]);\n      if ( attrs.datepickerOptions ) {\n        angular.forEach(scope.$parent.$eval(attrs.datepickerOptions), function( value, option ) {\n          datepickerEl.attr( cameltoDash(option), value );\n        });\n      }\n\n      scope.watchData = {};\n      angular.forEach(['minDate', 'maxDate', 'datepickerMode'], function( key ) {\n        if ( attrs[key] ) {\n          var getAttribute = $parse(attrs[key]);\n          scope.$parent.$watch(getAttribute, function(value){\n            scope.watchData[key] = value;\n          });\n          datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\n          // Propagate changes from datepicker to outside\n          if ( key === 'datepickerMode' ) {\n            var setAttribute = getAttribute.assign;\n            scope.$watch('watchData.' + key, function(value, oldvalue) {\n              if ( value !== oldvalue ) {\n                setAttribute(scope.$parent, value);\n              }\n            });\n          }\n        }\n      });\n      if (attrs.dateDisabled) {\n        datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n      }\n\n      function parseDate(viewValue) {\n        if (!viewValue) {\n          ngModel.$setValidity('date', true);\n          return null;\n        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n          ngModel.$setValidity('date', true);\n          return viewValue;\n        } else if (angular.isString(viewValue)) {\n          var date = dateParser.parse(viewValue, dateFormat) || new Date(viewValue);\n          if (isNaN(date)) {\n            ngModel.$setValidity('date', false);\n            return undefined;\n          } else {\n            ngModel.$setValidity('date', true);\n            return date;\n          }\n        } else {\n          ngModel.$setValidity('date', false);\n          return undefined;\n        }\n      }\n      ngModel.$parsers.unshift(parseDate);\n\n      // Inner change\n      scope.dateSelection = function(dt) {\n        if (angular.isDefined(dt)) {\n          scope.date = dt;\n        }\n        ngModel.$setViewValue(scope.date);\n        ngModel.$render();\n\n        if ( closeOnDateSelection ) {\n          scope.isOpen = false;\n          element[0].focus();\n        }\n      };\n\n      element.bind('input change keyup', function() {\n        scope.$apply(function() {\n          scope.date = ngModel.$modelValue;\n        });\n      });\n\n      // Outter change\n      ngModel.$render = function() {\n        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';\n        element.val(date);\n        scope.date = parseDate( ngModel.$modelValue );\n      };\n\n      var documentClickBind = function(event) {\n        if (scope.isOpen && event.target !== element[0]) {\n          scope.$apply(function() {\n            scope.isOpen = false;\n          });\n        }\n      };\n\n      var keydown = function(evt, noApply) {\n        scope.keydown(evt);\n      };\n      element.bind('keydown', keydown);\n\n      scope.keydown = function(evt) {\n        if (evt.which === 27) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          scope.close();\n        } else if (evt.which === 40 && !scope.isOpen) {\n          scope.isOpen = true;\n        }\n      };\n\n      scope.$watch('isOpen', function(value) {\n        if (value) {\n          scope.$broadcast('datepicker.focus');\n          scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n          scope.position.top = scope.position.top + element.prop('offsetHeight');\n\n          $document.bind('click', documentClickBind);\n        } else {\n          $document.unbind('click', documentClickBind);\n        }\n      });\n\n      scope.select = function( date ) {\n        if (date === 'today') {\n          var today = new Date();\n          if (angular.isDate(ngModel.$modelValue)) {\n            date = new Date(ngModel.$modelValue);\n            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n          } else {\n            date = new Date(today.setHours(0, 0, 0, 0));\n          }\n        }\n        scope.dateSelection( date );\n      };\n\n      scope.close = function() {\n        scope.isOpen = false;\n        element[0].focus();\n      };\n\n      var $popup = $compile(popupEl)(scope);\n      // Prevent jQuery cache memory leak (template is now redundant after linking)\n      popupEl.remove();\n\n      if ( appendToBody ) {\n        $document.find('body').append($popup);\n      } else {\n        element.after($popup);\n      }\n\n      scope.$on('$destroy', function() {\n        $popup.remove();\n        element.unbind('keydown', keydown);\n        $document.unbind('click', documentClickBind);\n      });\n    }\n  };\n}])\n\n.directive('datepickerPopupWrap', function() {\n  return {\n    restrict:'EA',\n    replace: true,\n    transclude: true,\n    templateUrl: 'template/datepicker/popup.html',\n    link:function (scope, element, attrs) {\n      element.bind('click', function(event) {\n        event.preventDefault();\n        event.stopPropagation();\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.dropdown', [])\n\n.constant('dropdownConfig', {\n  openClass: 'open'\n})\n\n.service('dropdownService', ['$document', function($document) {\n  var openScope = null;\n\n  this.open = function( dropdownScope ) {\n    if ( !openScope ) {\n      $document.bind('click', closeDropdown);\n      $document.bind('keydown', escapeKeyBind);\n    }\n\n    if ( openScope && openScope !== dropdownScope ) {\n        openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n  };\n\n  this.close = function( dropdownScope ) {\n    if ( openScope === dropdownScope ) {\n      openScope = null;\n      $document.unbind('click', closeDropdown);\n      $document.unbind('keydown', escapeKeyBind);\n    }\n  };\n\n  var closeDropdown = function( evt ) {\n    var toggleElement = openScope.getToggleElement();\n    if ( evt && toggleElement && toggleElement[0].contains(evt.target) ) {\n        return;\n    }\n\n    openScope.$apply(function() {\n      openScope.isOpen = false;\n    });\n  };\n\n  var escapeKeyBind = function( evt ) {\n    if ( evt.which === 27 ) {\n      openScope.focusToggleElement();\n      closeDropdown();\n    }\n  };\n}])\n\n.controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {\n  var self = this,\n      scope = $scope.$new(), // create a child scope so we are not polluting original one\n      openClass = dropdownConfig.openClass,\n      getIsOpen,\n      setIsOpen = angular.noop,\n      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop;\n\n  this.init = function( element ) {\n    self.$element = element;\n\n    if ( $attrs.isOpen ) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n  };\n\n  this.toggle = function( open ) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.focusToggleElement = function() {\n    if ( self.toggleElement ) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function( isOpen, wasOpen ) {\n    $animate[isOpen ? 'addClass' : 'removeClass'](self.$element, openClass);\n\n    if ( isOpen ) {\n      scope.focusToggleElement();\n      dropdownService.open( scope );\n    } else {\n      dropdownService.close( scope );\n    }\n\n    setIsOpen($scope, isOpen);\n    if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n      toggleInvoker($scope, { open: !!isOpen });\n    }\n  });\n\n  $scope.$on('$locationChangeSuccess', function() {\n    scope.isOpen = false;\n  });\n\n  $scope.$on('$destroy', function() {\n    scope.$destroy();\n  });\n}])\n\n.directive('dropdown', function() {\n  return {\n    restrict: 'CA',\n    controller: 'DropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init( element );\n    }\n  };\n})\n\n.directive('dropdownToggle', function() {\n  return {\n    restrict: 'CA',\n    require: '?^dropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if ( !dropdownCtrl ) {\n        return;\n      }\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if ( !element.hasClass('disabled') && !attrs.disabled ) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function( isOpen ) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.transition'])\n\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory('$$stackedMap', function () {\n    return {\n      createNew: function () {\n        var stack = [];\n\n        return {\n          add: function (key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function (key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function () {\n            return stack[stack.length - 1];\n          },\n          remove: function (key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function () {\n            return stack.splice(stack.length - 1, 1)[0];\n          },\n          length: function () {\n            return stack.length;\n          }\n        };\n      }\n    };\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive('modalBackdrop', ['$timeout', function ($timeout) {\n    return {\n      restrict: 'EA',\n      replace: true,\n      templateUrl: 'template/modal/backdrop.html',\n      link: function (scope, element, attrs) {\n        scope.backdropClass = attrs.backdropClass || '';\n\n        scope.animate = false;\n\n        //trigger CSS transitions\n        $timeout(function () {\n          scope.animate = true;\n        });\n      }\n    };\n  }])\n\n  .directive('modalWindow', ['$modalStack', '$timeout', function ($modalStack, $timeout) {\n    return {\n      restrict: 'EA',\n      scope: {\n        index: '@',\n        animate: '='\n      },\n      replace: true,\n      transclude: true,\n      templateUrl: function(tElement, tAttrs) {\n        return tAttrs.templateUrl || 'template/modal/window.html';\n      },\n      link: function (scope, element, attrs) {\n        element.addClass(attrs.windowClass || '');\n        scope.size = attrs.size;\n\n        $timeout(function () {\n          // trigger CSS transitions\n          scope.animate = true;\n\n          /**\n           * Auto-focusing of a freshly-opened modal element causes any child elements\n           * with the autofocus attribute to loose focus. This is an issue on touch\n           * based devices which will show and then hide the onscreen keyboard.\n           * Attempts to refocus the autofocus element via JavaScript will not reopen\n           * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n           * the modal element if the modal does not contain an autofocus element.\n           */\n          if (!element[0].querySelectorAll('[autofocus]').length) {\n            element[0].focus();\n          }\n        });\n\n        scope.close = function (evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && (evt.target === evt.currentTarget)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, 'backdrop click');\n          }\n        };\n      }\n    };\n  }])\n\n  .directive('modalTransclude', function () {\n    return {\n      link: function($scope, $element, $attrs, controller, $transclude) {\n        $transclude($scope.$parent, function(clone) {\n          $element.empty();\n          $element.append(clone);\n        });\n      }\n    };\n  })\n\n  .factory('$modalStack', ['$transition', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap',\n    function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {\n\n      var OPENED_MODAL_CLASS = 'modal-open';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var $modalStack = {};\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex){\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance) {\n\n        var body = $document.find('body').eq(0);\n        var modalWindow = openedWindows.get(modalInstance).value;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n\n        //remove window DOM element\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {\n          modalWindow.modalScope.$destroy();\n          body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);\n          checkRemoveBackdrop();\n        });\n      }\n\n      function checkRemoveBackdrop() {\n          //remove backdrop if no longer needed\n          if (backdropDomEl && backdropIndex() == -1) {\n            var backdropScopeRef = backdropScope;\n            removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {\n              backdropScopeRef.$destroy();\n              backdropScopeRef = null;\n            });\n            backdropDomEl = undefined;\n            backdropScope = undefined;\n          }\n      }\n\n      function removeAfterAnimate(domEl, scope, emulateTime, done) {\n        // Closing animation\n        scope.animate = false;\n\n        var transitionEndEventName = $transition.transitionEndEventName;\n        if (transitionEndEventName) {\n          // transition out\n          var timeout = $timeout(afterAnimating, emulateTime);\n\n          domEl.bind(transitionEndEventName, function () {\n            $timeout.cancel(timeout);\n            afterAnimating();\n            scope.$apply();\n          });\n        } else {\n          // Ensure this call is async\n          $timeout(afterAnimating);\n        }\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          domEl.remove();\n          if (done) {\n            done();\n          }\n        }\n      }\n\n      $document.bind('keydown', function (evt) {\n        var modal;\n\n        if (evt.which === 27) {\n          modal = openedWindows.top();\n          if (modal && modal.value.keyboard) {\n            evt.preventDefault();\n            $rootScope.$apply(function () {\n              $modalStack.dismiss(modal.key, 'escape key press');\n            });\n          }\n        }\n      });\n\n      $modalStack.open = function (modalInstance, modal) {\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard\n        });\n\n        var body = $document.find('body').eq(0),\n            currBackdropIndex = backdropIndex();\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.index = currBackdropIndex;\n          var angularBackgroundDomEl = angular.element('<div modal-backdrop></div>');\n          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);\n          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n          body.append(backdropDomEl);\n        }\n\n        var angularDomEl = angular.element('<div modal-window></div>');\n        angularDomEl.attr({\n          'template-url': modal.windowTemplateUrl,\n          'window-class': modal.windowClass,\n          'size': modal.size,\n          'index': openedWindows.length() - 1,\n          'animate': 'animate'\n        }).html(modal.content);\n\n        var modalDomEl = $compile(angularDomEl)(modal.scope);\n        openedWindows.top().value.modalDomEl = modalDomEl;\n        body.append(modalDomEl);\n        body.addClass(OPENED_MODAL_CLASS);\n      };\n\n      $modalStack.close = function (modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.deferred.resolve(result);\n          removeModalWindow(modalInstance);\n        }\n      };\n\n      $modalStack.dismiss = function (modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.deferred.reject(reason);\n          removeModalWindow(modalInstance);\n        }\n      };\n\n      $modalStack.dismissAll = function (reason) {\n        var topModal = this.getTop();\n        while (topModal) {\n          this.dismiss(topModal.key, reason);\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function () {\n        return openedWindows.top();\n      };\n\n      return $modalStack;\n    }])\n\n  .provider('$modal', function () {\n\n    var $modalProvider = {\n      options: {\n        backdrop: true, //can be also false or 'static'\n        keyboard: true\n      },\n      $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack',\n        function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {\n\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $http.get(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl,\n                {cache: $templateCache}).then(function (result) {\n                  return result.data;\n              });\n          }\n\n          function getResolvePromises(resolves) {\n            var promisesArr = [];\n            angular.forEach(resolves, function (value) {\n              if (angular.isFunction(value) || angular.isArray(value)) {\n                promisesArr.push($q.when($injector.invoke(value)));\n              }\n            });\n            return promisesArr;\n          }\n\n          $modal.open = function (modalOptions) {\n\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              close: function (result) {\n                $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n\n            //verify options\n            if (!modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error('One of template or templateUrl options is required.');\n            }\n\n            var templateAndResolvePromise =\n              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\n\n            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {\n\n              var modalScope = (modalOptions.scope || $rootScope).$new();\n              modalScope.$close = modalInstance.close;\n              modalScope.$dismiss = modalInstance.dismiss;\n\n              var ctrlInstance, ctrlLocals = {};\n              var resolveIter = 1;\n\n              //controllers\n              if (modalOptions.controller) {\n                ctrlLocals.$scope = modalScope;\n                ctrlLocals.$modalInstance = modalInstance;\n                angular.forEach(modalOptions.resolve, function (value, key) {\n                  ctrlLocals[key] = tplAndVars[resolveIter++];\n                });\n\n                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n                if (modalOptions.controllerAs) {\n                  modalScope[modalOptions.controllerAs] = ctrlInstance;\n                }\n              }\n\n              $modalStack.open(modalInstance, {\n                scope: modalScope,\n                deferred: modalResultDeferred,\n                content: tplAndVars[0],\n                backdrop: modalOptions.backdrop,\n                keyboard: modalOptions.keyboard,\n                backdropClass: modalOptions.backdropClass,\n                windowClass: modalOptions.windowClass,\n                windowTemplateUrl: modalOptions.windowTemplateUrl,\n                size: modalOptions.size\n              });\n\n            }, function resolveError(reason) {\n              modalResultDeferred.reject(reason);\n            });\n\n            templateAndResolvePromise.then(function () {\n              modalOpenedDeferred.resolve(true);\n            }, function () {\n              modalOpenedDeferred.reject(false);\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }]\n    };\n\n    return $modalProvider;\n  });\n\nangular.module('ui.bootstrap.pagination', [])\n\n.controller('PaginationController', ['$scope', '$attrs', '$parse', function ($scope, $attrs, $parse) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n  this.init = function(ngModelCtrl_, config) {\n    ngModelCtrl = ngModelCtrl_;\n    this.config = config;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = config.itemsPerPage;\n    }\n  };\n\n  this.calculateTotalPages = function() {\n    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  };\n\n  this.render = function() {\n    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n  };\n\n  $scope.selectPage = function(page) {\n    if ( $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n      ngModelCtrl.$setViewValue(page);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.getText = function( key ) {\n    return $scope[key + 'Text'] || self.config[key + 'Text'];\n  };\n  $scope.noPrevious = function() {\n    return $scope.page === 1;\n  };\n  $scope.noNext = function() {\n    return $scope.page === $scope.totalPages;\n  };\n\n  $scope.$watch('totalItems', function() {\n    $scope.totalPages = self.calculateTotalPages();\n  });\n\n  $scope.$watch('totalPages', function(value) {\n    setNumPages($scope.$parent, value); // Readonly variable\n\n    if ( $scope.page > value ) {\n      $scope.selectPage(value);\n    } else {\n      ngModelCtrl.$render();\n    }\n  });\n}])\n\n.constant('paginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true\n})\n\n.directive('pagination', ['$parse', 'paginationConfig', function($parse, paginationConfig) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@'\n    },\n    require: ['pagination', '?ngModel'],\n    controller: 'PaginationController',\n    templateUrl: 'template/pagination/pagination.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      // Setup configuration parameters\n      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\n      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      }\n\n      function getPages(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );\n\n        // recompute if maxSize\n        if ( isMaxSized ) {\n          if ( rotate ) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, number === currentPage);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if ( isMaxSized && ! rotate ) {\n          if ( startPage > 1 ) {\n            var previousPageSet = makePage(startPage - 1, '...', false);\n            pages.unshift(previousPageSet);\n          }\n\n          if ( endPage < totalPages ) {\n            var nextPageSet = makePage(endPage + 1, '...', false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        return pages;\n      }\n\n      var originalRender = paginationCtrl.render;\n      paginationCtrl.render = function() {\n        originalRender();\n        if (scope.page > 0 && scope.page <= scope.totalPages) {\n          scope.pages = getPages(scope.page, scope.totalPages);\n        }\n      };\n    }\n  };\n}])\n\n.constant('pagerConfig', {\n  itemsPerPage: 10,\n  previousText: ' Previous',\n  nextText: 'Next ',\n  align: true\n})\n\n.directive('pager', ['pagerConfig', function(pagerConfig) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@'\n    },\n    require: ['pager', '?ngModel'],\n    controller: 'PaginationController',\n    templateUrl: 'template/pagination/pager.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n      paginationCtrl.init(ngModelCtrl, pagerConfig);\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module( 'ui.bootstrap.tooltip', [ 'ui.bootstrap.position', 'ui.bootstrap.bindHtml' ] )\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider( '$tooltip', function () {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: 'top',\n    animation: true,\n    popupDelay: 0\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    'mouseenter': 'mouseleave',\n    'click': 'click',\n    'focus': 'blur'\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n\n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: 'left' } );\n   *   });\n   */\n\tthis.options = function( value ) {\n\t\tangular.extend( globalOptions, value );\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n   */\n  this.setTriggers = function setTriggers ( triggers ) {\n    angular.extend( triggerMap, triggers );\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake-case.\n   */\n  function snake_case(name){\n    var regexp = /[A-Z]/g;\n    var separator = '-';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : '') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = [ '$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ( $window, $compile, $timeout, $parse, $document, $position, $interpolate ) {\n    return function $tooltip ( type, prefix, defaultTriggerShow ) {\n      var options = angular.extend( {}, defaultOptions, globalOptions );\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers ( trigger ) {\n        var show = trigger || options.trigger || defaultTriggerShow;\n        var hide = triggerMap[show] || show;\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case( type );\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template =\n        '<div '+ directiveName +'-popup '+\n          'title=\"'+startSym+'tt_title'+endSym+'\" '+\n          'content=\"'+startSym+'tt_content'+endSym+'\" '+\n          'placement=\"'+startSym+'tt_placement'+endSym+'\" '+\n          'animation=\"tt_animation\" '+\n          'is-open=\"tt_isOpen\"'+\n          '>'+\n        '</div>';\n\n      return {\n        restrict: 'EA',\n        scope: true,\n        compile: function (tElem, tAttrs) {\n          var tooltipLinker = $compile( template );\n\n          return function link ( scope, element, attrs ) {\n            var tooltip;\n            var transitionTimeout;\n            var popupTimeout;\n            var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;\n            var triggers = getTriggers( undefined );\n            var hasEnableExp = angular.isDefined(attrs[prefix+'Enable']);\n\n            var positionTooltip = function () {\n\n              var ttPosition = $position.positionElements(element, tooltip, scope.tt_placement, appendToBody);\n              ttPosition.top += 'px';\n              ttPosition.left += 'px';\n\n              // Now set the calculated positioning.\n              tooltip.css( ttPosition );\n            };\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            scope.tt_isOpen = false;\n\n            function toggleTooltipBind () {\n              if ( ! scope.tt_isOpen ) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if(hasEnableExp && !scope.$eval(attrs[prefix+'Enable'])) {\n                return;\n              }\n              if ( scope.tt_popupDelay ) {\n                // Do nothing if the tooltip was already scheduled to pop-up.\n                // This happens if show is triggered multiple times before any hide is triggered.\n                if (!popupTimeout) {\n                  popupTimeout = $timeout( show, scope.tt_popupDelay, false );\n                  popupTimeout.then(function(reposition){reposition();});\n                }\n              } else {\n                show()();\n              }\n            }\n\n            function hideTooltipBind () {\n              scope.$apply(function () {\n                hide();\n              });\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n\n              popupTimeout = null;\n\n              // If there is a pending remove transition, we must cancel it, lest the\n              // tooltip be mysteriously removed.\n              if ( transitionTimeout ) {\n                $timeout.cancel( transitionTimeout );\n                transitionTimeout = null;\n              }\n\n              // Don't show empty tooltips.\n              if ( ! scope.tt_content ) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // Set the initial positioning.\n              tooltip.css({ top: 0, left: 0, display: 'block' });\n\n              // Now we add it to the DOM because need some info about it. But it's not \n              // visible yet anyway.\n              if ( appendToBody ) {\n                  $document.find( 'body' ).append( tooltip );\n              } else {\n                element.after( tooltip );\n              }\n\n              positionTooltip();\n\n              // And show the tooltip.\n              scope.tt_isOpen = true;\n              scope.$digest(); // digest required as $apply is not called\n\n              // Return positioning function as promise callback for correct\n              // positioning after draw.\n              return positionTooltip;\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              // First things first: we don't show it anymore.\n              scope.tt_isOpen = false;\n\n              //if tooltip is going to be shown after delay, we must cancel this\n              $timeout.cancel( popupTimeout );\n              popupTimeout = null;\n\n              // And now we remove it from the DOM. However, if we have animation, we \n              // need to wait for it to expire beforehand.\n              // FIXME: this is a placeholder for a port of the transitions library.\n              if ( scope.tt_animation ) {\n                if (!transitionTimeout) {\n                  transitionTimeout = $timeout(removeTooltip, 500);\n                }\n              } else {\n                removeTooltip();\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                removeTooltip();\n              }\n              tooltip = tooltipLinker(scope, function () {});\n\n              // Get contents rendered into the tooltip\n              scope.$digest();\n            }\n\n            function removeTooltip() {\n              transitionTimeout = null;\n              if (tooltip) {\n                tooltip.remove();\n                tooltip = null;\n              }\n            }\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe( type, function ( val ) {\n              scope.tt_content = val;\n\n              if (!val && scope.tt_isOpen ) {\n                hide();\n              }\n            });\n\n            attrs.$observe( prefix+'Title', function ( val ) {\n              scope.tt_title = val;\n            });\n\n            attrs.$observe( prefix+'Placement', function ( val ) {\n              scope.tt_placement = angular.isDefined( val ) ? val : options.placement;\n            });\n\n            attrs.$observe( prefix+'PopupDelay', function ( val ) {\n              var delay = parseInt( val, 10 );\n              scope.tt_popupDelay = ! isNaN(delay) ? delay : options.popupDelay;\n            });\n\n            var unregisterTriggers = function () {\n              element.unbind(triggers.show, showTooltipBind);\n              element.unbind(triggers.hide, hideTooltipBind);\n            };\n\n            attrs.$observe( prefix+'Trigger', function ( val ) {\n              unregisterTriggers();\n\n              triggers = getTriggers( val );\n\n              if ( triggers.show === triggers.hide ) {\n                element.bind( triggers.show, toggleTooltipBind );\n              } else {\n                element.bind( triggers.show, showTooltipBind );\n                element.bind( triggers.hide, hideTooltipBind );\n              }\n            });\n\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\n            scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            attrs.$observe( prefix+'AppendToBody', function ( val ) {\n              appendToBody = angular.isDefined( val ) ? $parse( val )( scope ) : appendToBody;\n            });\n\n            // if a tooltip is attached to <body> we need to remove it on\n            // location change as its parent scope will probably not be destroyed\n            // by the change.\n            if ( appendToBody ) {\n              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {\n              if ( scope.tt_isOpen ) {\n                hide();\n              }\n            });\n            }\n\n            // Make sure tooltip is destroyed and removed.\n            scope.$on('$destroy', function onDestroyTooltip() {\n              $timeout.cancel( transitionTimeout );\n              $timeout.cancel( popupTimeout );\n              unregisterTriggers();\n              removeTooltip();\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n.directive( 'tooltipPopup', function () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-popup.html'\n  };\n})\n\n.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {\n  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );\n}])\n\n.directive( 'tooltipHtmlUnsafePopup', function () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'\n  };\n})\n\n.directive( 'tooltipHtmlUnsafe', [ '$tooltip', function ( $tooltip ) {\n  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html popovers, and selector delegatation.\n */\nangular.module( 'ui.bootstrap.popover', [ 'ui.bootstrap.tooltip' ] )\n\n.directive( 'popoverPopup', function () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover.html'\n  };\n})\n\n.directive( 'popover', [ '$tooltip', function ( $tooltip ) {\n  return $tooltip( 'popover', 'popover', 'click' );\n}]);\n\nangular.module('ui.bootstrap.progressbar', [])\n\n.constant('progressConfig', {\n  animate: true,\n  max: 100\n})\n\n.controller('ProgressController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {\n    var self = this,\n        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n    this.bars = [];\n    $scope.max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max;\n\n    this.addBar = function(bar, element) {\n        if ( !animate ) {\n            element.css({'transition': 'none'});\n        }\n\n        this.bars.push(bar);\n\n        bar.$watch('value', function( value ) {\n            bar.percent = +(100 * value / $scope.max).toFixed(2);\n        });\n\n        bar.$on('$destroy', function() {\n            element = null;\n            self.removeBar(bar);\n        });\n    };\n\n    this.removeBar = function(bar) {\n        this.bars.splice(this.bars.indexOf(bar), 1);\n    };\n}])\n\n.directive('progress', function() {\n    return {\n        restrict: 'EA',\n        replace: true,\n        transclude: true,\n        controller: 'ProgressController',\n        require: 'progress',\n        scope: {},\n        templateUrl: 'template/progressbar/progress.html'\n    };\n})\n\n.directive('bar', function() {\n    return {\n        restrict: 'EA',\n        replace: true,\n        transclude: true,\n        require: '^progress',\n        scope: {\n            value: '=',\n            type: '@'\n        },\n        templateUrl: 'template/progressbar/bar.html',\n        link: function(scope, element, attrs, progressCtrl) {\n            progressCtrl.addBar(scope, element);\n        }\n    };\n})\n\n.directive('progressbar', function() {\n    return {\n        restrict: 'EA',\n        replace: true,\n        transclude: true,\n        controller: 'ProgressController',\n        scope: {\n            value: '=',\n            type: '@'\n        },\n        templateUrl: 'template/progressbar/progressbar.html',\n        link: function(scope, element, attrs, progressCtrl) {\n            progressCtrl.addBar(scope, angular.element(element.children()[0]));\n        }\n    };\n});\nangular.module('ui.bootstrap.rating', [])\n\n.constant('ratingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null\n})\n\n.controller('RatingController', ['$scope', '$attrs', 'ratingConfig', function($scope, $attrs, ratingConfig) {\n  var ngModelCtrl  = { $setViewValue: angular.noop };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\n    var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) :\n                        new Array( angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max );\n    $scope.range = this.buildTemplateObjects(ratingStates);\n  };\n\n  this.buildTemplateObjects = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff }, states[i]);\n    }\n    return states;\n  };\n\n  $scope.rate = function(value) {\n    if ( !$scope.readonly && value >= 0 && value <= $scope.range.length ) {\n      ngModelCtrl.$setViewValue(value);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.enter = function(value) {\n    if ( !$scope.readonly ) {\n      $scope.value = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.onLeave();\n  };\n\n  $scope.onKeydown = function(evt) {\n    if (/(37|38|39|40)/.test(evt.which)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.rate( $scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1) );\n    }\n  };\n\n  this.render = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n  };\n}])\n\n.directive('rating', function() {\n  return {\n    restrict: 'EA',\n    require: ['rating', 'ngModel'],\n    scope: {\n      readonly: '=?',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'RatingController',\n    templateUrl: 'template/rating/rating.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if ( ngModelCtrl ) {\n        ratingCtrl.init( ngModelCtrl );\n      }\n    }\n  };\n});\n\n/**\n * @ngdoc overview\n * @name ui.bootstrap.tabs\n *\n * @description\n * AngularJS version of the tabs directive.\n */\n\nangular.module('ui.bootstrap.tabs', [])\n\n.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {\n  var ctrl = this,\n      tabs = ctrl.tabs = $scope.tabs = [];\n\n  ctrl.select = function(selectedTab) {\n    angular.forEach(tabs, function(tab) {\n      if (tab.active && tab !== selectedTab) {\n        tab.active = false;\n        tab.onDeselect();\n      }\n    });\n    selectedTab.active = true;\n    selectedTab.onSelect();\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    tabs.push(tab);\n    // we can't run the select function on the first tab\n    // since that would select it twice\n    if (tabs.length === 1) {\n      tab.active = true;\n    } else if (tab.active) {\n      ctrl.select(tab);\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index = tabs.indexOf(tab);\n    //Select a new tab if the tab to be removed is selected\n    if (tab.active && tabs.length > 1) {\n      //If this is the last tab, select the previous tab. else, the next tab.\n      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n      ctrl.select(tabs[newActiveIndex]);\n    }\n    tabs.splice(index, 1);\n  };\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabset\n * @restrict EA\n *\n * @description\n * Tabset is the outer container for the tabs directive\n *\n * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <tabset>\n      <tab heading=\"Tab 1\"><b>First</b> Content!</tab>\n      <tab heading=\"Tab 2\"><i>Second</i> Content!</tab>\n    </tabset>\n    <hr />\n    <tabset vertical=\"true\">\n      <tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</tab>\n      <tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</tab>\n    </tabset>\n    <tabset justified=\"true\">\n      <tab heading=\"Justified Tab 1\"><b>First</b> Justified Content!</tab>\n      <tab heading=\"Justified Tab 2\"><i>Second</i> Justified Content!</tab>\n    </tabset>\n  </file>\n</example>\n */\n.directive('tabset', function() {\n  return {\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@'\n    },\n    controller: 'TabsetController',\n    templateUrl: 'template/tabs/tabset.html',\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n    }\n  };\n})\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tab\n * @restrict EA\n *\n * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\n * @param {string=} select An expression to evaluate when the tab is selected.\n * @param {boolean=} active A binding, telling whether or not this tab is selected.\n * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n *\n * @description\n * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <div ng-controller=\"TabsDemoCtrl\">\n      <button class=\"btn btn-small\" ng-click=\"items[0].active = true\">\n        Select item 1, using active binding\n      </button>\n      <button class=\"btn btn-small\" ng-click=\"items[1].disabled = !items[1].disabled\">\n        Enable/disable item 2, using disabled binding\n      </button>\n      <br />\n      <tabset>\n        <tab heading=\"Tab 1\">First Tab</tab>\n        <tab select=\"alertMe()\">\n          <tab-heading><i class=\"icon-bell\"></i> Alert me!</tab-heading>\n          Second Tab, with alert callback and html heading!\n        </tab>\n        <tab ng-repeat=\"item in items\"\n          heading=\"{{item.title}}\"\n          disabled=\"item.disabled\"\n          active=\"item.active\">\n          {{item.content}}\n        </tab>\n      </tabset>\n    </div>\n  </file>\n  <file name=\"script.js\">\n    function TabsDemoCtrl($scope) {\n      $scope.items = [\n        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\n        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\n      ];\n\n      $scope.alertMe = function() {\n        setTimeout(function() {\n          alert(\"You've selected the alert tab!\");\n        });\n      };\n    };\n  </file>\n</example>\n */\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabHeading\n * @restrict EA\n *\n * @description\n * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <tabset>\n      <tab>\n        <tab-heading><b>HTML</b> in my titles?!</tab-heading>\n        And some content, too!\n      </tab>\n      <tab>\n        <tab-heading><i class=\"icon-heart\"></i> Icon heading?!?</tab-heading>\n        That's right.\n      </tab>\n    </tabset>\n  </file>\n</example>\n */\n.directive('tab', ['$parse', function($parse) {\n  return {\n    require: '^tabset',\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/tabs/tab.html',\n    transclude: true,\n    scope: {\n      active: '=?',\n      heading: '@',\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab's content into the dom\n      onDeselect: '&deselect'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being 'under' a tab\n    },\n    compile: function(elm, attrs, transclude) {\n      return function postLink(scope, elm, attrs, tabsetCtrl) {\n        scope.$watch('active', function(active) {\n          if (active) {\n            tabsetCtrl.select(scope);\n          }\n        });\n\n        scope.disabled = false;\n        if ( attrs.disabled ) {\n          scope.$parent.$watch($parse(attrs.disabled), function(value) {\n            scope.disabled = !! value;\n          });\n        }\n\n        scope.select = function() {\n          if ( !scope.disabled ) {\n            scope.active = true;\n          }\n        };\n\n        tabsetCtrl.addTab(scope);\n        scope.$on('$destroy', function() {\n          tabsetCtrl.removeTab(scope);\n        });\n\n        //We need to transclude later, once the content container is ready.\n        //when this link happens, we're inside a tab heading.\n        scope.$transcludeFn = transclude;\n      };\n    }\n  };\n}])\n\n.directive('tabHeadingTransclude', [function() {\n  return {\n    restrict: 'A',\n    require: '^tab',\n    link: function(scope, elm, attrs, tabCtrl) {\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html('');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n}])\n\n.directive('tabContentTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^tabset',\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.tabContentTransclude);\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude 'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n  function isTabHeading(node) {\n    return node.tagName &&  (\n      node.hasAttribute('tab-heading') ||\n      node.hasAttribute('data-tab-heading') ||\n      node.tagName.toLowerCase() === 'tab-heading' ||\n      node.tagName.toLowerCase() === 'data-tab-heading'\n    );\n  }\n})\n\n;\n\nangular.module('ui.bootstrap.timepicker', [])\n\n.constant('timepickerConfig', {\n  hourStep: 1,\n  minuteStep: 1,\n  showMeridian: true,\n  meridians: null,\n  readonlyInput: false,\n  mousewheel: true\n})\n\n.controller('TimepickerController', ['$scope', '$attrs', '$parse', '$log', '$locale', 'timepickerConfig', function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {\n  var selected = new Date(),\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\n  this.init = function( ngModelCtrl_, inputs ) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    var hoursInputEl = inputs.eq(0),\n        minutesInputEl = inputs.eq(1);\n\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n    if ( mousewheel ) {\n      this.setupMousewheelEvents( hoursInputEl, minutesInputEl );\n    }\n\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n    this.setupInputEvents( hoursInputEl, minutesInputEl );\n  };\n\n  var hourStep = timepickerConfig.hourStep;\n  if ($attrs.hourStep) {\n    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n      hourStep = parseInt(value, 10);\n    });\n  }\n\n  var minuteStep = timepickerConfig.minuteStep;\n  if ($attrs.minuteStep) {\n    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n      minuteStep = parseInt(value, 10);\n    });\n  }\n\n  // 12H / 24H mode\n  $scope.showMeridian = timepickerConfig.showMeridian;\n  if ($attrs.showMeridian) {\n    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n      $scope.showMeridian = !!value;\n\n      if ( ngModelCtrl.$error.time ) {\n        // Evaluate from template\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n        if (angular.isDefined( hours ) && angular.isDefined( minutes )) {\n          selected.setHours( hours );\n          refresh();\n        }\n      } else {\n        updateTemplate();\n      }\n    });\n  }\n\n  // Get $scope.hours in 24H mode if valid\n  function getHoursFromTemplate ( ) {\n    var hours = parseInt( $scope.hours, 10 );\n    var valid = ( $scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n    if ( !valid ) {\n      return undefined;\n    }\n\n    if ( $scope.showMeridian ) {\n      if ( hours === 12 ) {\n        hours = 0;\n      }\n      if ( $scope.meridian === meridians[1] ) {\n        hours = hours + 12;\n      }\n    }\n    return hours;\n  }\n\n  function getMinutesFromTemplate() {\n    var minutes = parseInt($scope.minutes, 10);\n    return ( minutes >= 0 && minutes < 60 ) ? minutes : undefined;\n  }\n\n  function pad( value ) {\n    return ( angular.isDefined(value) && value.toString().length < 2 ) ? '0' + value : value;\n  }\n\n  // Respond on mousewheel spin\n  this.setupMousewheelEvents = function( hoursInputEl, minutesInputEl ) {\n    var isScrollingUp = function(e) {\n      if (e.originalEvent) {\n        e = e.originalEvent;\n      }\n      //pick correct delta variable depending on event\n      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n      return (e.detail || delta > 0);\n    };\n\n    hoursInputEl.bind('mousewheel wheel', function(e) {\n      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementHours() : $scope.decrementHours() );\n      e.preventDefault();\n    });\n\n    minutesInputEl.bind('mousewheel wheel', function(e) {\n      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementMinutes() : $scope.decrementMinutes() );\n      e.preventDefault();\n    });\n\n  };\n\n  this.setupInputEvents = function( hoursInputEl, minutesInputEl ) {\n    if ( $scope.readonlyInput ) {\n      $scope.updateHours = angular.noop;\n      $scope.updateMinutes = angular.noop;\n      return;\n    }\n\n    var invalidate = function(invalidHours, invalidMinutes) {\n      ngModelCtrl.$setViewValue( null );\n      ngModelCtrl.$setValidity('time', false);\n      if (angular.isDefined(invalidHours)) {\n        $scope.invalidHours = invalidHours;\n      }\n      if (angular.isDefined(invalidMinutes)) {\n        $scope.invalidMinutes = invalidMinutes;\n      }\n    };\n\n    $scope.updateHours = function() {\n      var hours = getHoursFromTemplate();\n\n      if ( angular.isDefined(hours) ) {\n        selected.setHours( hours );\n        refresh( 'h' );\n      } else {\n        invalidate(true);\n      }\n    };\n\n    hoursInputEl.bind('blur', function(e) {\n      if ( !$scope.invalidHours && $scope.hours < 10) {\n        $scope.$apply( function() {\n          $scope.hours = pad( $scope.hours );\n        });\n      }\n    });\n\n    $scope.updateMinutes = function() {\n      var minutes = getMinutesFromTemplate();\n\n      if ( angular.isDefined(minutes) ) {\n        selected.setMinutes( minutes );\n        refresh( 'm' );\n      } else {\n        invalidate(undefined, true);\n      }\n    };\n\n    minutesInputEl.bind('blur', function(e) {\n      if ( !$scope.invalidMinutes && $scope.minutes < 10 ) {\n        $scope.$apply( function() {\n          $scope.minutes = pad( $scope.minutes );\n        });\n      }\n    });\n\n  };\n\n  this.render = function() {\n    var date = ngModelCtrl.$modelValue ? new Date( ngModelCtrl.$modelValue ) : null;\n\n    if ( isNaN(date) ) {\n      ngModelCtrl.$setValidity('time', false);\n      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n    } else {\n      if ( date ) {\n        selected = date;\n      }\n      makeValid();\n      updateTemplate();\n    }\n  };\n\n  // Call internally when we know that model is valid.\n  function refresh( keyboardChange ) {\n    makeValid();\n    ngModelCtrl.$setViewValue( new Date(selected) );\n    updateTemplate( keyboardChange );\n  }\n\n  function makeValid() {\n    ngModelCtrl.$setValidity('time', true);\n    $scope.invalidHours = false;\n    $scope.invalidMinutes = false;\n  }\n\n  function updateTemplate( keyboardChange ) {\n    var hours = selected.getHours(), minutes = selected.getMinutes();\n\n    if ( $scope.showMeridian ) {\n      hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system\n    }\n\n    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n    $scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);\n    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n  }\n\n  function addMinutes( minutes ) {\n    var dt = new Date( selected.getTime() + minutes * 60000 );\n    selected.setHours( dt.getHours(), dt.getMinutes() );\n    refresh();\n  }\n\n  $scope.incrementHours = function() {\n    addMinutes( hourStep * 60 );\n  };\n  $scope.decrementHours = function() {\n    addMinutes( - hourStep * 60 );\n  };\n  $scope.incrementMinutes = function() {\n    addMinutes( minuteStep );\n  };\n  $scope.decrementMinutes = function() {\n    addMinutes( - minuteStep );\n  };\n  $scope.toggleMeridian = function() {\n    addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );\n  };\n}])\n\n.directive('timepicker', function () {\n  return {\n    restrict: 'EA',\n    require: ['timepicker', '?^ngModel'],\n    controller:'TimepickerController',\n    replace: true,\n    scope: {},\n    templateUrl: 'template/timepicker/timepicker.html',\n    link: function(scope, element, attrs, ctrls) {\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if ( ngModelCtrl ) {\n        timepickerCtrl.init( ngModelCtrl, element.find('input') );\n      }\n    }\n  };\n});\n\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('typeaheadParser', ['$parse', function ($parse) {\n\n  //                      00000111000000000000022200000000000000003333333333333330000000000044000\n  var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n\n  return {\n    parse:function (input) {\n\n      var match = input.match(TYPEAHEAD_REGEXP);\n      if (!match) {\n        throw new Error(\n          'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n            ' but got \"' + input + '\".');\n      }\n\n      return {\n        itemName:match[3],\n        source:$parse(match[4]),\n        viewMapper:$parse(match[2] || match[1]),\n        modelMapper:$parse(match[1])\n      };\n    }\n  };\n}])\n\n  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',\n    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {\n\n  var HOT_KEYS = [9, 13, 27, 38, 40];\n\n  return {\n    require:'ngModel',\n    link:function (originalScope, element, attrs, modelCtrl) {\n\n      //SUPPORTED ATTRIBUTES (OPTIONS)\n\n      //minimal no of characters that needs to be entered before typeahead kicks-in\n      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;\n\n      //minimal wait time after last character typed before typehead kicks-in\n      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n      //should it restrict model values to the ones selected from the popup only?\n      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n      //binding to a variable that indicates if matches are being retrieved asynchronously\n      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n      //a callback executed when a match is selected\n      var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n      var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n      //INTERNAL VARIABLES\n\n      //model setter executed upon match selection\n      var $setModelValue = $parse(attrs.ngModel).assign;\n\n      //expressions used by typeahead\n      var parserResult = typeaheadParser.parse(attrs.typeahead);\n\n      var hasFocus;\n\n      //create a child scope for the typeahead directive so we are not polluting original scope\n      //with typeahead-specific data (matches, query etc.)\n      var scope = originalScope.$new();\n      originalScope.$on('$destroy', function(){\n        scope.$destroy();\n      });\n\n      // WAI-ARIA\n      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n      element.attr({\n        'aria-autocomplete': 'list',\n        'aria-expanded': false,\n        'aria-owns': popupId\n      });\n\n      //pop-up element used to display matches\n      var popUpEl = angular.element('<div typeahead-popup></div>');\n      popUpEl.attr({\n        id: popupId,\n        matches: 'matches',\n        active: 'activeIdx',\n        select: 'select(activeIdx)',\n        query: 'query',\n        position: 'position'\n      });\n      //custom item template\n      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n      }\n\n      var resetMatches = function() {\n        scope.matches = [];\n        scope.activeIdx = -1;\n        element.attr('aria-expanded', false);\n      };\n\n      var getMatchId = function(index) {\n        return popupId + '-option-' + index;\n      };\n\n      // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n      // This attribute is added or removed automatically when the `activeIdx` changes.\n      scope.$watch('activeIdx', function(index) {\n        if (index < 0) {\n          element.removeAttr('aria-activedescendant');\n        } else {\n          element.attr('aria-activedescendant', getMatchId(index));\n        }\n      });\n\n      var getMatchesAsync = function(inputValue) {\n\n        var locals = {$viewValue: inputValue};\n        isLoadingSetter(originalScope, true);\n        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\n          //it might happen that several async queries were in progress if a user were typing fast\n          //but we are interested only in responses that correspond to the current view value\n          var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n          if (onCurrentRequest && hasFocus) {\n            if (matches.length > 0) {\n\n              scope.activeIdx = 0;\n              scope.matches.length = 0;\n\n              //transform labels\n              for(var i=0; i<matches.length; i++) {\n                locals[parserResult.itemName] = matches[i];\n                scope.matches.push({\n                  id: getMatchId(i),\n                  label: parserResult.viewMapper(scope, locals),\n                  model: matches[i]\n                });\n              }\n\n              scope.query = inputValue;\n              //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n              //due to other elements being rendered\n              scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n              scope.position.top = scope.position.top + element.prop('offsetHeight');\n\n              element.attr('aria-expanded', true);\n            } else {\n              resetMatches();\n            }\n          }\n          if (onCurrentRequest) {\n            isLoadingSetter(originalScope, false);\n          }\n        }, function(){\n          resetMatches();\n          isLoadingSetter(originalScope, false);\n        });\n      };\n\n      resetMatches();\n\n      //we need to propagate user's query so we can higlight matches\n      scope.query = undefined;\n\n      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later \n      var timeoutPromise;\n\n      var scheduleSearchWithTimeout = function(inputValue) {\n        timeoutPromise = $timeout(function () {\n          getMatchesAsync(inputValue);\n        }, waitTime);\n      };\n\n      var cancelPreviousTimeout = function() {\n        if (timeoutPromise) {\n          $timeout.cancel(timeoutPromise);\n        }\n      };\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function (inputValue) {\n\n        hasFocus = true;\n\n        if (inputValue && inputValue.length >= minSearch) {\n          if (waitTime > 0) {\n            cancelPreviousTimeout();\n            scheduleSearchWithTimeout(inputValue);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          cancelPreviousTimeout();\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        } else {\n          if (!inputValue) {\n            // Reset in case user had typed something previously.\n            modelCtrl.$setValidity('editable', true);\n            return inputValue;\n          } else {\n            modelCtrl.$setValidity('editable', false);\n            return undefined;\n          }\n        }\n      });\n\n      modelCtrl.$formatters.push(function (modelValue) {\n\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        if (inputFormatter) {\n\n          locals['$model'] = modelValue;\n          return inputFormatter(originalScope, locals);\n\n        } else {\n\n          //it might happen that we don't have enough info to properly render input value\n          //we need to check for this situation and simply return model value if we can't apply custom formatting\n          locals[parserResult.itemName] = modelValue;\n          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n          locals[parserResult.itemName] = undefined;\n          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;\n        }\n      });\n\n      scope.select = function (activeIdx) {\n        //called from within the $digest() cycle\n        var locals = {};\n        var model, item;\n\n        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n        model = parserResult.modelMapper(originalScope, locals);\n        $setModelValue(originalScope, model);\n        modelCtrl.$setValidity('editable', true);\n\n        onSelectCallback(originalScope, {\n          $item: item,\n          $model: model,\n          $label: parserResult.viewMapper(originalScope, locals)\n        });\n\n        resetMatches();\n\n        //return focus to the input element if a match was selected via a mouse click event\n        // use timeout to avoid $rootScope:inprog error\n        $timeout(function() { element[0].focus(); }, 0, false);\n      };\n\n      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n      element.bind('keydown', function (evt) {\n\n        //typeahead is open and an \"interesting\" key was pressed\n        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n          return;\n        }\n\n        evt.preventDefault();\n\n        if (evt.which === 40) {\n          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n          scope.$digest();\n\n        } else if (evt.which === 38) {\n          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;\n          scope.$digest();\n\n        } else if (evt.which === 13 || evt.which === 9) {\n          scope.$apply(function () {\n            scope.select(scope.activeIdx);\n          });\n\n        } else if (evt.which === 27) {\n          evt.stopPropagation();\n\n          resetMatches();\n          scope.$digest();\n        }\n      });\n\n      element.bind('blur', function (evt) {\n        hasFocus = false;\n      });\n\n      // Keep reference to click handler to unbind it.\n      var dismissClickHandler = function (evt) {\n        if (element[0] !== evt.target) {\n          resetMatches();\n          scope.$digest();\n        }\n      };\n\n      $document.bind('click', dismissClickHandler);\n\n      originalScope.$on('$destroy', function(){\n        $document.unbind('click', dismissClickHandler);\n      });\n\n      var $popup = $compile(popUpEl)(scope);\n      if ( appendToBody ) {\n        $document.find('body').append($popup);\n      } else {\n        element.after($popup);\n      }\n    }\n  };\n\n}])\n\n  .directive('typeaheadPopup', function () {\n    return {\n      restrict:'EA',\n      scope:{\n        matches:'=',\n        query:'=',\n        active:'=',\n        position:'=',\n        select:'&'\n      },\n      replace:true,\n      templateUrl:'template/typeahead/typeahead-popup.html',\n      link:function (scope, element, attrs) {\n\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function () {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function (matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function (matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function (activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  })\n\n  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {\n    return {\n      restrict:'EA',\n      scope:{\n        index:'=',\n        match:'=',\n        query:'='\n      },\n      link:function (scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n        $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent){\n           element.replaceWith($compile(tplContent.trim())(scope));\n        });\n      }\n    };\n  }])\n\n  .filter('typeaheadHighlight', function() {\n\n    function escapeRegexp(queryToEscape) {\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    return function(matchItem, query) {\n      return query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;\n    };\n  });\n\nangular.module(\"template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/accordion/accordion-group.html\",\n    \"<div class=\\\"panel panel-default\\\">\\n\" +\n    \"  <div class=\\\"panel-heading\\\">\\n\" +\n    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n    \"      <a class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" accordion-transclude=\\\"heading\\\"><span ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n    \"    </h4>\\n\" +\n    \"  </div>\\n\" +\n    \"  <div class=\\\"panel-collapse\\\" collapse=\\\"!isOpen\\\">\\n\" +\n    \"\t  <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/accordion/accordion.html\",\n    \"<div class=\\\"panel-group\\\" ng-transclude></div>\");\n}]);\n\nangular.module(\"template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/alert/alert.html\",\n    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissable' : null]\\\" role=\\\"alert\\\">\\n\" +\n    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close()\\\">\\n\" +\n    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n    \"    </button>\\n\" +\n    \"    <div ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/carousel/carousel.html\",\n    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n    \"    <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"        <li ng-repeat=\\\"slide in slides track by $index\\\" ng-class=\\\"{active: isActive(slide)}\\\" ng-click=\\\"select(slide)\\\"></li>\\n\" +\n    \"    </ol>\\n\" +\n    \"    <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n    \"    <a class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\"><span class=\\\"glyphicon glyphicon-chevron-left\\\"></span></a>\\n\" +\n    \"    <a class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\"><span class=\\\"glyphicon glyphicon-chevron-right\\\"></span></a>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/carousel/slide.html\",\n    \"<div ng-class=\\\"{\\n\" +\n    \"    'active': leaving || (active && !entering),\\n\" +\n    \"    'prev': (next || active) && direction=='prev',\\n\" +\n    \"    'next': (next || active) && direction=='next',\\n\" +\n    \"    'right': direction=='prev',\\n\" +\n    \"    'left': direction=='next'\\n\" +\n    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/datepicker.html\",\n    \"<div ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n    \"  <daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></daypicker>\\n\" +\n    \"  <monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></monthpicker>\\n\" +\n    \"  <yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></yearpicker>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/day.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"{{5 + showWeeks}}\\\"><button id=\\\"{{uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th ng-show=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n    \"      <th ng-repeat=\\\"label in labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{label.full}}\\\">{{label.abbr}}</small></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-show=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{dt.uid}}\\\" aria-disabled=\\\"{{!!dt.disabled}}\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"width:100%;\\\" class=\\\"btn btn-default btn-sm\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/month.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th><button id=\\\"{{uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{dt.uid}}\\\" aria-disabled=\\\"{{!!dt.disabled}}\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"{'text-info': dt.current}\\\">{{dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" ng-style=\\\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n    \"\t<li ng-transclude></li>\\n\" +\n    \"\t<li ng-if=\\\"showButtonBar\\\" style=\\\"padding:10px 9px 2px\\\">\\n\" +\n    \"\t\t<span class=\\\"btn-group\\\">\\n\" +\n    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-info\\\" ng-click=\\\"select('today')\\\">{{ getText('current') }}</button>\\n\" +\n    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger\\\" ng-click=\\\"select(null)\\\">{{ getText('clear') }}</button>\\n\" +\n    \"\t\t</span>\\n\" +\n    \"\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right\\\" ng-click=\\\"close()\\\">{{ getText('close') }}</button>\\n\" +\n    \"\t</li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/year.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"3\\\"><button id=\\\"{{uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{dt.uid}}\\\" aria-disabled=\\\"{{!!dt.disabled}}\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"{'text-info': dt.current}\\\">{{dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/modal/backdrop.html\",\n    \"<div class=\\\"modal-backdrop fade {{ backdropClass }}\\\"\\n\" +\n    \"     ng-class=\\\"{in: animate}\\\"\\n\" +\n    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n    \"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/modal/window.html\",\n    \"<div tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal fade\\\" ng-class=\\\"{in: animate}\\\" ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\" ng-click=\\\"close($event)\\\">\\n\" +\n    \"    <div class=\\\"modal-dialog\\\" ng-class=\\\"{'modal-sm': size == 'sm', 'modal-lg': size == 'lg'}\\\"><div class=\\\"modal-content\\\" modal-transclude></div></div>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/pagination/pager.html\",\n    \"<ul class=\\\"pager\\\">\\n\" +\n    \"  <li ng-class=\\\"{disabled: noPrevious(), previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1)\\\">{{getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-class=\\\"{disabled: noNext(), next: align}\\\"><a href ng-click=\\\"selectPage(page + 1)\\\">{{getText('next')}}</a></li>\\n\" +\n    \"</ul>\");\n}]);\n\nangular.module(\"template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/pagination/pagination.html\",\n    \"<ul class=\\\"pagination\\\">\\n\" +\n    \"  <li ng-if=\\\"boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()}\\\"><a href ng-click=\\\"selectPage(1)\\\">{{getText('first')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"directionLinks\\\" ng-class=\\\"{disabled: noPrevious()}\\\"><a href ng-click=\\\"selectPage(page - 1)\\\">{{getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active}\\\"><a href ng-click=\\\"selectPage(page.number)\\\">{{page.text}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"directionLinks\\\" ng-class=\\\"{disabled: noNext()}\\\"><a href ng-click=\\\"selectPage(page + 1)\\\">{{getText('next')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"boundaryLinks\\\" ng-class=\\\"{disabled: noNext()}\\\"><a href ng-click=\\\"selectPage(totalPages)\\\">{{getText('last')}}</a></li>\\n\" +\n    \"</ul>\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-html-unsafe-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-html-unsafe-popup.html\",\n    \"<div class=\\\"tooltip {{placement}}\\\" ng-class=\\\"{ in: isOpen(), fade: animation() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" bind-html-unsafe=\\\"content\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-popup.html\",\n    \"<div class=\\\"tooltip {{placement}}\\\" ng-class=\\\"{ in: isOpen(), fade: animation() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/popover/popover.html\",\n    \"<div class=\\\"popover {{placement}}\\\" ng-class=\\\"{ in: isOpen(), fade: animation() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-show=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/bar.html\",\n    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: percent + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" ng-transclude></div>\");\n}]);\n\nangular.module(\"template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/progress.html\",\n    \"<div class=\\\"progress\\\" ng-transclude></div>\");\n}]);\n\nangular.module(\"template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/progressbar.html\",\n    \"<div class=\\\"progress\\\">\\n\" +\n    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: percent + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" ng-transclude></div>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/rating/rating.html\",\n    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n    \"    <i ng-repeat=\\\"r in range track by $index\\\" ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\">\\n\" +\n    \"        <span class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n    \"    </i>\\n\" +\n    \"</span>\");\n}]);\n\nangular.module(\"template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tabs/tab.html\",\n    \"<li ng-class=\\\"{active: active, disabled: disabled}\\\">\\n\" +\n    \"  <a ng-click=\\\"select()\\\" tab-heading-transclude>{{heading}}</a>\\n\" +\n    \"</li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tabs/tabset.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"nav nav-{{type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n    \"  <div class=\\\"tab-content\\\">\\n\" +\n    \"    <div class=\\\"tab-pane\\\" \\n\" +\n    \"         ng-repeat=\\\"tab in tabs\\\" \\n\" +\n    \"         ng-class=\\\"{active: tab.active}\\\"\\n\" +\n    \"         tab-content-transclude=\\\"tab\\\">\\n\" +\n    \"    </div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/timepicker/timepicker.html\",\n    \"<table>\\n\" +\n    \"\t<tbody>\\n\" +\n    \"\t\t<tr class=\\\"text-center\\\">\\n\" +\n    \"\t\t\t<td><a ng-click=\\\"incrementHours()\\\" class=\\\"btn btn-link\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"\t\t\t<td>&nbsp;</td>\\n\" +\n    \"\t\t\t<td><a ng-click=\\\"incrementMinutes()\\\" class=\\\"btn btn-link\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"\t\t\t<td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"\t\t</tr>\\n\" +\n    \"\t\t<tr>\\n\" +\n    \"\t\t\t<td style=\\\"width:50px;\\\" class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n    \"\t\t\t\t<input type=\\\"text\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-mousewheel=\\\"incrementHours()\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\">\\n\" +\n    \"\t\t\t</td>\\n\" +\n    \"\t\t\t<td>:</td>\\n\" +\n    \"\t\t\t<td style=\\\"width:50px;\\\" class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n    \"\t\t\t\t<input type=\\\"text\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\">\\n\" +\n    \"\t\t\t</td>\\n\" +\n    \"\t\t\t<td ng-show=\\\"showMeridian\\\"><button type=\\\"button\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\">{{meridian}}</button></td>\\n\" +\n    \"\t\t</tr>\\n\" +\n    \"\t\t<tr class=\\\"text-center\\\">\\n\" +\n    \"\t\t\t<td><a ng-click=\\\"decrementHours()\\\" class=\\\"btn btn-link\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"\t\t\t<td>&nbsp;</td>\\n\" +\n    \"\t\t\t<td><a ng-click=\\\"decrementMinutes()\\\" class=\\\"btn btn-link\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"\t\t\t<td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"\t\t</tr>\\n\" +\n    \"\t</tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/typeahead/typeahead-match.html\",\n    \"<a tabindex=\\\"-1\\\" bind-html-unsafe=\\\"match.label | typeaheadHighlight:query\\\"></a>\");\n}]);\n\nangular.module(\"template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/typeahead/typeahead-popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen()\\\" ng-style=\\\"{top: position.top+'px', left: position.left+'px'}\\\" style=\\\"display: block;\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index)\\\" role=\\\"option\\\" id=\\\"{{match.id}}\\\">\\n\" +\n    \"        <div typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/angular-bootstrap/ui-bootstrap-tpls.js\n ** module id = 2\n ** module chunks = 0\n **/","var jade = require(\"/home/travis/build/applicaster/siren-browser/node_modules/jade/lib/runtime.js\");\n\nmodule.exports = function template(locals) {\nvar buf = [];\nvar jade_mixins = {};\nvar jade_interp;\n\nbuf.push(\"<a href=\\\"https://github.com/applicaster/siren-browser\\\"><img style=\\\"position: absolute; top: 0; right: 0; border: 0; z-index:2;\\\" src=\\\"https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67\\\" alt=\\\"Fork me on GitHub\\\" data-canonical-src=\\\"https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png\\\"/></a><div cg-busy=\\\"{promise:myPromise,message:'Loading Your Data', minDuration: 500}\\\"> <div role=\\\"navigation\\\" style=\\\"z-index:1;\\\" class=\\\"navbar navbar-inverse navbar-fixed-top\\\"><div class=\\\"container\\\"><div class=\\\"navbar-header\\\"><button type=\\\"button\\\" data-toggle=\\\"collapse\\\" data-target=\\\".navbar-collapse\\\" class=\\\"navbar-toggle\\\"><span class=\\\"sr-only\\\">Toggle navigation</span><span class=\\\"icon-bar\\\"></span><span class=\\\"icon-bar\\\"></span><span class=\\\"icon-bar\\\"></span></button><a href=\\\"#\\\" class=\\\"navbar-brand\\\">Siren API Browser</a></div></div></div><div style=\\\"padding-top:60px;\\\" class=\\\"container\\\"><div class=\\\"row\\\"><div class=\\\"col-md-12\\\"><div ui-view=\\\"\\\"></div></div></div></div></div>\");;return buf.join(\"\");\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/body.jade\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * State-based routing for AngularJS\n * @version v0.2.11\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  angular.forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction arraySearch(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (arraySearch(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, cycle.indexOf(key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n      \n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, parent.$$inheritedValues);\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      if (parent.$$values) {\n        merged = merge(values, parent.$$values);\n        result.$$inheritedValues = parent.$$values;\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = parent.$$inheritedValues;\n        }        \n        extend(promises, parent.$$promises);\n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache })\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n * \n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp '}'` - curly placeholder with regexp. Should the regexp itself contain\n *   curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon \n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n * \n * Examples:\n * \n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when \n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config) {\n  config = angular.isObject(config) ? config : {};\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])(\\w+)               classic placeholder ($1 / $2)\n  //    \\{(\\w+)(?:\\:( ... ))?\\}   curly brace placeholder ($3) with optional regexp ... ($4)\n  //    (?: ... | ... | ... )+    the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                  - anything other than curly braces or backslash\n  //    \\\\.                       - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}     - a matched set of curly braces containing other atoms\n  var placeholder = /([:*])(\\w+)|\\{(\\w+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      params = this.params = {};\n\n  /**\n   * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n   * default value, which may be the result of an injectable function.\n   */\n  function $value(value) {\n    /*jshint validthis: true */\n    return isDefined(value) ? this.type.decode(value) : $UrlMatcherFactory.$$getDefaultValue(this);\n  }\n\n  function addParameter(id, type, config) {\n    if (!/^\\w+(-+\\w+)*$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = extend({ type: type || new Type(), $value: $value }, config);\n  }\n\n  function quoteRegExp(string, pattern, isOptional) {\n    var result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    var flag = isOptional ? '?' : '';\n    return result + flag + '(' + pattern + ')' + flag;\n  }\n\n  function paramConfig(param) {\n    if (!config.params || !config.params[param]) return {};\n    var cfg = config.params[param];\n    return isObject(cfg) ? cfg : { value: cfg };\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  var id, regexp, segment, type, cfg;\n\n  while ((m = placeholder.exec(pattern))) {\n    id      = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    regexp  = m[4] || (m[1] == '*' ? '.*' : '[^/]*');\n    segment = pattern.substring(last, m.index);\n    type    = this.$types[regexp] || new Type({ pattern: new RegExp(regexp) });\n    cfg     = paramConfig(id);\n\n    if (segment.indexOf('?') >= 0) break; // we're into the search part\n\n    compiled += quoteRegExp(segment, type.$subPattern(), isDefined(cfg.value));\n    addParameter(id, type, cfg);\n    segments.push(segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    // Allow parameters to be separated by '?' as well as '&' to make concat() easier\n    forEach(search.substring(1).split(/[&?]/), function(key) {\n      addParameter(key, null, paramConfig(key));\n    });\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, config);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var params = this.parameters(), nTotal = params.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, cfg, param;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  for (i = 0; i < nPath; i++) {\n    param = params[i];\n    cfg = this.params[param];\n    values[param] = cfg.$value(m[i + 1]);\n  }\n  for (/**/; i < nTotal; i++) {\n    param = params[i];\n    cfg = this.params[param];\n    values[param] = cfg.$value(searchParams[param]);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n * \n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return objectKeys(this.params);\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validate\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  var result = true, isOptional, cfg, self = this;\n\n  forEach(params, function(val, key) {\n    if (!self.params[key]) return;\n    cfg = self.params[key];\n    isOptional = !val && isDefined(cfg.value);\n    result = result && (isOptional || cfg.type.is(val));\n  });\n  return result;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  var segments = this.segments, params = this.parameters();\n\n  if (!values) return segments.join('').replace('//', '/');\n\n  var nPath = segments.length - 1, nTotal = params.length,\n    result = segments[0], i, search, value, param, cfg, array;\n\n  if (!this.validates(values)) return null;\n\n  for (i = 0; i < nPath; i++) {\n    param = params[i];\n    value = values[param];\n    cfg   = this.params[param];\n\n    if (!isDefined(value) && (segments[i] === '/' || segments[i + 1] === '/')) continue;\n    if (value != null) result += encodeURIComponent(cfg.type.encode(value));\n    result += segments[i + 1];\n  }\n\n  for (/**/; i < nTotal; i++) {\n    param = params[i];\n    value = values[param];\n    if (value == null) continue;\n    array = isArray(value);\n\n    if (array) {\n      value = value.map(encodeURIComponent).join('&' + param + '=');\n    }\n    result += (search ? '&' : '?') + param + '=' + (array ? value : encodeURIComponent(value));\n    search = true;\n  }\n  return result;\n};\n\nUrlMatcher.prototype.$types = {};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object hash that includes any method in `Type`'s public\n *        interface, and/or `pattern`, which should contain a custom regular expression used to match\n *        string parameters originating from a URL.\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a string URL parameter value to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n\n  var isCaseInsensitive = false, isStrictMode = true;\n\n  var enqueue = true, typeQueue = [], injector, defaultTypes = {\n    int: {\n      decode: function(val) {\n        return parseInt(val, 10);\n      },\n      is: function(val) {\n        if (!isDefined(val)) return false;\n        return this.decode(val.toString()) === val;\n      },\n      pattern: /\\d+/\n    },\n    bool: {\n      encode: function(val) {\n        return val ? 1 : 0;\n      },\n      decode: function(val) {\n        return parseInt(val, 10) === 0 ? false : true;\n      },\n      is: function(val) {\n        return val === true || val === false;\n      },\n      pattern: /0|1/\n    },\n    string: {\n      pattern: /[^\\/]*/\n    },\n    date: {\n      equals: function (a, b) {\n        return a.toISOString() === b.toISOString();\n      },\n      decode: function (val) {\n        return new Date(val);\n      },\n      encode: function (val) {\n        return [\n          val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   */\n  this.caseInsensitive = function(value) {\n    isCaseInsensitive = value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean} value `false` to match trailing slashes in URLs, otherwise `true`.\n   */\n  this.strictMode = function(value) {\n    isStrictMode = value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *   \n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} def  The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, def) {\n    if (!isDefined(def)) return UrlMatcher.prototype.$types[name];\n    typeQueue.push({ name: name, def: def });\n    if (!enqueue) flushTypeQueue();\n    return this;\n  };\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    UrlMatcher.prototype.$types = {};\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!UrlMatcher.prototype.$types[name]) UrlMatcher.prototype.$types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  // To ensure proper order of operations in object configuration, and to allow internal\n  // types to be overridden, `flushTypeQueue()` waits until `$urlMatcherFactory` is injected\n  // before actually wiring up and assigning type definitions\n  function flushTypeQueue() {\n    forEach(typeQueue, function(type) {\n      if (UrlMatcher.prototype.$types[type.name]) {\n        throw new Error(\"A type named '\" + type.name + \"' has already been defined.\");\n      }\n      var def = new Type(isInjectable(type.def) ? injector.invoke(type.def) : type.def);\n      UrlMatcher.prototype.$types[type.name] = def;\n    });\n  }\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {object} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. if handle is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|object} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];\n  function $get(   $location,   $rootScope,   $injector,   $browser) {\n\n    var baseHref = $browser.baseHref(), location = $location.url();\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n        $location.url(urlMatcher.format(params || {}));\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = extend({}, state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      if (!state.params) {\n        return state.url ? state.url.params : state.parent.params;\n      }\n      return state.params;\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    ownParams: function(state) {\n      state.params = state.params || {};\n\n      if (!state.parent) {\n          return objectKeys(state.params);\n      }\n      var paramNames = {}; forEach(state.params, function (v, k) { paramNames[k] = true; });\n\n      forEach(state.parent.params, function (v, k) {\n        if (!paramNames[k]) {\n          throw new Error(\"Missing required parameter '\" + k + \"' in state '\" + state.name + \"'\");\n        }\n        paramNames[k] = false;\n      });\n      var ownParams = [];\n\n      forEach(paramNames, function (own, p) {\n        if (own) ownParams.push(p);\n      });\n      return ownParams;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    if (queue[name]) {\n      for (var i = 0; i < queue[name].length; i++) {\n        registerState(queue[name][i]);\n      }\n    }\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(segments.indexOf(globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(segments.indexOf(globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * <a id='template'></a>\n   *\n   * - **`template`** - {string|function=} - html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <a id='templateUrl'></a>\n   *\n   * - **`templateUrl`** - {string|function=} - path or function that returns a path to an html \n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <a id='templateProvider'></a>\n   *\n   * - **`templateProvider`** - {function=} - Provider function that returns HTML content\n   *   string.\n   *\n   * <a id='controller'></a>\n   *\n   * - **`controller`** - {string|function=} -  Controller fn that should be associated with newly \n   *   related scope or the name of a registered controller if passed as a string.\n   *\n   * <a id='controllerProvider'></a>\n   *\n   * - **`controllerProvider`** - {function=} - Injectable provider function that returns\n   *   the actual controller or string.\n   *\n   * <a id='controllerAs'></a>\n   * \n   * - **`controllerAs`**  {string=}  A controller alias name. If present the controller will be \n   *   published to scope under the controllerAs name.\n   *\n   * <a id='resolve'></a>\n   *\n   * - **`resolve`** - {object.&lt;string, function&gt;=} - An optional map of dependencies which \n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved or one to be rejected before the \n   *   controller is instantiated. If all the promises are resolved successfully, the values \n   *   of the resolved promises are injected and $stateChangeSuccess event is fired. If any \n   *   of the promises are rejected the $stateChangeError event is fired. The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <a id='url'></a>\n   *\n   * - **`url`** - {string=} - A url with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   * <a id='params'></a>\n   *\n   * - **`params`** - {object=} - An array of parameter names or regular expressions. Only \n   *   use this within a state if you are not using url. Otherwise you can specify your\n   *   parameters within the url. When a state is navigated or transitioned to, the \n   *   $stateParams service will be populated with any parameters that were passed.\n   *\n   * <a id='views'></a>\n   *\n   * - **`views`** - {object=} - Use the views property to set up multiple views or to target views\n   *   manually/explicitly.\n   *\n   * <a id='abstract'></a>\n   *\n   * - **`abstract`** - {boolean=} - An abstract state will never be directly activated, \n   *   but can provide inherited properties to its common children states.\n   *\n   * <a id='onEnter'></a>\n   *\n   * - **`onEnter`** - {object=} - Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n   *\n   * <a id='onExit'></a>\n   *\n   * - **`onExit`** - {object=} - Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n   *\n   * <a id='reloadOnSearch'></a>\n   *\n   * - **`reloadOnSearch = true`** - {boolean=} - If `false`, will not retrigger the same state \n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   *\n   * <a id='data'></a>\n   *\n   * - **`data`** - {object=} - Arbitrary data object, useful for custom configuration.\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the \n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\". \n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} definition State configuration object.\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved, events are not re-fired, \n     * and controllers reinstantiated (bug with controllers reinstantiating right now, fixing soon).\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: false \n     * });\n     * </pre>\n     */\n    $state.reload = function reload() {\n      $state.transitionTo($state.current, $stateParams, { reload: true, inherit: false, notify: false });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && equalForKeys(toParams, fromParams, state.ownParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldTriggerReload(to, from, locals, options)) {\n        if (to.self.reloadOnSearch !== false) $urlRouter.update();\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(objectKeys(to.params), toParams || {});\n\n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n          $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be \n     * tested for strict equality against the current active params object, so all params \n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like \n     * to test against the current active state.\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params) {\n      var state = findState(stateOrName);\n\n      if (!isDefined(state)) {\n        return undefined;\n      }\n\n      if ($state.$current !== state) {\n        return false;\n      }\n\n      return isDefined(params) && params !== null ? angular.equals($stateParams, params) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params) {\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n      var state = findState(stateOrName);\n\n      if (!isDefined(state)) {\n        return undefined;\n      }\n      if (!isDefined($state.$current.includes[state.name])) {\n        return false;\n      }\n      return equalForKeys(params, $stateParams);\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || !nav.url) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(objectKeys(state.params), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|Sbject=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return objectKeys(states).map(function(name) { return states[name].self; });\n      var state = findState(stateOrName, context);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(objectKeys(state.params), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      // Resolve template and dependencies for all views.\n      forEach(state.views, function (view, name) {\n        var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n        injectables.$template = [ function () {\n          return $view.load(name, { view: view, locals: locals, params: $stateParams }) || '';\n        }];\n\n        promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function (result) {\n          // References to the controller (only instantiated at link time)\n          if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n            var injectLocals = angular.extend({}, injectables, locals);\n            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n          } else {\n            result.$$controller = view.controller;\n          }\n          // Provide access to the state itself for internal use\n          result.$$state = state;\n          result.$$controllerAs = view.controllerAs;\n          dst[name] = result;\n        }));\n      });\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldTriggerReload(to, from, locals, options) {\n    if (to === from && ((locals === from.locals && !options.reload) || (to.self.reloadOnSearch === false))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .value('$stateParams', {})\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        if (result && options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$viewContentLoading\n         * @eventOf ui.router.state.$view\n         * @eventType broadcast on root scope\n         * @description\n         *\n         * Fired once the view **begins loading**, *before* the DOM is rendered.\n         *\n         * @param {Object} event Event object.\n         * @param {Object} viewConfig The view config properties (template, controller, etc).\n         *\n         * @example\n         *\n         * <pre>\n         * $scope.$on('$viewContentLoading',\n         * function(event, viewConfig){\n         *     // Access to all the view config properties.\n         *     // and one special property 'targetView'\n         *     // viewConfig.targetView\n         * });\n         * </pre>\n         */\n          $rootScope.$broadcast('$viewContentLoading', options);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} ui-view A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = function() {\n      return {\n        enter: function (element, target, cb) { target.after(element); cb(); },\n        leave: function (element, cb) { element.remove(); cb(); }\n      };\n    };\n\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) { $animate.enter(element, null, target, cb); },\n        leave: function(element, cb) { $animate.leave(element, cb); }\n      };\n    }\n\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics();\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n        scope.$on('$viewContentLoading', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          if (previousEl) {\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(attrs, $element.inheritedData('$uiView')),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description           *\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           */\n          currentScope.$emit('$viewContentLoaded');\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state'];\nfunction $ViewDirectiveFill ($compile, $controller, $state) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(attrs, $element.inheritedData('$uiView')),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given attributes and inherited $uiView data, return the view's name\n */\nfunction getUiViewName(attrs, inherited) {\n  var name = attrs.uiView || attrs.name || '';\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated \n * URL, the directive will automatically generate & update the `href` attribute via \n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking \n * the link will trigger a state transition with optional parameters. \n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be \n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative \n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the \n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the \n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n * \n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  var allowedOptions = ['location', 'inherit', 'reload'];\n\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref = parseStateRef(attrs.uiSref, $state.current.name);\n      var params = null, url = null, base = stateContext(element) || $state.$current;\n      var isForm = element[0].nodeName === \"FORM\";\n      var attr = isForm ? \"action\" : \"href\", nav = true;\n\n      var options = { relative: base, inherit: true };\n      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};\n\n      angular.forEach(allowedOptions, function(option) {\n        if (option in optionsOverride) {\n          options[option] = optionsOverride[option];\n        }\n      });\n\n      var update = function(newVal) {\n        if (newVal) params = newVal;\n        if (!nav) return;\n\n        var newHref = $state.href(ref.state, params, options);\n\n        var activeDirective = uiSrefActive[1] || uiSrefActive[0];\n        if (activeDirective) {\n          activeDirective.$$setStateInfo(ref.state, params);\n        }\n        if (newHref === null) {\n          nav = false;\n          return false;\n        }\n        element[0][attr] = newHref;\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(newVal, oldVal) {\n          if (newVal !== params) update(newVal);\n        }, true);\n        params = scope.$eval(ref.paramExpr);\n      }\n      update();\n\n      if (isForm) return;\n\n      element.bind(\"click\", function(e) {\n        var button = e.which || e.button;\n        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {\n          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n          var transition = $timeout(function() {\n            $state.go(ref.state, params, options);\n          });\n          e.preventDefault();\n\n          e.preventDefault = function() {\n            $timeout.cancel(transition);\n          };\n        }\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n      var state, params, activeClass;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$setStateInfo = function (newState, newParams) {\n        state = $state.get(newState, stateContext($element));\n        params = newParams;\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      // Update route state\n      function update() {\n        if (isMatch()) {\n          $element.addClass(activeClass);\n        } else {\n          $element.removeClass(activeClass);\n        }\n      }\n\n      function isMatch() {\n        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {\n          return $state.$current.self === state && matchesParams();\n        } else {\n          return $state.includes(state.name) && matchesParams();\n        }\n      }\n\n      function matchesParams() {\n        return !params || equalForKeys(params, $stateParams);\n      }\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  return function(state) {\n    return $state.is(state);\n  };\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  return function(state) {\n    return $state.includes(state);\n  };\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router/release/angular-ui-router.js\n ** module id = 4\n ** module chunks = 0\n **/","( ->\n  require \"angular-ui-router\"\n  require \"angular-busy/dist/angular-busy.min.css\"\n  require \"angular-busy/dist/angular-busy.min.js\"\n  require(\"angular-bootstrap/ui-bootstrap.js\")\n  require(\"angular-bootstrap/ui-bootstrap-tpls.js\")\n  \n  angular.module(\"SirenBrowser\", [\"ui.bootstrap\", \"ui.router\", \"cgBusy\"]).config [\n    \"$stateProvider\"\n    \"$urlRouterProvider\"\n    ($stateProvider, $urlRouterProvider) ->\n      $urlRouterProvider.otherwise('/siren-browser')\n      $stateProvider.state \"siren-browser\",\n        url: \"/siren-browser?url?cached\"\n        controller: \"showCtrl as showCtrl\"\n        template: require(\"./templates/show.jade\")\n        resolve:\n          sirenEntity:[\n            'entityResolver'\n            '$rootScope'\n            '$stateParams'\n            (entityResolver,$rootScope, $stateParams) ->\n              entityResolver.resolve($stateParams.url)\n            ]\n  ]\n\n  require \"./controllers/showCtrl.coffee\"\n  require \"./directives/actionForm.coffee\"\n  require \"./services/entityResolver.coffee\"\n  require \"./services/sirenBrowserHttp.coffee\"\n)()\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/siren-browser/siren-browser.coffee\n **/","'use strict';\r\n\r\n/**\r\n * Merge two attribute objects giving precedence\r\n * to values in object `b`. Classes are special-cased\r\n * allowing for arrays and merging/joining appropriately\r\n * resulting in a string.\r\n *\r\n * @param {Object} a\r\n * @param {Object} b\r\n * @return {Object} a\r\n * @api private\r\n */\r\n\r\nexports.merge = function merge(a, b) {\r\n  if (arguments.length === 1) {\r\n    var attrs = a[0];\r\n    for (var i = 1; i < a.length; i++) {\r\n      attrs = merge(attrs, a[i]);\r\n    }\r\n    return attrs;\r\n  }\r\n  var ac = a['class'];\r\n  var bc = b['class'];\r\n\r\n  if (ac || bc) {\r\n    ac = ac || [];\r\n    bc = bc || [];\r\n    if (!Array.isArray(ac)) ac = [ac];\r\n    if (!Array.isArray(bc)) bc = [bc];\r\n    a['class'] = ac.concat(bc).filter(nulls);\r\n  }\r\n\r\n  for (var key in b) {\r\n    if (key != 'class') {\r\n      a[key] = b[key];\r\n    }\r\n  }\r\n\r\n  return a;\r\n};\r\n\r\n/**\r\n * Filter null `val`s.\r\n *\r\n * @param {*} val\r\n * @return {Boolean}\r\n * @api private\r\n */\r\n\r\nfunction nulls(val) {\r\n  return val != null && val !== '';\r\n}\r\n\r\n/**\r\n * join array as classes.\r\n *\r\n * @param {*} val\r\n * @return {String}\r\n */\r\nexports.joinClasses = joinClasses;\r\nfunction joinClasses(val) {\r\n  return Array.isArray(val) ? val.map(joinClasses).filter(nulls).join(' ') : val;\r\n}\r\n\r\n/**\r\n * Render the given classes.\r\n *\r\n * @param {Array} classes\r\n * @param {Array.<Boolean>} escaped\r\n * @return {String}\r\n */\r\nexports.cls = function cls(classes, escaped) {\r\n  var buf = [];\r\n  for (var i = 0; i < classes.length; i++) {\r\n    if (escaped && escaped[i]) {\r\n      buf.push(exports.escape(joinClasses([classes[i]])));\r\n    } else {\r\n      buf.push(joinClasses(classes[i]));\r\n    }\r\n  }\r\n  var text = joinClasses(buf);\r\n  if (text.length) {\r\n    return ' class=\"' + text + '\"';\r\n  } else {\r\n    return '';\r\n  }\r\n};\r\n\r\n/**\r\n * Render the given attribute.\r\n *\r\n * @param {String} key\r\n * @param {String} val\r\n * @param {Boolean} escaped\r\n * @param {Boolean} terse\r\n * @return {String}\r\n */\r\nexports.attr = function attr(key, val, escaped, terse) {\r\n  if ('boolean' == typeof val || null == val) {\r\n    if (val) {\r\n      return ' ' + (terse ? key : key + '=\"' + key + '\"');\r\n    } else {\r\n      return '';\r\n    }\r\n  } else if (0 == key.indexOf('data') && 'string' != typeof val) {\r\n    return ' ' + key + \"='\" + JSON.stringify(val).replace(/'/g, '&apos;') + \"'\";\r\n  } else if (escaped) {\r\n    return ' ' + key + '=\"' + exports.escape(val) + '\"';\r\n  } else {\r\n    return ' ' + key + '=\"' + val + '\"';\r\n  }\r\n};\r\n\r\n/**\r\n * Render the given attributes object.\r\n *\r\n * @param {Object} obj\r\n * @param {Object} escaped\r\n * @return {String}\r\n */\r\nexports.attrs = function attrs(obj, terse){\r\n  var buf = [];\r\n\r\n  var keys = Object.keys(obj);\r\n\r\n  if (keys.length) {\r\n    for (var i = 0; i < keys.length; ++i) {\r\n      var key = keys[i]\r\n        , val = obj[key];\r\n\r\n      if ('class' == key) {\r\n        if (val = joinClasses(val)) {\r\n          buf.push(' ' + key + '=\"' + val + '\"');\r\n        }\r\n      } else {\r\n        buf.push(exports.attr(key, val, false, terse));\r\n      }\r\n    }\r\n  }\r\n\r\n  return buf.join('');\r\n};\r\n\r\n/**\r\n * Escape the given string of `html`.\r\n *\r\n * @param {String} html\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.escape = function escape(html){\r\n  var result = String(html)\r\n    .replace(/&/g, '&amp;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\"/g, '&quot;');\r\n  if (result === '' + html) return html;\r\n  else return result;\r\n};\r\n\r\n/**\r\n * Re-throw the given `err` in context to the\r\n * the jade in `filename` at the given `lineno`.\r\n *\r\n * @param {Error} err\r\n * @param {String} filename\r\n * @param {String} lineno\r\n * @api private\r\n */\r\n\r\nexports.rethrow = function rethrow(err, filename, lineno, str){\r\n  if (!(err instanceof Error)) throw err;\r\n  if ((typeof window != 'undefined' || !filename) && !str) {\r\n    err.message += ' on line ' + lineno;\r\n    throw err;\r\n  }\r\n  try {\r\n    str = str || require('fs').readFileSync(filename, 'utf8')\r\n  } catch (ex) {\r\n    rethrow(err, null, lineno)\r\n  }\r\n  var context = 3\r\n    , lines = str.split('\\n')\r\n    , start = Math.max(lineno - context, 0)\r\n    , end = Math.min(lines.length, lineno + context);\r\n\r\n  // Error context\r\n  var context = lines.slice(start, end).map(function(line, i){\r\n    var curr = i + start + 1;\r\n    return (curr == lineno ? '  > ' : '    ')\r\n      + curr\r\n      + '| '\r\n      + line;\r\n  }).join('\\n');\r\n\r\n  // Alter exception message\r\n  err.path = filename;\r\n  err.message = (filename || 'Jade') + ':' + lineno\r\n    + '\\n' + context + '\\n\\n' + err.message;\r\n  throw err;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jade/lib/runtime.js\n ** module id = 6\n ** module chunks = 0\n **/","var jade = require(\"/home/travis/build/applicaster/siren-browser/node_modules/jade/lib/runtime.js\");\n\nmodule.exports = function template(locals) {\nvar buf = [];\nvar jade_mixins = {};\nvar jade_interp;\n\nbuf.push(\"<div class=\\\"row\\\"><div class=\\\"col-md-12\\\"><form class=\\\"form-horizontal\\\"><div class=\\\"form-group\\\"><label for=\\\"url\\\" class=\\\"col-sm-2 control-label\\\">Entity URI:</label><div class=\\\"col-sm-8\\\"><input id=\\\"url\\\" type=\\\"text\\\" ng-model=\\\"showCtrl.url\\\" class=\\\"form-control\\\"/></div><div class=\\\"col-sm-1\\\"><button ui-sref=\\\"siren-browser({url:showCtrl.url})\\\" class=\\\"form-control btn btn-primary\\\">Go</button></div></div></form></div></div><div class=\\\"row\\\"><div class=\\\"col-md-8 col-md-offset-2\\\"><alert ng-repeat=\\\"alert in alerts\\\" type=\\\"{{alert.type}}\\\" close=\\\"alerts.splice(index, 1)\\\">{{alert.msg}}</alert></div></div><div id=\\\"response\\\" class=\\\"row\\\"><div class=\\\"col-md-4\\\"><div id=\\\"class\\\" ng-show=\\\"showCtrl.class\\\"><h3>Class</h3><pre>{{showCtrl.class}}</pre></div><div id=\\\"properties\\\" ng-show=\\\"showCtrl.properties\\\"><h3>Properties</h3><pre>{{showCtrl.properties | prettify}}</pre></div><div id=\\\"links\\\" ng-show=\\\"showCtrl.links.length\\\"><h3>Links</h3><ul><li ng-repeat=\\\"link in showCtrl.links\\\"><a href=\\\"#/siren-browser?url={{ link.href | encodeURIComponent }}\\\">{{link.rel}}</a></li></ul></div></div><div class=\\\"col-md-6\\\"><div id=\\\"actions\\\" ng-show=\\\"showCtrl.actions.length\\\"><h3>Actions</h3><accordion close-others=\\\"true\\\"><accordion-group ng-repeat=\\\"action in showCtrl.actions\\\" is-open=\\\"$first\\\"><accordion-heading><span ng-show=\\\"action.title\\\">{{action.title}}</span><span ng-show=\\\"!action.title\\\">{{action.name}}</span></accordion-heading><tabset><tab heading=\\\"Form\\\"><action-form ng-model=\\\"action\\\"></action-form></tab><tab heading=\\\"Source\\\"><pre>| {{ action | prettify }}</pre></tab></tabset></accordion-group></accordion></div><div id=\\\"entities\\\" ng-show=\\\"showCtrl.entities.length\\\"><h3>Entities</h3><div><label class=\\\"checkbox\\\"><input id=\\\"oneAtATime\\\" type=\\\"checkbox\\\" ng-model=\\\"isOneAtATime\\\"/>Open only one at a time</label></div><br/><accordion close-others=\\\"isOneAtATime\\\"><accordion-group ng-repeat=\\\"entity in showCtrl.entities\\\" heading=\\\"class: {{entity.class}}\\\" is-open=\\\"$first\\\"><div ng-show=\\\"entity.properties\\\"><h4>Properties</h4><pre>{{entity.properties | prettify}}</pre></div><div ng-show=\\\"entity.links\\\"><h4>Links</h4><ul><li ng-repeat=\\\"link in entity.links\\\"><a ui-sref=\\\"siren-browser({url:link.href})\\\">{{link.rel}}</a></li></ul></div><div ng-show=\\\"entity.href\\\">href:<a ui-sref=\\\"siren-browser({url:entity.href})\\\">{{entity.href}}</a></div><div ng-show=\\\"entity.actions\\\"><h4>Actions</h4><div class=\\\"btn-group-vertical\\\"><button ng-repeat=\\\"action in entity.actions\\\" ng-click=\\\"showCtrl.openActionModal(action)\\\" class=\\\"btn btn-default\\\">Action {{action.name}}</button></div></div></accordion-group></accordion></div></div></div>\");;return buf.join(\"\");\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/modules/siren-browser/templates/show.jade\n ** module id = 7\n ** module chunks = 0\n **/","(->\n  require \"../siren-browser.coffee\"\n  require \"./actionModalCtrl.coffee\"\n  showCtrl = ($scope, $stateParams, $rootScope, sirenEntity, $modal) ->\n    # Reset Alerts\n    $rootScope.alerts = []\n    @url = $stateParams.url\n    @actions = sirenEntity.data.actions\n    @class = sirenEntity.data.class\n    @properties = sirenEntity.data.properties\n    @links = sirenEntity.data.links\n    @entities = sirenEntity.data.entities\n    @openActionModal = (action) ->\n      modalInstance = $modal.open\n        template: require(\"../templates/actionModal.jade\")\n        controller: 'actionModalCtrl as actionModalCtrl'\n        resolve:\n          action: () ->\n            action\n        size: 'lg'\n    return\n\n  angular.module(\"SirenBrowser\").controller(\"showCtrl\", [\n    '$scope'\n    '$stateParams'\n    '$rootScope'\n    'sirenEntity'\n    '$modal'\n    showCtrl\n  ])\n)()\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/siren-browser/controllers/showCtrl.coffee\n **/","(->\n  actionForm = () ->\n    restrict: 'E',\n    template: require(\"../templates/action-form.jade\")\n    require: \"ngModel\"\n    scope:\n      action: '=ngModel'\n    controller: \"actionFromCtrl as actionFromCtrl\"\n  require \"../controllers/actionFromCtrl.coffee\"\n  angular.module(\"SirenBrowser\").directive(\"actionForm\", actionForm)\n)()\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/siren-browser/directives/actionForm.coffee\n **/","(->\n  require \"../siren-browser.coffee\"\n  entityResolver = ($rootScope, sirenBrowserHttp) ->\n    class EntityResolverClass\n      constructor: () ->\n        @cachedEntity = null\n      cacheEntity: (entity) ->\n        @cachedEntity = entity\n      resolve: (url) ->\n        if (entity = @cachedEntity)\n          @cachedEntity = null\n          entity\n        else\n          if (url)\n            sirenBrowserHttp.request({method: 'GET', url: url})\n          else\n            {data:{}}\n    new EntityResolverClass\n\n  angular.module('SirenBrowser')\n    .service \"entityResolver\", [\n      '$rootScope'\n      'sirenBrowserHttp'\n      entityResolver\n    ]\n)()\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/siren-browser/services/entityResolver.coffee\n **/","(->\n  require \"../siren-browser.coffee\"\n  sirenBrowserHttp = ($rootScope, $http) ->\n    class SirenBrowserHttpClass\n      constructor: () ->\n      request: (options) ->\n        $rootScope.myPromise = $http(options)\n        .error (data, status) ->\n          msg = 'HTTP Error ' + status + ': ' + JSON.stringify(data.properties)\n          $rootScope.alerts = []\n          $rootScope.alerts.push(\n            { type: 'danger', msg: msg }\n          )\n          console.log(\"error in get  status=\"+status, data.properties)\n          return\n    new SirenBrowserHttpClass\n\n  angular.module('SirenBrowser')\n    .service \"sirenBrowserHttp\", [\n      '$rootScope'\n      '$http'\n      sirenBrowserHttp\n    ]\n)()\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/siren-browser/services/sirenBrowserHttp.coffee\n **/","angular.module(\"cgBusy\",[]),angular.module(\"cgBusy\").factory(\"_cgBusyTrackerFactory\",[\"$timeout\",\"$q\",function(a,b){return function(){var c={};c.promises=[],c.delayPromise=null,c.durationPromise=null,c.delayJustFinished=!1,c.reset=function(b){c.minDuration=b.minDuration,c.promises=[],angular.forEach(b.promises,function(a){a&&!a.$cgBusyFulfilled&&d(a)}),0!==c.promises.length&&(c.delayJustFinished=!1,b.delay&&(c.delayPromise=a(function(){c.delayPromise=null,c.delayJustFinished=!0},parseInt(b.delay,10))),b.minDuration&&(c.durationPromise=a(function(){c.durationPromise=null},parseInt(b.minDuration,10)+(b.delay?parseInt(b.delay,10):0))))},c.getThen=function(a){var c=a&&(a.then||a.$then||a.$promise&&a.$promise.then);return a.denodeify?b.when(a).then:c};var d=function(a){var b=c.getThen(a);if(!b)throw new Error(\"cgBusy expects a promise (or something that has a .promise or .$promise\");-1===c.promises.indexOf(a)&&(c.promises.push(a),b(function(){a.$cgBusyFulfilled=!0,-1!==c.promises.indexOf(a)&&c.promises.splice(c.promises.indexOf(a),1)},function(){a.$cgBusyFulfilled=!0,-1!==c.promises.indexOf(a)&&c.promises.splice(c.promises.indexOf(a),1)}))};return c.active=function(){return c.delayPromise?!1:c.delayJustFinished?(c.delayJustFinished=!1,c.promises.length>0):c.durationPromise?!0:c.promises.length>0},c}}]),angular.module(\"cgBusy\").value(\"cgBusyDefaults\",{}),angular.module(\"cgBusy\").directive(\"cgBusy\",[\"$compile\",\"$templateCache\",\"cgBusyDefaults\",\"$http\",\"_cgBusyTrackerFactory\",function(a,b,c,d,e){return{restrict:\"A\",link:function(f,g,h){var i=g.css(\"position\");(\"static\"===i||\"\"===i||\"undefined\"==typeof i)&&g.css(\"position\",\"relative\");var j,k,l,m,n,o=e(),p={templateUrl:\"angular-busy.html\",delay:0,minDuration:0,backdrop:!0,message:\"Please Wait...\"};angular.extend(p,c),f.$watchCollection(h.cgBusy,function(c){if(c||(c={promise:null}),angular.isString(c))throw new Error(\"Invalid value for cg-busy.  cgBusy no longer accepts string ids to represent promises/trackers.\");(angular.isArray(c)||o.getThen(c))&&(c={promise:c}),c=angular.extend(angular.copy(p),c),c.templateUrl||(c.templateUrl=p.templateUrl),angular.isArray(c.promise)||(c.promise=[c.promise]),m||(m=f.$new()),m.$message=c.message,angular.equals(o.promises,c.promise)||o.reset({promises:c.promise,delay:c.delay,minDuration:c.minDuration}),m.$cgBusyIsActive=function(){return o.active()},j&&l===c.templateUrl&&n===c.backdrop||(j&&j.remove(),k&&k.remove(),l=c.templateUrl,n=c.backdrop,d.get(l,{cache:b}).success(function(b){if(c.backdrop=\"undefined\"==typeof c.backdrop?!0:c.backdrop,c.backdrop){var d='<div class=\"cg-busy cg-busy-backdrop cg-busy-backdrop-animation ng-hide\" ng-show=\"$cgBusyIsActive()\"></div>';k=a(d)(m),g.append(k)}var e='<div class=\"cg-busy cg-busy-animation ng-hide\" ng-show=\"$cgBusyIsActive()\">'+b+\"</div>\";j=a(e)(m),angular.element(j.children()[0]).css(\"position\",\"absolute\").css(\"top\",0).css(\"left\",0).css(\"right\",0).css(\"bottom\",0),g.append(j)}).error(function(a){throw new Error(\"Template specified for cgBusy (\"+c.templateUrl+\") could not be loaded. \"+a)}))},!0)}}}]),angular.module(\"cgBusy\").run([\"$templateCache\",function(a){\"use strict\";a.put(\"angular-busy.html\",'<div class=\"cg-busy-default-wrapper\">\\n\\n   <div class=\"cg-busy-default-sign\">\\n\\n      <div class=\"cg-busy-default-spinner\">\\n         <div class=\"bar1\"></div>\\n         <div class=\"bar2\"></div>\\n         <div class=\"bar3\"></div>\\n         <div class=\"bar4\"></div>\\n         <div class=\"bar5\"></div>\\n         <div class=\"bar6\"></div>\\n         <div class=\"bar7\"></div>\\n         <div class=\"bar8\"></div>\\n         <div class=\"bar9\"></div>\\n         <div class=\"bar10\"></div>\\n         <div class=\"bar11\"></div>\\n         <div class=\"bar12\"></div>\\n      </div>\\n\\n      <div class=\"cg-busy-default-text\">{{$message}}</div>\\n\\n   </div>\\n\\n</div>')}]);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/angular-busy/dist/angular-busy.min.js\n ** module id = 12\n ** module chunks = 0\n **/","(->\n  require \"../siren-browser.coffee\"\n  actionModalCtrl = ($scope, $modalInstance, action) ->\n    @action = action\n    @close = ->\n      $modalInstance.dismiss('cancel');\n    return\n  angular.module(\"SirenBrowser\").controller(\"actionModalCtrl\", [\n    '$scope'\n    '$modalInstance'\n    'action'\n    actionModalCtrl\n  ])\n)()\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/siren-browser/controllers/actionModalCtrl.coffee\n **/","var jade = require(\"/home/travis/build/applicaster/siren-browser/node_modules/jade/lib/runtime.js\");\n\nmodule.exports = function template(locals) {\nvar buf = [];\nvar jade_mixins = {};\nvar jade_interp;\n\nbuf.push(\"<div class=\\\"modal-header\\\"><h3 class=\\\"modal-title\\\">{{actionModalCtrl.action.name}}</h3></div><div class=\\\"modal-body\\\"><tabset><tab heading=\\\"Form\\\"><action-form ng-model=\\\"actionModalCtrl.action\\\"></action-form></tab><tab heading=\\\"Source\\\"><pre>| {{ actionModalCtrl.action | prettify }}</pre></tab></tabset></div>\");;return buf.join(\"\");\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/modules/siren-browser/templates/actionModal.jade\n ** module id = 14\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!/home/travis/build/applicaster/siren-browser/node_modules/css-loader/index.js!/home/travis/build/applicaster/siren-browser/bower_components/angular-busy/dist/angular-busy.min.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!/home/travis/build/applicaster/siren-browser/node_modules/style-loader/addStyles.js\")(content);\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tmodule.hot.accept(\"!!/home/travis/build/applicaster/siren-browser/node_modules/css-loader/index.js!/home/travis/build/applicaster/siren-browser/bower_components/angular-busy/dist/angular-busy.min.css\", function() {\n\t\tvar newContent = require(\"!!/home/travis/build/applicaster/siren-browser/node_modules/css-loader/index.js!/home/travis/build/applicaster/siren-browser/bower_components/angular-busy/dist/angular-busy.min.css\");\n\t\tif(typeof newContent === 'string') newContent = [module.id, newContent, ''];\n\t\tupdate(newContent);\n\t});\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/angular-busy/dist/angular-busy.min.css\n ** module id = 15\n ** module chunks = 0\n **/","exports = module.exports = require(\"/home/travis/build/applicaster/siren-browser/node_modules/css-loader/cssToString.js\")();\nexports.push([module.id, \".cg-busy{position:absolute;top:0;left:0;right:0;bottom:0;z-index:1001}.cg-busy-animation.ng-hide-add,.cg-busy-animation.ng-hide-remove{-webkit-transition:all .3s ease;-moz-transition:all .3s ease;-o-transition:all .3s ease;transition:all .3s ease;display:block!important}.cg-busy-animation.ng-hide-remove{opacity:0;-webkit-transform:translate(0,-40px);-moz-transform:translate(0,-40px);-ms-transform:translate(0,-40px);-o-transform:translate(0,-40px);transform:translate(0,-40px)}.cg-busy-animation.ng-hide-add,.cg-busy-animation.ng-hide-remove.ng-hide-remove-active{opacity:1;-webkit-transform:translate(0,0);-moz-transform:translate(0,0);-ms-transform:translate(0,0);-o-transform:translate(0,0);transform:translate(0,0)}.cg-busy-animation.ng-hide-add.ng-hide-add-active{opacity:0;-webkit-transform:translate(0,-40px);-moz-transform:translate(0,-40px);-ms-transform:translate(0,-40px);-o-transform:translate(0,-40px);transform:translate(0,-40px)}.cg-busy-backdrop{background-color:#fff;opacity:.7}.cg-busy-backdrop-animation.ng-hide-add,.cg-busy-backdrop-animation.ng-hide-remove{-webkit-transition:opacity .3s ease;-moz-transition:opacity .3s ease;-o-transition:opacity .3s ease;transition:opacity .3s ease;display:block!important}.cg-busy-backdrop-animation.ng-hide{opacity:0}.cg-busy-default-wrapper{text-align:center}.cg-busy-default-sign{display:inline-block;position:relative;z-index:1002;padding-bottom:6px;color:#333;text-shadow:0 1px 1px rgba(255,255,255,.75);background-color:#e9eeee;border:1px solid #ddd;border-top-width:0;-webkit-border-radius:7px;-moz-border-radius:7px;border-radius:7px;border-top-left-radius:0;border-top-right-radius:0;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05);box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05)}.cg-busy-default-text{margin:13px 12px 6px 49px;font-size:16px;color:#555;text-align:left;max-width:400px}.cg-busy-default-spinner{position:absolute;width:25px;height:25px;display:inline-block;top:12px;left:14px}.cg-busy-default-spinner div{width:12%;height:26%;background:#000;position:absolute;left:44.5%;top:37%;opacity:0;-webkit-animation:cg-busy-spinner-anim 1s linear infinite;-moz-animation:cg-busy-spinner-anim 1s linear infinite;-ms-animation:cg-busy-spinner-anim 1s linear infinite;-o-animation:cg-busy-spinner-anim 1s linear infinite;animation:cg-busy-spinner-anim 1s linear infinite;-webkit-border-radius:50px;-moz-border-radius:50px;border-radius:50px;-webkit-box-shadow:0 0 3px rgba(0,0,0,.2);-moz-box-shadow:0 0 3px rgba(0,0,0,.2);box-shadow:0 0 3px rgba(0,0,0,.2)}.cg-busy-default-spinner div.bar1{-webkit-transform:rotate(0)translate(0,-142%);-moz-transform:rotate(0)translate(0,-142%);-ms-transform:rotate(0)translate(0,-142%);-o-transform:rotate(0)translate(0,-142%);transform:rotate(0)translate(0,-142%);-webkit-animation-delay:0;-moz-animation-delay:0;-ms-animation-delay:0;-o-animation-delay:0;animation-delay:0}.cg-busy-default-spinner div.bar2{-webkit-transform:rotate(30deg)translate(0,-142%);-moz-transform:rotate(30deg)translate(0,-142%);-ms-transform:rotate(30deg)translate(0,-142%);-o-transform:rotate(30deg)translate(0,-142%);transform:rotate(30deg)translate(0,-142%);-webkit-animation-delay:-.9167s;-moz-animation-delay:-.9167s;-ms-animation-delay:-.9167s;-o-animation-delay:-.9167s;animation-delay:-.9167s}.cg-busy-default-spinner div.bar3{-webkit-transform:rotate(60deg)translate(0,-142%);-moz-transform:rotate(60deg)translate(0,-142%);-ms-transform:rotate(60deg)translate(0,-142%);-o-transform:rotate(60deg)translate(0,-142%);transform:rotate(60deg)translate(0,-142%);-webkit-animation-delay:-.833s;-moz-animation-delay:-.833s;-ms-animation-delay:-.833s;-o-animation-delay:-.833s;animation-delay:-.833s}.cg-busy-default-spinner div.bar4{-webkit-transform:rotate(90deg)translate(0,-142%);-moz-transform:rotate(90deg)translate(0,-142%);-ms-transform:rotate(90deg)translate(0,-142%);-o-transform:rotate(90deg)translate(0,-142%);transform:rotate(90deg)translate(0,-142%);-webkit-animation-delay:-.75s;-moz-animation-delay:-.75s;-ms-animation-delay:-.75s;-o-animation-delay:-.75s;animation-delay:-.75s}.cg-busy-default-spinner div.bar5{-webkit-transform:rotate(120deg)translate(0,-142%);-moz-transform:rotate(120deg)translate(0,-142%);-ms-transform:rotate(120deg)translate(0,-142%);-o-transform:rotate(120deg)translate(0,-142%);transform:rotate(120deg)translate(0,-142%);-webkit-animation-delay:-.667s;-moz-animation-delay:-.667s;-ms-animation-delay:-.667s;-o-animation-delay:-.667s;animation-delay:-.667s}.cg-busy-default-spinner div.bar6{-webkit-transform:rotate(150deg)translate(0,-142%);-moz-transform:rotate(150deg)translate(0,-142%);-ms-transform:rotate(150deg)translate(0,-142%);-o-transform:rotate(150deg)translate(0,-142%);transform:rotate(150deg)translate(0,-142%);-webkit-animation-delay:-.5833s;-moz-animation-delay:-.5833s;-ms-animation-delay:-.5833s;-o-animation-delay:-.5833s;animation-delay:-.5833s}.cg-busy-default-spinner div.bar7{-webkit-transform:rotate(180deg)translate(0,-142%);-moz-transform:rotate(180deg)translate(0,-142%);-ms-transform:rotate(180deg)translate(0,-142%);-o-transform:rotate(180deg)translate(0,-142%);transform:rotate(180deg)translate(0,-142%);-webkit-animation-delay:-.5s;-moz-animation-delay:-.5s;-ms-animation-delay:-.5s;-o-animation-delay:-.5s;animation-delay:-.5s}.cg-busy-default-spinner div.bar8{-webkit-transform:rotate(210deg)translate(0,-142%);-moz-transform:rotate(210deg)translate(0,-142%);-ms-transform:rotate(210deg)translate(0,-142%);-o-transform:rotate(210deg)translate(0,-142%);transform:rotate(210deg)translate(0,-142%);-webkit-animation-delay:-.41667s;-moz-animation-delay:-.41667s;-ms-animation-delay:-.41667s;-o-animation-delay:-.41667s;animation-delay:-.41667s}.cg-busy-default-spinner div.bar9{-webkit-transform:rotate(240deg)translate(0,-142%);-moz-transform:rotate(240deg)translate(0,-142%);-ms-transform:rotate(240deg)translate(0,-142%);-o-transform:rotate(240deg)translate(0,-142%);transform:rotate(240deg)translate(0,-142%);-webkit-animation-delay:-.333s;-moz-animation-delay:-.333s;-ms-animation-delay:-.333s;-o-animation-delay:-.333s;animation-delay:-.333s}.cg-busy-default-spinner div.bar10{-webkit-transform:rotate(270deg)translate(0,-142%);-moz-transform:rotate(270deg)translate(0,-142%);-ms-transform:rotate(270deg)translate(0,-142%);-o-transform:rotate(270deg)translate(0,-142%);transform:rotate(270deg)translate(0,-142%);-webkit-animation-delay:-.25s;-moz-animation-delay:-.25s;-ms-animation-delay:-.25s;-o-animation-delay:-.25s;animation-delay:-.25s}.cg-busy-default-spinner div.bar11{-webkit-transform:rotate(300deg)translate(0,-142%);-moz-transform:rotate(300deg)translate(0,-142%);-ms-transform:rotate(300deg)translate(0,-142%);-o-transform:rotate(300deg)translate(0,-142%);transform:rotate(300deg)translate(0,-142%);-webkit-animation-delay:-.1667s;-moz-animation-delay:-.1667s;-ms-animation-delay:-.1667s;-o-animation-delay:-.1667s;animation-delay:-.1667s}.cg-busy-default-spinner div.bar12{-webkit-transform:rotate(330deg)translate(0,-142%);-moz-transform:rotate(330deg)translate(0,-142%);-ms-transform:rotate(330deg)translate(0,-142%);-o-transform:rotate(330deg)translate(0,-142%);transform:rotate(330deg)translate(0,-142%);-webkit-animation-delay:-.0833s;-moz-animation-delay:-.0833s;-ms-animation-delay:-.0833s;-o-animation-delay:-.0833s;animation-delay:-.0833s}@-webkit-keyframes cg-busy-spinner-anim{from{opacity:1}to{opacity:.25}}@-moz-keyframes cg-busy-spinner-anim{from{opacity:1}to{opacity:.25}}@keyframes cg-busy-spinner-anim{from{opacity:1}to{opacity:.25}}\", \"\"]);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./bower_components/angular-busy/dist/angular-busy.min.css\n ** module id = 16\n ** module chunks = 0\n **/","var jade = require(\"/home/travis/build/applicaster/siren-browser/node_modules/jade/lib/runtime.js\");\n\nmodule.exports = function template(locals) {\nvar buf = [];\nvar jade_mixins = {};\nvar jade_interp;\n\nbuf.push(\"<form ng-submit=\\\"actionFromCtrl.submit(action); $parent.$close()\\\"><div ng-repeat=\\\"field in action.fields\\\"><div ng-if=\\\"field.type == 'checkbox' || field.type == 'radio'\\\" class=\\\"form-group\\\"><label>{{field.title}}</label><div ng-repeat=\\\"option in field.value\\\" class=\\\"checkbox radio\\\"><label><input type=\\\"{{field.type}}\\\" name=\\\"{{field.name}}\\\" value=\\\"{{option.value}}\\\" ng-checked=\\\"option.selected\\\"/>{{option.title}}</label></div></div><div ng-if=\\\"field.type != 'checkbox'  &amp;&amp; field.type != 'radio'\\\" class=\\\"form-group\\\"><label ng-if=\\\"field.type != 'hidden'\\\">{{field.title}}</label><input type=\\\"{{field.type}}\\\" name=\\\"{{field.name}}\\\" value=\\\"{{field.value}}\\\" class=\\\"form-control\\\"/></div></div><input type=\\\"submit\\\" class=\\\"btn btn-primary\\\"/></form>\");;return buf.join(\"\");\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/modules/siren-browser/templates/action-form.jade\n ** module id = 17\n ** module chunks = 0\n **/","(->\n  require(\"../services/actionsUtils.coffee\")\n  require(\"../services/entityResolver.coffee\")\n  actionFromCtrl = (\n    $scope\n    $element\n    sirenBrowserHttp\n    $state\n    $rootScope\n    entityResolver\n    actionsUtils\n  ) ->\n    # Public: submits action data to a siren API request.\n    #\n    # action - action metadat and values to send.\n    #\n    # returns nothing.\n    @submit = (action) ->\n      formData = $element.find(\"form\").serialize()\n      options = actionsUtils.renderOptions(action, formData)\n      $rootScope.entityUrl = options.url\n      sirenBrowserHttp.request(options)\n      .success((data) ->\n        entityResolver.cacheEntity(data: data)\n        url = $rootScope.entityUrl\n        options =\n          notify: true\n          reload: true\n        $state.go('siren-browser', {url: url}, options)\n      )\n    return\n\n  angular.module(\"SirenBrowser\").controller(\"actionFromCtrl\", [\n    '$scope'\n    '$element'\n    'sirenBrowserHttp'\n    '$state'\n    '$rootScope'\n    'entityResolver'\n    'actionsUtils'\n    actionFromCtrl\n  ])\n)()\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/siren-browser/controllers/actionFromCtrl.coffee\n **/","console.log(\"I'm `fs` modules\");\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fs/index.js\n ** module id = 19\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {};\r\n\r\nmodule.exports = function(list) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles);\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j]));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j]));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\t// var sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media/*, sourceMap: sourceMap*/};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction addStyle(obj) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tvar head = document.head || document.getElementsByTagName(\"head\")[0];\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\tapplyToTag(styleElement, obj);\r\n\treturn function(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media /*&& newObj.sourceMap === obj.sourceMap*/)\r\n\t\t\t\treturn;\r\n\t\t\tapplyToTag(styleElement, obj = newObj);\r\n\t\t} else {\r\n\t\t\thead.removeChild(styleElement);\r\n\t\t}\r\n\t};\r\n};\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\t// var sourceMap = obj.sourceMap;\r\n\r\n\t// No browser support\r\n\t// if(sourceMap && typeof btoa === \"function\") {\r\n\t\t// try {\r\n\t\t\t// css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(JSON.stringify(sourceMap)) + \" */\";\r\n\t\t// } catch(e) {}\r\n\t// }\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 20\n ** module chunks = 0\n **/","module.exports = function() {\r\n\tvar list = [];\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\treturn list;\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/cssToString.js\n ** module id = 21\n ** module chunks = 0\n **/","(->\n  require \"../siren-browser.coffee\"\n  require \"jquery.ba-bbq\"\n  actionsUtils = () ->\n\n    # Public: Resolve form enctype and use application/x-www-form-urlencoded\n    # and use 'application/x-www-form-urlencoded' as default\n    # See http://www.w3.org/TR/html401/interact/forms.html#adef-enctype.\n    #\n    # enctype - the content type to resolve.\n    #\n    # Returns the resolved form enctype.\n    resolveFormContentType: (enctype = 'application/x-www-form-urlencoded') ->\n      enctype\n\n    # Private: Process data as x-www-form-urlencoded after using serialize.\n    # data stays the same. The reason to use a fuction here is to stay\n    # consitsnat with other process avaiable process fucntions.\n    #\n    # data - serialized form data.\n    #\n    # Returns entered data.\n    _proecessUrlecoded: (data) ->\n      data\n\n    # Private: Process data as JSON afetr using serialize.\n    #\n    # data - serialized form data.\n    #\n    # Returns data as JSON object.\n    _processJson: (data) ->\n      $.deparam(data, true)\n\n    # Public: Convert form data depending of form content type.\n    #\n    # data - The form data.\n    # enctype = The form content type.\n    #\n    # Retunrs  converted form.\n    # Raises Error in case of an unrecognised content type.\n    formDataContentTypeConverter: (data, enctype) ->\n      processFormData =\n        'application/x-www-form-urlencoded': @_proecessUrlecoded\n        'application/json': @_processJson\n      if processFormData[enctype]\n        convertedData = processFormData[enctype](data)\n      else\n        throw new Error(\"Form content type not suppoted.\")\n      convertedData\n\n    # Private: create a valid URl when concting a query stirng\n    # to an existing URL.\n    # Make sure there is no more than 1 apperaence of '?' sign\n    #\n    # url - the url to attch the query string\n    # queryString - query string\n    #\n    # Returns a valid URL\n    _urlBuilderGET: (url, queryString) ->\n      separator = if (url.search(/\\?/) > 0) then \"&\" else \"?\"\n      url + separator + queryString\n\n    # Public: render action options for $http service.\n    #\n    # action - The action object.\n    # formData - serialized form data values.\n    #\n    # Returns the renderd options.\n    renderOptions: (action, formData) ->\n      resolveFormContentType = @resolveFormContentType(action.type)\n      options =\n        method: action.method\n        url: action.href\n        headers:\n          'Content-Type': resolveFormContentType\n          'Accept':\n            'application/vnd.siren+json, application/json, text/plain, */*'\n      data = @formDataContentTypeConverter(\n        formData, resolveFormContentType\n      )\n      if (action.method == 'GET')\n        options.url = @_urlBuilderGET(options.url, data)\n      else\n        options.data = data\n      options\n\n\n  angular.module('SirenBrowser')\n    .factory \"actionsUtils\", [\n      actionsUtils\n    ]\n\n)()\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/siren-browser/services/actionsUtils.coffee\n **/","/*!\n * jQuery BBQ: Back Button & Query Library - v1.3pre - 8/26/2010\n * http://benalman.com/projects/jquery-bbq-plugin/\n *\n * Copyright (c) 2010 \"Cowboy\" Ben Alman\n * Dual licensed under the MIT and GPL licenses.\n * http://benalman.com/about/license/\n */\n\n// Script: jQuery BBQ: Back Button & Query Library\n//\n// *Version: 1.3pre, Last updated: 8/26/2010*\n//\n// Project Home - http://benalman.com/projects/jquery-bbq-plugin/\n// GitHub       - http://github.com/cowboy/jquery-bbq/\n// Source       - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.js\n// (Minified)   - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.min.js (2.2kb gzipped)\n//\n// About: License\n//\n// Copyright (c) 2010 \"Cowboy\" Ben Alman,\n// Dual licensed under the MIT and GPL licenses.\n// http://benalman.com/about/license/\n//\n// About: Examples\n//\n// These working examples, complete with fully commented code, illustrate a few\n// ways in which this plugin can be used.\n//\n// Basic AJAX     - http://benalman.com/code/projects/jquery-bbq/examples/fragment-basic/\n// Advanced AJAX  - http://benalman.com/code/projects/jquery-bbq/examples/fragment-advanced/\n// jQuery UI Tabs - http://benalman.com/code/projects/jquery-bbq/examples/fragment-jquery-ui-tabs/\n// Deparam        - http://benalman.com/code/projects/jquery-bbq/examples/deparam/\n//\n// About: Support and Testing\n//\n// Information about what version or versions of jQuery this plugin has been\n// tested with, what browsers it has been tested in, and where the unit tests\n// reside (so you can test it yourself).\n//\n// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2\n// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,\n//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.\n// Unit Tests      - http://benalman.com/code/projects/jquery-bbq/unit/\n//\n// About: Release History\n//\n// 1.3pre - (8/26/2010) Integrated <jQuery hashchange event> v1.3, which adds\n//         document.title and document.domain support in IE6/7, BlackBerry\n//         support, better Iframe hiding for accessibility reasons, and the new\n//         <jQuery.fn.hashchange> \"shortcut\" method. Added the\n//         <jQuery.param.sorted> method which reduces the possibility of\n//         extraneous hashchange event triggering. Added the\n//         <jQuery.param.fragment.ajaxCrawlable> method which can be used to\n//         enable Google \"AJAX Crawlable mode.\"\n// 1.2.1 - (2/17/2010) Actually fixed the stale window.location Safari bug from\n//         <jQuery hashchange event> in BBQ, which was the main reason for the\n//         previous release!\n// 1.2   - (2/16/2010) Integrated <jQuery hashchange event> v1.2, which fixes a\n//         Safari bug, the event can now be bound before DOM ready, and IE6/7\n//         page should no longer scroll when the event is first bound. Also\n//         added the <jQuery.param.fragment.noEscape> method, and reworked the\n//         <hashchange event (BBQ)> internal \"add\" method to be compatible with\n//         changes made to the jQuery 1.4.2 special events API.\n// 1.1.1 - (1/22/2010) Integrated <jQuery hashchange event> v1.1, which fixes an\n//         obscure IE8 EmulateIE7 meta tag compatibility mode bug.\n// 1.1   - (1/9/2010) Broke out the jQuery BBQ event.special <hashchange event>\n//         functionality into a separate plugin for users who want just the\n//         basic event & back button support, without all the extra awesomeness\n//         that BBQ provides. This plugin will be included as part of jQuery BBQ,\n//         but also be available separately. See <jQuery hashchange event>\n//         plugin for more information. Also added the <jQuery.bbq.removeState>\n//         method and added additional <jQuery.deparam> examples.\n// 1.0.3 - (12/2/2009) Fixed an issue in IE 6 where location.search and\n//         location.hash would report incorrectly if the hash contained the ?\n//         character. Also <jQuery.param.querystring> and <jQuery.param.fragment>\n//         will no longer parse params out of a URL that doesn't contain ? or #,\n//         respectively.\n// 1.0.2 - (10/10/2009) Fixed an issue in IE 6/7 where the hidden IFRAME caused\n//         a \"This page contains both secure and nonsecure items.\" warning when\n//         used on an https:// page.\n// 1.0.1 - (10/7/2009) Fixed an issue in IE 8. Since both \"IE7\" and \"IE8\n//         Compatibility View\" modes erroneously report that the browser\n//         supports the native window.onhashchange event, a slightly more\n//         robust test needed to be added.\n// 1.0   - (10/2/2009) Initial release\n\n(function($,window){\n  '$:nomunge'; // Used by YUI compressor.\n\n  // Some convenient shortcuts.\n  var undefined,\n    aps = Array.prototype.slice,\n    decode = decodeURIComponent,\n\n    // Method / object references.\n    jq_param = $.param,\n    jq_param_sorted,\n    jq_param_fragment,\n    jq_deparam,\n    jq_deparam_fragment,\n    jq_bbq = $.bbq = $.bbq || {},\n    jq_bbq_pushState,\n    jq_bbq_getState,\n    jq_elemUrlAttr,\n    special = $.event.special,\n\n    // Reused strings.\n    str_hashchange = 'hashchange',\n    str_querystring = 'querystring',\n    str_fragment = 'fragment',\n    str_elemUrlAttr = 'elemUrlAttr',\n    str_href = 'href',\n    str_src = 'src',\n\n    // Reused RegExp.\n    re_params_querystring = /^.*\\?|#.*$/g,\n    re_params_fragment,\n    re_fragment,\n    re_no_escape,\n\n    ajax_crawlable,\n    fragment_prefix,\n\n    // Used by jQuery.elemUrlAttr.\n    elemUrlAttr_cache = {};\n\n  // A few commonly used bits, broken out to help reduce minified file size.\n\n  function is_string( arg ) {\n    return typeof arg === 'string';\n  };\n\n  // Why write the same function twice? Let's curry! Mmmm, curry..\n\n  function curry( func ) {\n    var args = aps.call( arguments, 1 );\n\n    return function() {\n      return func.apply( this, args.concat( aps.call( arguments ) ) );\n    };\n  };\n\n  // Get location.hash (or what you'd expect location.hash to be) sans any\n  // leading #. Thanks for making this necessary, Firefox!\n  function get_fragment( url ) {\n    return url.replace( re_fragment, '$2' );\n  };\n\n  // Get location.search (or what you'd expect location.search to be) sans any\n  // leading #. Thanks for making this necessary, IE6!\n  function get_querystring( url ) {\n    return url.replace( /(?:^[^?#]*\\?([^#]*).*$)?.*/, '$1' );\n  };\n\n  // Section: Param (to string)\n  //\n  // Method: jQuery.param.querystring\n  //\n  // Retrieve the query string from a URL or if no arguments are passed, the\n  // current window.location.href.\n  //\n  // Usage:\n  //\n  // > jQuery.param.querystring( [ url ] );\n  //\n  // Arguments:\n  //\n  //  url - (String) A URL containing query string params to be parsed. If url\n  //    is not passed, the current window.location.href is used.\n  //\n  // Returns:\n  //\n  //  (String) The parsed query string, with any leading \"?\" removed.\n  //\n\n  // Method: jQuery.param.querystring (build url)\n  //\n  // Merge a URL, with or without pre-existing query string params, plus any\n  // object, params string or URL containing query string params into a new URL.\n  //\n  // Usage:\n  //\n  // > jQuery.param.querystring( url, params [, merge_mode ] );\n  //\n  // Arguments:\n  //\n  //  url - (String) A valid URL for params to be merged into. This URL may\n  //    contain a query string and/or fragment (hash).\n  //  params - (String) A params string or URL containing query string params to\n  //    be merged into url.\n  //  params - (Object) A params object to be merged into url.\n  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not\n  //    specified, and is as-follows:\n  //\n  //    * 0: params in the params argument will override any query string\n  //         params in url.\n  //    * 1: any query string params in url will override params in the params\n  //         argument.\n  //    * 2: params argument will completely replace any query string in url.\n  //\n  // Returns:\n  //\n  //  (String) A URL with a urlencoded query string in the format '?a=b&c=d&e=f'.\n\n  // Method: jQuery.param.fragment\n  //\n  // Retrieve the fragment (hash) from a URL or if no arguments are passed, the\n  // current window.location.href.\n  //\n  // Usage:\n  //\n  // > jQuery.param.fragment( [ url ] );\n  //\n  // Arguments:\n  //\n  //  url - (String) A URL containing fragment (hash) params to be parsed. If\n  //    url is not passed, the current window.location.href is used.\n  //\n  // Returns:\n  //\n  //  (String) The parsed fragment (hash) string, with any leading \"#\" removed.\n\n  // Method: jQuery.param.fragment (build url)\n  //\n  // Merge a URL, with or without pre-existing fragment (hash) params, plus any\n  // object, params string or URL containing fragment (hash) params into a new\n  // URL.\n  //\n  // Usage:\n  //\n  // > jQuery.param.fragment( url, params [, merge_mode ] );\n  //\n  // Arguments:\n  //\n  //  url - (String) A valid URL for params to be merged into. This URL may\n  //    contain a query string and/or fragment (hash).\n  //  params - (String) A params string or URL containing fragment (hash) params\n  //    to be merged into url.\n  //  params - (Object) A params object to be merged into url.\n  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not\n  //    specified, and is as-follows:\n  //\n  //    * 0: params in the params argument will override any fragment (hash)\n  //         params in url.\n  //    * 1: any fragment (hash) params in url will override params in the\n  //         params argument.\n  //    * 2: params argument will completely replace any query string in url.\n  //\n  // Returns:\n  //\n  //  (String) A URL with a urlencoded fragment (hash) in the format '#a=b&c=d&e=f'.\n\n  function jq_param_sub( is_fragment, get_func, url, params, merge_mode ) {\n    var result,\n      qs,\n      matches,\n      url_params,\n      hash;\n\n    if ( params !== undefined ) {\n      // Build URL by merging params into url string.\n\n      // matches[1] = url part that precedes params, not including trailing ?/#\n      // matches[2] = params, not including leading ?/#\n      // matches[3] = if in 'querystring' mode, hash including leading #, otherwise ''\n      matches = url.match( is_fragment ? re_fragment : /^([^#?]*)\\??([^#]*)(#?.*)/ );\n\n      // Get the hash if in 'querystring' mode, and it exists.\n      hash = matches[3] || '';\n\n      if ( merge_mode === 2 && is_string( params ) ) {\n        // If merge_mode is 2 and params is a string, merge the fragment / query\n        // string into the URL wholesale, without converting it into an object.\n        qs = params.replace( is_fragment ? re_params_fragment : re_params_querystring, '' );\n\n      } else {\n        // Convert relevant params in url to object.\n        url_params = jq_deparam( matches[2] );\n\n        params = is_string( params )\n\n          // Convert passed params string into object.\n          ? jq_deparam[ is_fragment ? str_fragment : str_querystring ]( params )\n\n          // Passed params object.\n          : params;\n\n        qs = merge_mode === 2 ? params                              // passed params replace url params\n          : merge_mode === 1  ? $.extend( {}, params, url_params )  // url params override passed params\n          : $.extend( {}, url_params, params );                     // passed params override url params\n\n        // Convert params object into a sorted params string.\n        qs = jq_param_sorted( qs );\n\n        // Unescape characters specified via $.param.noEscape. Since only hash-\n        // history users have requested this feature, it's only enabled for\n        // fragment-related params strings.\n        if ( is_fragment ) {\n          qs = qs.replace( re_no_escape, decode );\n        }\n      }\n\n      // Build URL from the base url, querystring and hash. In 'querystring'\n      // mode, ? is only added if a query string exists. In 'fragment' mode, #\n      // is always added.\n      result = matches[1] + ( is_fragment ? fragment_prefix : qs || !matches[1] ? '?' : '' ) + qs + hash;\n\n    } else {\n      // If URL was passed in, parse params from URL string, otherwise parse\n      // params from window.location.href.\n      result = get_func( url !== undefined ? url : location.href );\n    }\n\n    return result;\n  };\n\n  jq_param[ str_querystring ]                  = curry( jq_param_sub, 0, get_querystring );\n  jq_param[ str_fragment ] = jq_param_fragment = curry( jq_param_sub, 1, get_fragment );\n\n  // Method: jQuery.param.sorted\n  //\n  // Returns a params string equivalent to that returned by the internal\n  // jQuery.param method, but sorted, which makes it suitable for use as a\n  // cache key.\n  //\n  // For example, in most browsers jQuery.param({z:1,a:2}) returns \"z=1&a=2\"\n  // and jQuery.param({a:2,z:1}) returns \"a=2&z=1\". Even though both the\n  // objects being serialized and the resulting params strings are equivalent,\n  // if these params strings were set into the location.hash fragment\n  // sequentially, the hashchange event would be triggered unnecessarily, since\n  // the strings are different (even though the data described by them is the\n  // same). By sorting the params string, unecessary hashchange event triggering\n  // can be avoided.\n  //\n  // Usage:\n  //\n  // > jQuery.param.sorted( obj [, traditional ] );\n  //\n  // Arguments:\n  //\n  //  obj - (Object) An object to be serialized.\n  //  traditional - (Boolean) Params deep/shallow serialization mode. See the\n  //    documentation at http://api.jquery.com/jQuery.param/ for more detail.\n  //\n  // Returns:\n  //\n  //  (String) A sorted params string.\n\n  jq_param.sorted = jq_param_sorted = function( a, traditional ) {\n    var arr = [],\n      obj = {};\n\n    $.each( jq_param( a, traditional ).split( '&' ), function(i,v){\n      var key = v.replace( /(?:%5B|=).*$/, '' ),\n        key_obj = obj[ key ];\n\n      if ( !key_obj ) {\n        key_obj = obj[ key ] = [];\n        arr.push( key );\n      }\n\n      key_obj.push( v );\n    });\n\n    return $.map( arr.sort(), function(v){\n      return obj[ v ];\n    }).join( '&' );\n  };\n\n  // Method: jQuery.param.fragment.noEscape\n  //\n  // Specify characters that will be left unescaped when fragments are created\n  // or merged using <jQuery.param.fragment>, or when the fragment is modified\n  // using <jQuery.bbq.pushState>. This option only applies to serialized data\n  // object fragments, and not set-as-string fragments. Does not affect the\n  // query string. Defaults to \",/\" (comma, forward slash).\n  //\n  // Note that this is considered a purely aesthetic option, and will help to\n  // create URLs that \"look pretty\" in the address bar or bookmarks, without\n  // affecting functionality in any way. That being said, be careful to not\n  // unescape characters that are used as delimiters or serve a special\n  // purpose, such as the \"#?&=+\" (octothorpe, question mark, ampersand,\n  // equals, plus) characters.\n  //\n  // Usage:\n  //\n  // > jQuery.param.fragment.noEscape( [ chars ] );\n  //\n  // Arguments:\n  //\n  //  chars - (String) The characters to not escape in the fragment. If\n  //    unspecified, defaults to empty string (escape all characters).\n  //\n  // Returns:\n  //\n  //  Nothing.\n\n  jq_param_fragment.noEscape = function( chars ) {\n    chars = chars || '';\n    var arr = $.map( chars.split(''), encodeURIComponent );\n    re_no_escape = new RegExp( arr.join('|'), 'g' );\n  };\n\n  // A sensible default. These are the characters people seem to complain about\n  // \"uglifying up the URL\" the most.\n  jq_param_fragment.noEscape( ',/' );\n\n  // Method: jQuery.param.fragment.ajaxCrawlable\n  //\n  // TODO: DESCRIBE\n  //\n  // Usage:\n  //\n  // > jQuery.param.fragment.ajaxCrawlable( [ state ] );\n  //\n  // Arguments:\n  //\n  //  state - (Boolean) TODO: DESCRIBE\n  //\n  // Returns:\n  //\n  //  (Boolean) The current ajaxCrawlable state.\n\n  jq_param_fragment.ajaxCrawlable = function( state ) {\n    if ( state !== undefined ) {\n      if ( state ) {\n        re_params_fragment = /^.*(?:#!|#)/;\n        re_fragment = /^([^#]*)(?:#!|#)?(.*)$/;\n        fragment_prefix = '#!';\n      } else {\n        re_params_fragment = /^.*#/;\n        re_fragment = /^([^#]*)#?(.*)$/;\n        fragment_prefix = '#';\n      }\n      ajax_crawlable = !!state;\n    }\n\n    return ajax_crawlable;\n  };\n\n  jq_param_fragment.ajaxCrawlable( 0 );\n\n  // Section: Deparam (from string)\n  //\n  // Method: jQuery.deparam\n  //\n  // Deserialize a params string into an object, optionally coercing numbers,\n  // booleans, null and undefined values; this method is the counterpart to the\n  // internal jQuery.param method.\n  //\n  // Usage:\n  //\n  // > jQuery.deparam( params [, coerce ] );\n  //\n  // Arguments:\n  //\n  //  params - (String) A params string to be parsed.\n  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and\n  //    undefined to their actual value. Defaults to false if omitted.\n  //\n  // Returns:\n  //\n  //  (Object) An object representing the deserialized params string.\n\n  $.deparam = jq_deparam = function( params, coerce ) {\n    var obj = {},\n      coerce_types = { 'true': !0, 'false': !1, 'null': null };\n\n    // Iterate over all name=value pairs.\n    $.each( params.replace( /\\+/g, ' ' ).split( '&' ), function(j,v){\n      var param = v.split( '=' ),\n        key = decode( param[0] ),\n        val,\n        cur = obj,\n        i = 0,\n\n        // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it\n        // into its component parts.\n        keys = key.split( '][' ),\n        keys_last = keys.length - 1;\n\n      // If the first keys part contains [ and the last ends with ], then []\n      // are correctly balanced.\n      if ( /\\[/.test( keys[0] ) && /\\]$/.test( keys[ keys_last ] ) ) {\n        // Remove the trailing ] from the last keys part.\n        keys[ keys_last ] = keys[ keys_last ].replace( /\\]$/, '' );\n\n        // Split first keys part into two parts on the [ and add them back onto\n        // the beginning of the keys array.\n        keys = keys.shift().split('[').concat( keys );\n\n        keys_last = keys.length - 1;\n      } else {\n        // Basic 'foo' style key.\n        keys_last = 0;\n      }\n\n      // Are we dealing with a name=value pair, or just a name?\n      if ( param.length === 2 ) {\n        val = decode( param[1] );\n\n        // Coerce values.\n        if ( coerce ) {\n          val = val && !isNaN(val)            ? +val              // number\n            : val === 'undefined'             ? undefined         // undefined\n            : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null\n            : val;                                                // string\n        }\n\n        if ( keys_last ) {\n          // Complex key, build deep object structure based on a few rules:\n          // * The 'cur' pointer starts at the object top-level.\n          // * [] = array push (n is set to array length), [n] = array if n is\n          //   numeric, otherwise object.\n          // * If at the last keys part, set the value.\n          // * For each keys part, if the current level is undefined create an\n          //   object or array based on the type of the next keys part.\n          // * Move the 'cur' pointer to the next level.\n          // * Rinse & repeat.\n          for ( ; i <= keys_last; i++ ) {\n            key = keys[i] === '' ? cur.length : keys[i];\n            cur = cur[key] = i < keys_last\n              ? cur[key] || ( keys[i+1] && isNaN( keys[i+1] ) ? {} : [] )\n              : val;\n          }\n\n        } else {\n          // Simple key, even simpler rules, since only scalars and shallow\n          // arrays are allowed.\n\n          if ( $.isArray( obj[key] ) ) {\n            // val is already an array, so push on the next value.\n            obj[key].push( val );\n\n          } else if ( obj[key] !== undefined ) {\n            // val isn't an array, but since a second value has been specified,\n            // convert val into an array.\n            obj[key] = [ obj[key], val ];\n\n          } else {\n            // val is a scalar.\n            obj[key] = val;\n          }\n        }\n\n      } else if ( key ) {\n        // No value was defined, so set something meaningful.\n        obj[key] = coerce\n          ? undefined\n          : '';\n      }\n    });\n\n    return obj;\n  };\n\n  // Method: jQuery.deparam.querystring\n  //\n  // Parse the query string from a URL or the current window.location.href,\n  // deserializing it into an object, optionally coercing numbers, booleans,\n  // null and undefined values.\n  //\n  // Usage:\n  //\n  // > jQuery.deparam.querystring( [ url ] [, coerce ] );\n  //\n  // Arguments:\n  //\n  //  url - (String) An optional params string or URL containing query string\n  //    params to be parsed. If url is omitted, the current\n  //    window.location.href is used.\n  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and\n  //    undefined to their actual value. Defaults to false if omitted.\n  //\n  // Returns:\n  //\n  //  (Object) An object representing the deserialized params string.\n\n  // Method: jQuery.deparam.fragment\n  //\n  // Parse the fragment (hash) from a URL or the current window.location.href,\n  // deserializing it into an object, optionally coercing numbers, booleans,\n  // null and undefined values.\n  //\n  // Usage:\n  //\n  // > jQuery.deparam.fragment( [ url ] [, coerce ] );\n  //\n  // Arguments:\n  //\n  //  url - (String) An optional params string or URL containing fragment (hash)\n  //    params to be parsed. If url is omitted, the current window.location.href\n  //    is used.\n  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and\n  //    undefined to their actual value. Defaults to false if omitted.\n  //\n  // Returns:\n  //\n  //  (Object) An object representing the deserialized params string.\n\n  function jq_deparam_sub( is_fragment, url_or_params, coerce ) {\n    if ( url_or_params === undefined || typeof url_or_params === 'boolean' ) {\n      // url_or_params not specified.\n      coerce = url_or_params;\n      url_or_params = jq_param[ is_fragment ? str_fragment : str_querystring ]();\n    } else {\n      url_or_params = is_string( url_or_params )\n        ? url_or_params.replace( is_fragment ? re_params_fragment : re_params_querystring, '' )\n        : url_or_params;\n    }\n\n    return jq_deparam( url_or_params, coerce );\n  };\n\n  jq_deparam[ str_querystring ]                    = curry( jq_deparam_sub, 0 );\n  jq_deparam[ str_fragment ] = jq_deparam_fragment = curry( jq_deparam_sub, 1 );\n\n  // Section: Element manipulation\n  //\n  // Method: jQuery.elemUrlAttr\n  //\n  // Get the internal \"Default URL attribute per tag\" list, or augment the list\n  // with additional tag-attribute pairs, in case the defaults are insufficient.\n  //\n  // In the <jQuery.fn.querystring> and <jQuery.fn.fragment> methods, this list\n  // is used to determine which attribute contains the URL to be modified, if\n  // an \"attr\" param is not specified.\n  //\n  // Default Tag-Attribute List:\n  //\n  //  a      - href\n  //  base   - href\n  //  iframe - src\n  //  img    - src\n  //  input  - src\n  //  form   - action\n  //  link   - href\n  //  script - src\n  //\n  // Usage:\n  //\n  // > jQuery.elemUrlAttr( [ tag_attr ] );\n  //\n  // Arguments:\n  //\n  //  tag_attr - (Object) An object containing a list of tag names and their\n  //    associated default attribute names in the format { tag: 'attr', ... } to\n  //    be merged into the internal tag-attribute list.\n  //\n  // Returns:\n  //\n  //  (Object) An object containing all stored tag-attribute values.\n\n  // Only define function and set defaults if function doesn't already exist, as\n  // the urlInternal plugin will provide this method as well.\n  $[ str_elemUrlAttr ] || ($[ str_elemUrlAttr ] = function( obj ) {\n    return $.extend( elemUrlAttr_cache, obj );\n  })({\n    a: str_href,\n    base: str_href,\n    iframe: str_src,\n    img: str_src,\n    input: str_src,\n    form: 'action',\n    link: str_href,\n    script: str_src\n  });\n\n  jq_elemUrlAttr = $[ str_elemUrlAttr ];\n\n  // Method: jQuery.fn.querystring\n  //\n  // Update URL attribute in one or more elements, merging the current URL (with\n  // or without pre-existing query string params) plus any params object or\n  // string into a new URL, which is then set into that attribute. Like\n  // <jQuery.param.querystring (build url)>, but for all elements in a jQuery\n  // collection.\n  //\n  // Usage:\n  //\n  // > jQuery('selector').querystring( [ attr, ] params [, merge_mode ] );\n  //\n  // Arguments:\n  //\n  //  attr - (String) Optional name of an attribute that will contain a URL to\n  //    merge params or url into. See <jQuery.elemUrlAttr> for a list of default\n  //    attributes.\n  //  params - (Object) A params object to be merged into the URL attribute.\n  //  params - (String) A URL containing query string params, or params string\n  //    to be merged into the URL attribute.\n  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not\n  //    specified, and is as-follows:\n  //\n  //    * 0: params in the params argument will override any params in attr URL.\n  //    * 1: any params in attr URL will override params in the params argument.\n  //    * 2: params argument will completely replace any query string in attr\n  //         URL.\n  //\n  // Returns:\n  //\n  //  (jQuery) The initial jQuery collection of elements, but with modified URL\n  //  attribute values.\n\n  // Method: jQuery.fn.fragment\n  //\n  // Update URL attribute in one or more elements, merging the current URL (with\n  // or without pre-existing fragment/hash params) plus any params object or\n  // string into a new URL, which is then set into that attribute. Like\n  // <jQuery.param.fragment (build url)>, but for all elements in a jQuery\n  // collection.\n  //\n  // Usage:\n  //\n  // > jQuery('selector').fragment( [ attr, ] params [, merge_mode ] );\n  //\n  // Arguments:\n  //\n  //  attr - (String) Optional name of an attribute that will contain a URL to\n  //    merge params into. See <jQuery.elemUrlAttr> for a list of default\n  //    attributes.\n  //  params - (Object) A params object to be merged into the URL attribute.\n  //  params - (String) A URL containing fragment (hash) params, or params\n  //    string to be merged into the URL attribute.\n  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not\n  //    specified, and is as-follows:\n  //\n  //    * 0: params in the params argument will override any params in attr URL.\n  //    * 1: any params in attr URL will override params in the params argument.\n  //    * 2: params argument will completely replace any fragment (hash) in attr\n  //         URL.\n  //\n  // Returns:\n  //\n  //  (jQuery) The initial jQuery collection of elements, but with modified URL\n  //  attribute values.\n\n  function jq_fn_sub( mode, force_attr, params, merge_mode ) {\n    if ( !is_string( params ) && typeof params !== 'object' ) {\n      // force_attr not specified.\n      merge_mode = params;\n      params = force_attr;\n      force_attr = undefined;\n    }\n\n    return this.each(function(){\n      var that = $(this),\n\n        // Get attribute specified, or default specified via $.elemUrlAttr.\n        attr = force_attr || jq_elemUrlAttr()[ ( this.nodeName || '' ).toLowerCase() ] || '',\n\n        // Get URL value.\n        url = attr && that.attr( attr ) || '';\n\n      // Update attribute with new URL.\n      that.attr( attr, jq_param[ mode ]( url, params, merge_mode ) );\n    });\n\n  };\n\n  $.fn[ str_querystring ] = curry( jq_fn_sub, str_querystring );\n  $.fn[ str_fragment ]    = curry( jq_fn_sub, str_fragment );\n\n  // Section: History, hashchange event\n  //\n  // Method: jQuery.bbq.pushState\n  //\n  // Adds a 'state' into the browser history at the current position, setting\n  // location.hash and triggering any bound <hashchange event> callbacks\n  // (provided the new state is different than the previous state).\n  //\n  // If no arguments are passed, an empty state is created, which is just a\n  // shortcut for jQuery.bbq.pushState( {}, 2 ).\n  //\n  // Usage:\n  //\n  // > jQuery.bbq.pushState( [ params [, merge_mode ] ] );\n  //\n  // Arguments:\n  //\n  //  params - (String) A serialized params string or a hash string beginning\n  //    with # to merge into location.hash.\n  //  params - (Object) A params object to merge into location.hash.\n  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not\n  //    specified (unless a hash string beginning with # is specified, in which\n  //    case merge behavior defaults to 2), and is as-follows:\n  //\n  //    * 0: params in the params argument will override any params in the\n  //         current state.\n  //    * 1: any params in the current state will override params in the params\n  //         argument.\n  //    * 2: params argument will completely replace current state.\n  //\n  // Returns:\n  //\n  //  Nothing.\n  //\n  // Additional Notes:\n  //\n  //  * Setting an empty state may cause the browser to scroll.\n  //  * Unlike the fragment and querystring methods, if a hash string beginning\n  //    with # is specified as the params agrument, merge_mode defaults to 2.\n\n  jq_bbq.pushState = jq_bbq_pushState = function( params, merge_mode ) {\n    if ( is_string( params ) && /^#/.test( params ) && merge_mode === undefined ) {\n      // Params string begins with # and merge_mode not specified, so completely\n      // overwrite window.location.hash.\n      merge_mode = 2;\n    }\n\n    var has_args = params !== undefined,\n      // Merge params into window.location using $.param.fragment.\n      url = jq_param_fragment( location.href,\n        has_args ? params : {}, has_args ? merge_mode : 2 );\n\n    // Set new window.location.href. Note that Safari 3 & Chrome barf on\n    // location.hash = '#' so the entire URL is set.\n    location.href = url;\n  };\n\n  // Method: jQuery.bbq.getState\n  //\n  // Retrieves the current 'state' from the browser history, parsing\n  // location.hash for a specific key or returning an object containing the\n  // entire state, optionally coercing numbers, booleans, null and undefined\n  // values.\n  //\n  // Usage:\n  //\n  // > jQuery.bbq.getState( [ key ] [, coerce ] );\n  //\n  // Arguments:\n  //\n  //  key - (String) An optional state key for which to return a value.\n  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and\n  //    undefined to their actual value. Defaults to false.\n  //\n  // Returns:\n  //\n  //  (Anything) If key is passed, returns the value corresponding with that key\n  //    in the location.hash 'state', or undefined. If not, an object\n  //    representing the entire 'state' is returned.\n\n  jq_bbq.getState = jq_bbq_getState = function( key, coerce ) {\n    return key === undefined || typeof key === 'boolean'\n      ? jq_deparam_fragment( key ) // 'key' really means 'coerce' here\n      : jq_deparam_fragment( coerce )[ key ];\n  };\n\n  // Method: jQuery.bbq.removeState\n  //\n  // Remove one or more keys from the current browser history 'state', creating\n  // a new state, setting location.hash and triggering any bound\n  // <hashchange event> callbacks (provided the new state is different than\n  // the previous state).\n  //\n  // If no arguments are passed, an empty state is created, which is just a\n  // shortcut for jQuery.bbq.pushState( {}, 2 ).\n  //\n  // Usage:\n  //\n  // > jQuery.bbq.removeState( [ key [, key ... ] ] );\n  //\n  // Arguments:\n  //\n  //  key - (String) One or more key values to remove from the current state,\n  //    passed as individual arguments.\n  //  key - (Array) A single array argument that contains a list of key values\n  //    to remove from the current state.\n  //\n  // Returns:\n  //\n  //  Nothing.\n  //\n  // Additional Notes:\n  //\n  //  * Setting an empty state may cause the browser to scroll.\n\n  jq_bbq.removeState = function( arr ) {\n    var state = {};\n\n    // If one or more arguments is passed..\n    if ( arr !== undefined ) {\n\n      // Get the current state.\n      state = jq_bbq_getState();\n\n      // For each passed key, delete the corresponding property from the current\n      // state.\n      $.each( $.isArray( arr ) ? arr : arguments, function(i,v){\n        delete state[ v ];\n      });\n    }\n\n    // Set the state, completely overriding any existing state.\n    jq_bbq_pushState( state, 2 );\n  };\n\n  // Event: hashchange event (BBQ)\n  //\n  // Usage in jQuery 1.4 and newer:\n  //\n  // In jQuery 1.4 and newer, the event object passed into any hashchange event\n  // callback is augmented with a copy of the location.hash fragment at the time\n  // the event was triggered as its event.fragment property. In addition, the\n  // event.getState method operates on this property (instead of location.hash)\n  // which allows this fragment-as-a-state to be referenced later, even after\n  // window.location may have changed.\n  //\n  // Note that event.fragment and event.getState are not defined according to\n  // W3C (or any other) specification, but will still be available whether or\n  // not the hashchange event exists natively in the browser, because of the\n  // utility they provide.\n  //\n  // The event.fragment property contains the output of <jQuery.param.fragment>\n  // and the event.getState method is equivalent to the <jQuery.bbq.getState>\n  // method.\n  //\n  // > $(window).bind( 'hashchange', function( event ) {\n  // >   var hash_str = event.fragment,\n  // >     param_obj = event.getState(),\n  // >     param_val = event.getState( 'param_name' ),\n  // >     param_val_coerced = event.getState( 'param_name', true );\n  // >   ...\n  // > });\n  //\n  // Usage in jQuery 1.3.2:\n  //\n  // In jQuery 1.3.2, the event object cannot to be augmented as in jQuery 1.4+,\n  // so the fragment state isn't bound to the event object and must instead be\n  // parsed using the <jQuery.param.fragment> and <jQuery.bbq.getState> methods.\n  //\n  // > $(window).bind( 'hashchange', function( event ) {\n  // >   var hash_str = $.param.fragment(),\n  // >     param_obj = $.bbq.getState(),\n  // >     param_val = $.bbq.getState( 'param_name' ),\n  // >     param_val_coerced = $.bbq.getState( 'param_name', true );\n  // >   ...\n  // > });\n  //\n  // Additional Notes:\n  //\n  // * Due to changes in the special events API, jQuery BBQ v1.2 or newer is\n  //   required to enable the augmented event object in jQuery 1.4.2 and newer.\n  // * See <jQuery hashchange event> for more detailed information.\n\n  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {\n\n    // Augmenting the event object with the .fragment property and .getState\n    // method requires jQuery 1.4 or newer. Note: with 1.3.2, everything will\n    // work, but the event won't be augmented)\n    add: function( handleObj ) {\n      var old_handler;\n\n      function new_handler(e) {\n        // e.fragment is set to the value of location.hash (with any leading #\n        // removed) at the time the event is triggered.\n        var hash = e[ str_fragment ] = jq_param_fragment();\n\n        // e.getState() works just like $.bbq.getState(), but uses the\n        // e.fragment property stored on the event object.\n        e.getState = function( key, coerce ) {\n          return key === undefined || typeof key === 'boolean'\n            ? jq_deparam( hash, key ) // 'key' really means 'coerce' here\n            : jq_deparam( hash, coerce )[ key ];\n        };\n\n        old_handler.apply( this, arguments );\n      };\n\n      // This may seem a little complicated, but it normalizes the special event\n      // .add method between jQuery 1.4/1.4.1 and 1.4.2+\n      if ( $.isFunction( handleObj ) ) {\n        // 1.4, 1.4.1\n        old_handler = handleObj;\n        return new_handler;\n      } else {\n        // 1.4.2+\n        old_handler = handleObj.handler;\n        handleObj.handler = new_handler;\n      }\n    }\n\n  });\n\n})(jQuery,this);\n\n/*!\n * jQuery hashchange event - v1.3 - 7/21/2010\n * http://benalman.com/projects/jquery-hashchange-plugin/\n *\n * Copyright (c) 2010 \"Cowboy\" Ben Alman\n * Dual licensed under the MIT and GPL licenses.\n * http://benalman.com/about/license/\n */\n\n// Script: jQuery hashchange event\n//\n// *Version: 1.3, Last updated: 7/21/2010*\n//\n// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/\n// GitHub       - http://github.com/cowboy/jquery-hashchange/\n// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js\n// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (0.8kb gzipped)\n//\n// About: License\n//\n// Copyright (c) 2010 \"Cowboy\" Ben Alman,\n// Dual licensed under the MIT and GPL licenses.\n// http://benalman.com/about/license/\n//\n// About: Examples\n//\n// These working examples, complete with fully commented code, illustrate a few\n// ways in which this plugin can be used.\n//\n// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/\n// document.domain - http://benalman.com/code/projects/jquery-hashchange/examples/document_domain/\n//\n// About: Support and Testing\n//\n// Information about what version or versions of jQuery this plugin has been\n// tested with, what browsers it has been tested in, and where the unit tests\n// reside (so you can test it yourself).\n//\n// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2\n// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,\n//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.\n// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/\n//\n// About: Known issues\n//\n// While this jQuery hashchange event implementation is quite stable and\n// robust, there are a few unfortunate browser bugs surrounding expected\n// hashchange event-based behaviors, independent of any JavaScript\n// window.onhashchange abstraction. See the following examples for more\n// information:\n//\n// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/\n// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/\n// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/\n// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/\n//\n// Also note that should a browser natively support the window.onhashchange\n// event, but not report that it does, the fallback polling loop will be used.\n//\n// About: Release History\n//\n// 1.3   - (7/21/2010) Reorganized IE6/7 Iframe code to make it more\n//         \"removable\" for mobile-only development. Added IE6/7 document.title\n//         support. Attempted to make Iframe as hidden as possible by using\n//         techniques from http://www.paciellogroup.com/blog/?p=604. Added\n//         support for the \"shortcut\" format $(window).hashchange( fn ) and\n//         $(window).hashchange() like jQuery provides for built-in events.\n//         Renamed jQuery.hashchangeDelay to <jQuery.fn.hashchange.delay> and\n//         lowered its default value to 50. Added <jQuery.fn.hashchange.domain>\n//         and <jQuery.fn.hashchange.src> properties plus document-domain.html\n//         file to address access denied issues when setting document.domain in\n//         IE6/7.\n// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin\n//         from a page on another domain would cause an error in Safari 4. Also,\n//         IE6/7 Iframe is now inserted after the body (this actually works),\n//         which prevents the page from scrolling when the event is first bound.\n//         Event can also now be bound before DOM ready, but it won't be usable\n//         before then in IE6/7.\n// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug\n//         where browser version is incorrectly reported as 8.0, despite\n//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.\n// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special\n//         window.onhashchange functionality into a separate plugin for users\n//         who want just the basic event & back button support, without all the\n//         extra awesomeness that BBQ provides. This plugin will be included as\n//         part of jQuery BBQ, but also be available separately.\n\n(function($,window,undefined){\n  '$:nomunge'; // Used by YUI compressor.\n\n  // Reused string.\n  var str_hashchange = 'hashchange',\n\n    // Method / object references.\n    doc = document,\n    fake_onhashchange,\n    special = $.event.special,\n\n    // Does the browser support window.onhashchange? Note that IE8 running in\n    // IE7 compatibility mode reports true for 'onhashchange' in window, even\n    // though the event isn't supported, so also test document.documentMode.\n    doc_mode = doc.documentMode,\n    supports_onhashchange = 'on' + str_hashchange in window && ( doc_mode === undefined || doc_mode > 7 );\n\n  // Get location.hash (or what you'd expect location.hash to be) sans any\n  // leading #. Thanks for making this necessary, Firefox!\n  function get_fragment( url ) {\n    url = url || location.href;\n    return '#' + url.replace( /^[^#]*#?(.*)$/, '$1' );\n  };\n\n  // Method: jQuery.fn.hashchange\n  //\n  // Bind a handler to the window.onhashchange event or trigger all bound\n  // window.onhashchange event handlers. This behavior is consistent with\n  // jQuery's built-in event handlers.\n  //\n  // Usage:\n  //\n  // > jQuery(window).hashchange( [ handler ] );\n  //\n  // Arguments:\n  //\n  //  handler - (Function) Optional handler to be bound to the hashchange\n  //    event. This is a \"shortcut\" for the more verbose form:\n  //    jQuery(window).bind( 'hashchange', handler ). If handler is omitted,\n  //    all bound window.onhashchange event handlers will be triggered. This\n  //    is a shortcut for the more verbose\n  //    jQuery(window).trigger( 'hashchange' ). These forms are described in\n  //    the <hashchange event> section.\n  //\n  // Returns:\n  //\n  //  (jQuery) The initial jQuery collection of elements.\n\n  // Allow the \"shortcut\" format $(elem).hashchange( fn ) for binding and\n  // $(elem).hashchange() for triggering, like jQuery does for built-in events.\n  $.fn[ str_hashchange ] = function( fn ) {\n    return fn ? this.bind( str_hashchange, fn ) : this.trigger( str_hashchange );\n  };\n\n  // Property: jQuery.fn.hashchange.delay\n  //\n  // The numeric interval (in milliseconds) at which the <hashchange event>\n  // polling loop executes. Defaults to 50.\n\n  // Property: jQuery.fn.hashchange.domain\n  //\n  // If you're setting document.domain in your JavaScript, and you want hash\n  // history to work in IE6/7, not only must this property be set, but you must\n  // also set document.domain BEFORE jQuery is loaded into the page. This\n  // property is only applicable if you are supporting IE6/7 (or IE8 operating\n  // in \"IE7 compatibility\" mode).\n  //\n  // In addition, the <jQuery.fn.hashchange.src> property must be set to the\n  // path of the included \"document-domain.html\" file, which can be renamed or\n  // modified if necessary (note that the document.domain specified must be the\n  // same in both your main JavaScript as well as in this file).\n  //\n  // Usage:\n  //\n  // jQuery.fn.hashchange.domain = document.domain;\n\n  // Property: jQuery.fn.hashchange.src\n  //\n  // If, for some reason, you need to specify an Iframe src file (for example,\n  // when setting document.domain as in <jQuery.fn.hashchange.domain>), you can\n  // do so using this property. Note that when using this property, history\n  // won't be recorded in IE6/7 until the Iframe src file loads. This property\n  // is only applicable if you are supporting IE6/7 (or IE8 operating in \"IE7\n  // compatibility\" mode).\n  //\n  // Usage:\n  //\n  // jQuery.fn.hashchange.src = 'path/to/file.html';\n\n  $.fn[ str_hashchange ].delay = 50;\n  /*\n  $.fn[ str_hashchange ].domain = null;\n  $.fn[ str_hashchange ].src = null;\n  */\n\n  // Event: hashchange event\n  //\n  // Fired when location.hash changes. In browsers that support it, the native\n  // HTML5 window.onhashchange event is used, otherwise a polling loop is\n  // initialized, running every <jQuery.fn.hashchange.delay> milliseconds to\n  // see if the hash has changed. In IE6/7 (and IE8 operating in \"IE7\n  // compatibility\" mode), a hidden Iframe is created to allow the back button\n  // and hash-based history to work.\n  //\n  // Usage as described in <jQuery.fn.hashchange>:\n  //\n  // > // Bind an event handler.\n  // > jQuery(window).hashchange( function(e) {\n  // >   var hash = location.hash;\n  // >   ...\n  // > });\n  // >\n  // > // Manually trigger the event handler.\n  // > jQuery(window).hashchange();\n  //\n  // A more verbose usage that allows for event namespacing:\n  //\n  // > // Bind an event handler.\n  // > jQuery(window).bind( 'hashchange', function(e) {\n  // >   var hash = location.hash;\n  // >   ...\n  // > });\n  // >\n  // > // Manually trigger the event handler.\n  // > jQuery(window).trigger( 'hashchange' );\n  //\n  // Additional Notes:\n  //\n  // * The polling loop and Iframe are not created until at least one handler\n  //   is actually bound to the 'hashchange' event.\n  // * If you need the bound handler(s) to execute immediately, in cases where\n  //   a location.hash exists on page load, via bookmark or page refresh for\n  //   example, use jQuery(window).hashchange() or the more verbose\n  //   jQuery(window).trigger( 'hashchange' ).\n  // * The event can be bound before DOM ready, but since it won't be usable\n  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is\n  //   to bind it inside a DOM ready handler.\n\n  // Override existing $.event.special.hashchange methods (allowing this plugin\n  // to be defined after jQuery BBQ in BBQ's source code).\n  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {\n\n    // Called only when the first 'hashchange' event is bound to window.\n    setup: function() {\n      // If window.onhashchange is supported natively, there's nothing to do..\n      if ( supports_onhashchange ) { return false; }\n\n      // Otherwise, we need to create our own. And we don't want to call this\n      // until the user binds to the event, just in case they never do, since it\n      // will create a polling loop and possibly even a hidden Iframe.\n      $( fake_onhashchange.start );\n    },\n\n    // Called only when the last 'hashchange' event is unbound from window.\n    teardown: function() {\n      // If window.onhashchange is supported natively, there's nothing to do..\n      if ( supports_onhashchange ) { return false; }\n\n      // Otherwise, we need to stop ours (if possible).\n      $( fake_onhashchange.stop );\n    }\n\n  });\n\n  // fake_onhashchange does all the work of triggering the window.onhashchange\n  // event for browsers that don't natively support it, including creating a\n  // polling loop to watch for hash changes and in IE 6/7 creating a hidden\n  // Iframe to enable back and forward.\n  fake_onhashchange = (function(){\n    var self = {},\n      timeout_id,\n\n      // Remember the initial hash so it doesn't get triggered immediately.\n      last_hash = get_fragment(),\n\n      fn_retval = function(val){ return val; },\n      history_set = fn_retval,\n      history_get = fn_retval;\n\n    // Start the polling loop.\n    self.start = function() {\n      timeout_id || poll();\n    };\n\n    // Stop the polling loop.\n    self.stop = function() {\n      timeout_id && clearTimeout( timeout_id );\n      timeout_id = undefined;\n    };\n\n    // This polling loop checks every $.fn.hashchange.delay milliseconds to see\n    // if location.hash has changed, and triggers the 'hashchange' event on\n    // window when necessary.\n    function poll() {\n      var hash = get_fragment(),\n        history_hash = history_get( last_hash );\n\n      if ( hash !== last_hash ) {\n        history_set( last_hash = hash, history_hash );\n\n        $(window).trigger( str_hashchange );\n\n      } else if ( history_hash !== last_hash ) {\n        location.href = location.href.replace( /#.*/, '' ) + history_hash;\n      }\n\n      timeout_id = setTimeout( poll, $.fn[ str_hashchange ].delay );\n    };\n\n    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n    // vvvvvvvvvvvvvvvvvvv REMOVE IF NOT SUPPORTING IE6/7/8 vvvvvvvvvvvvvvvvvvv\n    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n    var ua = navigator.userAgent.toLowerCase();\n    var browser = {\n       msie: /msie/.test(ua) && !/opera/.test(ua)\n    };\n    browser.msie && !supports_onhashchange && (function(){\n      // Not only do IE6/7 need the \"magical\" Iframe treatment, but so does IE8\n      // when running in \"IE7 compatibility\" mode.\n\n      var iframe,\n        iframe_src;\n\n      // When the event is bound and polling starts in IE 6/7, create a hidden\n      // Iframe for history handling.\n      self.start = function(){\n        if ( !iframe ) {\n          iframe_src = $.fn[ str_hashchange ].src;\n          iframe_src = iframe_src && iframe_src + get_fragment();\n\n          // Create hidden Iframe. Attempt to make Iframe as hidden as possible\n          // by using techniques from http://www.paciellogroup.com/blog/?p=604.\n          iframe = $('<iframe tabindex=\"-1\" title=\"empty\"/>').hide()\n\n            // When Iframe has completely loaded, initialize the history and\n            // start polling.\n            .one( 'load', function(){\n              iframe_src || history_set( get_fragment() );\n              poll();\n            })\n\n            // Load Iframe src if specified, otherwise nothing.\n            .attr( 'src', iframe_src || 'javascript:0' )\n\n            // Append Iframe after the end of the body to prevent unnecessary\n            // initial page scrolling (yes, this works).\n            .insertAfter( 'body' )[0].contentWindow;\n\n          // Whenever `document.title` changes, update the Iframe's title to\n          // prettify the back/next history menu entries. Since IE sometimes\n          // errors with \"Unspecified error\" the very first time this is set\n          // (yes, very useful) wrap this with a try/catch block.\n          doc.onpropertychange = function(){\n            try {\n              if ( event.propertyName === 'title' ) {\n                iframe.document.title = doc.title;\n              }\n            } catch(e) {}\n          };\n\n        }\n      };\n\n      // Override the \"stop\" method since an IE6/7 Iframe was created. Even\n      // if there are no longer any bound event handlers, the polling loop\n      // is still necessary for back/next to work at all!\n      self.stop = fn_retval;\n\n      // Get history by looking at the hidden Iframe's location.hash.\n      history_get = function() {\n        return get_fragment( iframe.location.href );\n      };\n\n      // Set a new history item by opening and then closing the Iframe\n      // document, *then* setting its location.hash. If document.domain has\n      // been set, update that as well.\n      history_set = function( hash, history_hash ) {\n        var iframe_doc = iframe.document,\n          domain = $.fn[ str_hashchange ].domain;\n\n        if ( hash !== history_hash ) {\n          // Update Iframe with any initial `document.title` that might be set.\n          iframe_doc.title = doc.title;\n\n          // Opening the Iframe's document after it has been closed is what\n          // actually adds a history entry.\n          iframe_doc.open();\n\n          // Set document.domain for the Iframe document as well, if necessary.\n          domain && iframe_doc.write( '<script>document.domain=\"' + domain + '\"</script>' );\n\n          iframe_doc.close();\n\n          // Update the Iframe's hash, for great justice.\n          iframe.location.hash = hash;\n        }\n      };\n\n    })();\n    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    // ^^^^^^^^^^^^^^^^^^^ REMOVE IF NOT SUPPORTING IE6/7/8 ^^^^^^^^^^^^^^^^^^^\n    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n    return self;\n  })();\n\n})(jQuery,this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./web_modules/jquery.ba-bbq.js\n ** module id = 23\n ** module chunks = 0\n **/"],"sourceRoot":""}